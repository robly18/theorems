\documentclass{report}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{comment}
\usepackage[utf8]{inputenc}
\usepackage[portuguese]{babel}
\usepackage{hyperref}
\usepackage{indentfirst}

%para desenhar árvores sintáticas
\usepackage{tikz}
\usepackage{tikz-qtree}
\tikzset{level distance=2em}

\usepackage{graphicx}


\title{Lógica}
\author{}
\date{}

\newtheorem{prop}{Proposição}

\theoremstyle{definition}
\newtheorem{definicao}{Definição}
\newtheorem*{definicao*}{Definição}

\theoremstyle{remark}
\newtheorem{obs}{Obs}

\addto\captionsportuguese{
	\renewcommand{\proofname}{Dem}
}

\renewcommand{\bf}[1]{\mathbf{#1}}

\newcommand{\F}{\mathrm{F}}

\newcommand{\lt}{\mathrm{T}}
\newcommand{\lf}{\mathrm{F}}

\DeclareMathOperator{\var}{Var}


\DeclareMathOperator{\pnot}{\texttt{not}}
\newcommand{\pand}{\mathbin{\texttt{and}}}
\newcommand{\por}{\mathbin{\texttt{or}}}

\begin{document}
	\maketitle
	\newpage
	
	\tableofcontents
	\newpage
	
	\chapter{Lógica Proposicional}
	
	\section{Semântica}
	
	A lógica proposicional é um sistema que nos permite expressar raciocínios sobre afirmações e relações entre elas.
	
	Mais concretamente, é um sistema no qual as variáveis representam afirmações, que tomam o valor `verdadeiro' e `falso', juntamente com um conjunto de operações lógicas com as quais o leitor já estará familiar, por exemplo o `ou' e o `não'.
	
	Não é preciso procurar muito para descobrir que este sistema não tem apenas interesse teórico. Qualquer linguagem de programação em uso regular terá este sistema contido no seu funcionamento. Tome-se o exemplo da linguagem Python. Nesta linguagem, as variáveis podem ser do tipo \texttt{bool}. Uma variável deste tipo toma um de dois valores: \texttt{True} e \texttt{False}. Existem também os operadores \texttt{and}, \texttt{or} e \texttt{not}, que recebem valores booleanos e retornam valores booleanos. O uso de parênteses permite-nos agrupar expressões, de modo a formar expressões mais complexas. Por exemplo, \texttt{(a and b) or not (b or not c)} é uma expressão válida em Python (assumindo que as variáveis \texttt{a}, \texttt{b} e \texttt{c} estão definidas e são do tipo \texttt{bool}.)
	
	Formalizaremos e estudaremos este sistema, usando-o como `caixa de areia' para nos preparar para a lógica de primeira ordem, que apesar de semelhante, é significativamente mais complexa.
	
	\subsection{Noções básicas (Preliminar)}
	
	Esta subsecção tem o sufixo `Preliminar' porque não é final. Isto é, algumas das definições e demonstrações aqui dadas não correspondem às definições que serão usadas no resto do livro. No entanto, as definições `refinadas' poderão ser um pouco confusas e mal motivadas quando vistas pela primeira vez, pelo que aqui nos focamos em dar uma ideia intuitiva e `em bruto' das noções em jogo.
	
	\bigskip
	
	De modo a conseguirmos raciocinar sobre afirmações, precisamos de saber o que é uma fórmula. Intuitivamente, uma fórmula é uma sequência de variáveis, operações e parênteses. Por exemplo, a expressão $(a \land b) \lor \neg (b \lor \neg c)$ é um exemplo de uma fórmula.
	
	Claro que esta `definição' deixa muito a desejar. Apresentamos agora uma definição mais rigorosa.
	
	Fixe-se, primeiro, um conjunto, que usaremos em tudo o que se segue, chamado o conjunto das variáveis. Isto é apenas um conjunto infinito contável\footnote{Algo estranhamente, a cardinalidade exata deste conjunto é relevante. Bastantes argumentos que faremos de futuro necessitam explicitamente da contabilidade de $X$!} de símbolos $X$. Normalmente usamos variáveis como $x$, $y$, $p$, $q$, e permitimos a modificação de símbolos como a adição de apóstrofos ou asteriscos. Os símbolos $c$, $c'$, $c^*$ são considerados distintos. Usaremos a convenção que variáveis serão representadas por letras romanas minúsculas.
	
	\begin{obs}
	Há a necessidade de distinguir uma variável de uma `meta-variável'. Isto é: se falamos na variável $x$, poderá ser ambíguo se nos referimos ao elemento $x \in X$ ou se a letra $x$ é uma incógnita que pode significar uma variável arbitrária.
	
	Para evitar esta ambíguidade, representamos meta-variáveis a negrito: $\bf{x}$. Ou seja: $x$ é o elemento de $X$, enquanto que $\bf x$ é uma incógnita que pode ser substituída por qualquer variável: $x$, $y$, $z$, \dots
	\end{obs}
	
	Há quem defina, agora, fórmulas como sequências de símbolos. Isto parece ser uma definição intuitiva, visto que é assim que representamos fórmulas: sequências de caracteres. No entanto, visto que no futuro teremos que escrever programas que lêm e interpretam estas fórmulas, é mais conveniente definirmos fórmulas pelas respetivas árvores semânticas.
	
	Para esclarecer o que se entende por isto, considere-se a expressão $a \lor b$. Isto consiste de um operador (o operador `ou') aplicado a duas variáveis. Podemos representar isto como uma árvore na seguinte forma:
	
	\begin{center}
	\Tree [.\texttt{or} $a$ $b$ ]
	\end{center}
	
	Podemos, no entanto, considerar expressões mais complexas. Por exemplo, considere-se a expressão $(a \land b) \lor \neg (b \lor \neg c)$. Interpretada como uma árvore, esta expressão fica
	
	\begin{center}
	\Tree [.\texttt{or} [.\texttt{and} $a$ $b$ ] [.\texttt{not} [.\texttt{or} $b$ [.\texttt{not} $c$ ] ] ] ]
	\end{center}
	
	Para os nossos propósitos, é mais fácil manipular àrvores do que sequências de caracteres.
	
	Estamos agora prontos para dar uma definição preliminar de fórmula.
	
	\begin{definicao*}
	\textbf{Nota: Esta não é a definição final e está aqui para o propósito de motivar o que se segue.} Um leitor que queira ver a definição final poderá saltar para a página \pageref{def:formulaproposicional}
	
	Definimos o conjunto das fórmulas booleanas $\F_b$ (sobre o conjunto $X$, que deixamos implícito) indutivamente.
	
	Qualquer variável $\bf x$ é uma fórmula.
	
	Se $\alpha$ e $\beta$ são fórmulas, todos os seguintes são fórmulas:
	
	\begin{center}
	\Tree [.\texttt{not} $\alpha$ ]
	\hspace{3em}
	\Tree [.\texttt{and} $\alpha$ $\beta$ ]
	\hspace{3em}
	\Tree [.\texttt{or} $\alpha$ $\beta$ ]
	\hspace{3em}
	\scalebox{2}{$\dots$}
	\end{center}
	\end{definicao*}
	
	O leitor poderia adicionar mais operadores se assim o desejasse. Pelo momento, trabalharemos apenas com estes três.
	
	Apesar de, neste texto, definirmos fórmulas como árvores sintáticas, este formato não é prático para efeitos tipográficos. Assim sendo, continuaremos a escrever fórmulas de forma linear, tendo sempre em mente que as nossas sequências de caracteres representam uma árvore sintática.
	
	Fórmulas são normalmente denotadas por letras gregas minúsculas.
	
	\bigskip
	
	Há vários conceitos naturais que gostaríamos de definir relacionados com fórmulas, o primeiro dos quais será, dada uma fórmula $\varphi$, \emph{o conjunto das variáveis em $\varphi$}. Denotamos isto por $\var \varphi$, e usamos este conceito para exemplificar a noção de \emph{definição indutiva}.
	
	De facto, visto que definimos as fórmulas de forma indutiva, muitas das definições e demonstrações que se seguem vão tomar a forma:
	
	\begin{itemize}
	\item Provar/definir algo para as fórmulas base ($\bf x$);
	
	\item Tendo este algo definido/provado para um par de fórmulas $\alpha$ e $\beta$, defini-lo/prová-lo para $\neg \alpha$, $\alpha \land \beta$ e $\alpha \lor \beta$.
	\end{itemize}
	
	No caso da noção $\var \varphi$, definimos simplesmente:
	
	\begin{gather*}
	\var \bf x = \{\bf x\}\\
	\var \neg \alpha = \var \alpha\\
	\var (\alpha \land \beta) = \var (\alpha \lor \beta) = \var \alpha \cup \var \beta
	\end{gather*}
	
	Dada uma fórmula $\varphi$ com variáveis $a$, $b$, $c$, \dots, queremos, dada uma associação entre as variáveis e valores de verdade, `interpretar a fórmula $\varphi$'. Isto corresponde a substituir cada variável pelo seu valor de verdade, seguido de `fazer as contas'.
	
	Para tornar esta noção mais rigorosa, é primeiro necessário formalizar a noção de `associar valores de verdade a variáveis'.
	
	Uma valoração é uma função $\rho : X \to \{\lt, \lf\}$, onde $\lt$ e $\lf$ são símbolos que representam os valores de verdade `verdadeiro' e `falso'. Ou seja, $\rho$ associa a cada $\bf x \in X$ um valor de verdade $\rho(\bf x)$.
	
	Existem operações que podem ser feitas a valores de verdade. Usemos o exemplo dos operadores na linguagem Python: $\pnot$, $\pand$ e $\por$. Estes são funções que pegam em um ou dois valores de verdade e devolvem outro valor de verdade. Mais concretamente:
	
	\begin{itemize}
	\item $\pnot \lt = \lf$; $\pnot \lf = \lt$;
	
	\item $x \pand y$ é $\lt$ se $x = y = \lt$; caso contrário é $\lf$.
	
	\item $x \por y$ é $\lf$ se $x = y = \lf$; caso contrário é $\lt$.
	\end{itemize}
	
	Fixos uma fórmula $\varphi$ e uma valoração $\rho$, definimos a interpretação de $\varphi$ por $\rho$ da seguinte forma:
	
	\begin{itemize}
	\item Se $\varphi$ é uma fórmula do tipo $\bf x$, $\rho(\varphi)$ já está definido (como $\rho(\bf x)$).
	
	\item Se $\varphi$ é da forma $\neg \alpha$, $\alpha \land \beta$ ou $\alpha \lor \beta$, $\rho(\varphi)$ é definido como $\pnot \rho(\alpha)$, $\rho(\alpha) \pand \rho(\beta)$ e $\rho(\alpha) \por \rho(\beta)$, respetivamente.
	\end{itemize}
	
	\pagebreak
	
	\begin{definicao}\label{def:formulaproposicional}
	inserir def a serio
	\end{definicao}
	
	\subsection{Regras de dedução}
	
	Expôr regras que nos permitem concluir que certas coisas são consequências de outras sem ter de verificar todos os casos possíveis.
	
	\section{Sintática}
	
	Usar as regras de dedução da secção anterior para motivar a ideia de uma sequência de regras puramente sintáticas para discernir verdade de falsidade.
	
	Realçar a importância futura de regras sintáticas: em universos mais complicados, verificar todos os casos é impossível (visto que há frequentemente um número bastante infinito de casos). Como tal, é útil ter um método puramente sintático que nos permite descobrir verdades (e todas as verdades!).
	
	Concluír que, como objetivo, desejamos provar que algo é possível de provar sse é verdade.
	
	\subsection{Definições básicas}
	
	Expôr as definições de: demonstração, teorema, teoria. Introduzir a ideia de indução em fórmulas. Demonstrar a correção do cálculo.
	
	\subsection{Intuição}
	
	Secção opcional que discute os axiomas escolhidos e o porquê da sua escolha, elaborando como um matemático curioso poderia ter a eles chegado por si mesmo.
	
	\subsection{Metateoremas}
	
	Traduzir as regras de dedução feitas anteriormente para o contexto de sintaxe.
	
	\subsection{Completude}
	
	Demonstrar a completude do cálculo, dados os axiomas apropriados.
	
	\chapter{Lógica de primeira ordem}
	
	Introdução à lógica de primeira ordem, culminando no teorema da completude de Gödel.
	
	\chapter{Introdução à computação}
	
	Introdução à teoria das funções computáveis, ligando-a à lógica de primeira ordem, culminando nos teoremas de incompletude de Gödel.
	

\end{document}