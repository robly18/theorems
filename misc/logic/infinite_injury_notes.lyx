#LyX 2.4 created this file. For more info see https://www.lyx.org/
\lyxformat 620
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble

\usepackage{listings}
\lstset{
basicstyle=\ttfamily\footnotesize,
keepspaces=true,
tabsize=4,
breaklines=true,
columns=fullflexible,
mathescape=true
}
\usepackage{fullpage}
\usepackage{tikz}
\usepackage{braket}
\end_preamble
\use_default_options true
\begin_modules
duarte_theorems
enumitem
\end_modules
\maintain_unincluded_children no
\language english
\language_package default
\inputencoding auto-legacy
\fontencoding auto
\font_roman "lmodern" "default"
\font_sans "lmss" "default"
\font_typewriter "lmtt" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_roman_osf false
\font_sans_osf false
\font_typewriter_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\float_alignment class
\paperfontsize default
\spacing single
\use_hyperref false
\papersize letter
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_formatted_ref 0
\use_minted 0
\use_lineno 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tablestyle default
\tracking_changes false
\output_changes false
\change_bars false
\postpone_fragile_content false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\docbook_table_output 0
\docbook_mathml_prefix 1
\end_header

\begin_body

\begin_layout Title
Notes on Infinite Injury
\end_layout

\begin_layout Author
Duarte Maia
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "C:/Users/gaming/Desktop/theorems/misc/lyx/macros_logic.lyx"
literal "false"

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Infinite injury is causing me a major headache,
 so I'm trying to write down my thoughts on it for posteriority.
 Sourced mostly from Soare's book 
\begin_inset CommandInset citation
LatexCommand cite
key "soare1"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Section
Thick Subset Lemma
\end_layout

\begin_layout Lemma
Let 
\begin_inset Formula $B$
\end_inset

 be c.e.
\begin_inset space \space{}
\end_inset

and let 
\begin_inset Formula $C$
\end_inset

 be 
\begin_inset Formula $\Delta_{2}$
\end_inset

,
 such that no finite amount of columns of 
\begin_inset Formula $B$
\end_inset

 compute 
\begin_inset Formula $C$
\end_inset

.
 Then,
 there is a thick c.e.
\begin_inset space \space{}
\end_inset

subset 
\begin_inset Formula $A$
\end_inset

 of 
\begin_inset Formula $B$
\end_inset

 (thick meaning that every column of 
\begin_inset Formula $A$
\end_inset

 differs finitely much from the corresponding column of 
\begin_inset Formula $B$
\end_inset

) that does not compute 
\begin_inset Formula $C$
\end_inset

.
\end_layout

\begin_layout Proof
Here is how the construction shall work:
 We will have a countable number of workers,
 indexed on the natural numbers,
 placing 
\begin_inset Quotes eld
\end_inset

locks
\begin_inset Quotes erd
\end_inset

 on the elements of 
\begin_inset Formula $\N$
\end_inset

.
 In parallel,
 we shall have a worker looking at the elements of 
\begin_inset Formula $B$
\end_inset

 and attempting to enumerate them into 
\begin_inset Formula $A$
\end_inset

,
 with the restriction that an element can be placed into 
\begin_inset Formula $A$
\end_inset

 (and 
\emph on
will
\emph default
 be placed into 
\begin_inset Formula $A$
\end_inset

) only if this does not contradict any of the locks in place.
\end_layout

\begin_layout Proof
Here is a description of lock 
\begin_inset Formula $e$
\end_inset

.
 First,
 it will 
\emph on
never
\emph default
 lock any elements of the first 
\begin_inset Formula $e$
\end_inset

 columns.
 The corresponding worker shall attempt to compute/approximate an initial segment 
\begin_inset Formula $\Phi_{e}^{A}$
\end_inset

 and compare it with a fixed limit approximation of 
\begin_inset Formula $C$
\end_inset

.
 The lock will be placed up to the use of the longest initial segment of 
\begin_inset Formula $\Phi_{e}^{A}$
\end_inset

 that is found to agree with 
\begin_inset Formula $C$
\end_inset

,
 plus the first element that is found to disagree.
 If,
 on this initial segment,
 an element is added to the first 
\begin_inset Formula $e$
\end_inset

 columns of 
\begin_inset Formula $A$
\end_inset

 (which this lock cannot stop),
 the lock is rolled back up to the use of the longest initial segment whose computation was not affected,
 even potentially (i.e.
\begin_inset space \space{}
\end_inset

the use didn't reach it),
 by this change in 
\begin_inset Formula $A$
\end_inset

.
 On the other hand,
 if the approximation of 
\begin_inset Formula $C$
\end_inset

 changes so that it no longer matches 
\begin_inset Formula $\Phi_{e}^{A}$
\end_inset

,
 we keep the lock in place,
 nevermore advancing unless 
\begin_inset Formula $C$
\end_inset

 changes its mind again.
\end_layout

\begin_layout Proof
This description evidently creates a c.e.
\begin_inset space \space{}
\end_inset

subset of 
\begin_inset Formula $B$
\end_inset

.
 Let us investigate the behavior of 
\begin_inset Formula $\Phi_{e}^{A}$
\end_inset

 for different values of 
\begin_inset Formula $e$
\end_inset

,
 starting with 
\begin_inset Formula $e=0$
\end_inset

.
\end_layout

\begin_layout Proof
The lock corresponding to 
\begin_inset Formula $e=0$
\end_inset

 is never broken.
 Now,
 let us look at 
\begin_inset Formula $\Phi_{0}^{A}$
\end_inset

 and its approximations.
 If,
 per chance,
 
\begin_inset Formula $\Phi_{0}^{A}=C$
\end_inset

,
 then we would get that 
\begin_inset Formula $C$
\end_inset

 is computable,
 because we could look at the approximations of 
\begin_inset Formula $\Phi_{0}^{A}$
\end_inset

,
 and since any lock put in place is never removed,
 the first approximation that is found to agree with an initial segment of 
\begin_inset Formula $C$
\end_inset

 is fixed,
 and this is computably searchable.
 Thus,
 if 
\begin_inset Formula $\Phi_{0}^{A}=C$
\end_inset

 then 
\begin_inset Formula $\Phi_{0}^{A}$
\end_inset

 is computable and hence 
\begin_inset Formula $C$
\end_inset

 is computable,
 which is not true.
\end_layout

\begin_layout Proof
Let 
\begin_inset Formula $x$
\end_inset

 be the first value on which 
\begin_inset Formula $\Phi_{0}^{A}(x)$
\end_inset

 disagrees with 
\begin_inset Formula $C(x)$
\end_inset

.
 This may happen because 
\begin_inset Formula $\Phi_{0}^{A}(x)$
\end_inset

 is well-defined but differs from 
\begin_inset Formula $C(x)$
\end_inset

,
 or because it does not halt.
 If it is well-defined,
 eventually all elements of 
\begin_inset Formula $A$
\end_inset

 used by this computation will be put in place,
 and 
\begin_inset Formula $C(x)$
\end_inset

 will converge to its true value,
 and lock 
\begin_inset Formula $0$
\end_inset

 will never advance from this moment onward.
 If it is not well-defined:
 Pick a time after which 
\begin_inset Formula $\Phi_{0}^{A}=C$
\end_inset

 before 
\begin_inset Formula $x$
\end_inset

.
 After this time,
 no approximation of 
\begin_inset Formula $\Phi_{0}^{A}(x)$
\end_inset

 may halt,
 because if it did it would be locked in place.
 In either case,
 we conclude that lock 0 converges to a finite value.
\end_layout

\begin_layout Proof
Let us now look at the first column of 
\begin_inset Formula $A$
\end_inset

,
 and show that it is computable from the first column of 
\begin_inset Formula $B$
\end_inset

.
 This is because an element of 
\begin_inset Formula $A^{[0]}$
\end_inset

 falls into one of three cases:
\end_layout

\begin_layout Itemize
If it is not in 
\begin_inset Formula $B^{[0]}$
\end_inset

,
 it is not in 
\begin_inset Formula $A^{[0]}$
\end_inset

,
\end_layout

\begin_layout Itemize
If it is in 
\begin_inset Formula $A^{[0]}$
\end_inset

,
 this is confirmed after finitely much time,
\end_layout

\begin_layout Itemize
If it is in 
\begin_inset Formula $B^{[0]}$
\end_inset

 but not in 
\begin_inset Formula $A^{[0]}$
\end_inset

,
 this is because lock 0 moves past it before it can be added to 
\begin_inset Formula $A^{[0]}$
\end_inset

.
\end_layout

\begin_layout Standard
All of these are computable from 
\begin_inset Formula $B^{[0]}$
\end_inset

:
 Simply check if the element is in 
\begin_inset Formula $B^{[0]}$
\end_inset

,
 and if it is,
 see how long it takes to get added to 
\begin_inset Formula $B$
\end_inset

 and if the lock moves past it before then.
 Also,
 note that since the lock moves a finite amount,
 we conclude 
\begin_inset Formula $A^{[0]}=^{*}B^{[0]}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Let us now look at 
\begin_inset Formula $\Phi_{1}^{A}$
\end_inset

 and its associated lock.
 We show that 
\begin_inset Formula $\Phi_{1}^{A}$
\end_inset

 cannot equal 
\begin_inset Formula $C$
\end_inset

,
 for if it did,
 
\begin_inset Formula $C$
\end_inset

 would be computable from 
\begin_inset Formula $B^{[0]}$
\end_inset

.
 Indeed,
 consider the following process:
 Follow along the approximations of 
\begin_inset Formula $\Phi_{1}^{A}$
\end_inset

 and 
\begin_inset Formula $C$
\end_inset

 until the desired element 
\begin_inset Formula $x$
\end_inset

 is locked by lock 1.
 At this point,
 use 
\begin_inset Formula $B^{[0]}$
\end_inset

 to check if all elements of 
\begin_inset Formula $A^{[0]}$
\end_inset

 necessary for the computation (and all prior computations) have already been added.
 If they have,
 the computation will not be injured,
 and this this is the final value of 
\begin_inset Formula $\Phi_{1}^{A}$
\end_inset

.
 If not,
 then keep waiting – it will eventually happen.
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $x$
\end_inset

 be the first value on which 
\begin_inset Formula $\Phi_{1}^{A}(x)$
\end_inset

 disagrees with 
\begin_inset Formula $C(x)$
\end_inset

.
 This may happen because 
\begin_inset Formula $\Phi_{1}^{A}(x)$
\end_inset

 is well-defined but differs from 
\begin_inset Formula $C(x)$
\end_inset

,
 or because it does not halt.
 If it is well-defined,
 then eventually all elements of 
\begin_inset Formula $A$
\end_inset

 used by this computation will be put in place,
 
\begin_inset Formula $C(x)$
\end_inset

 will converge to its true value,
 and lock 1 will never advance from this moment onward.
 However,
 if it is not well-defined,
 it may happen that approximations of 
\begin_inset Formula $\Phi_{1}^{A}(x)$
\end_inset

 may converge for arbitrarily large times,
 but be consistently injured.
 Thus,
 the approximations of the lock no longer furnish a lower bound for the elements that are permanently locked.
\end_layout

\begin_layout Standard
Here is such a lower bound,
 that allows us to compute 
\begin_inset Formula $A^{[\leq1]}$
\end_inset

 from 
\begin_inset Formula $B^{[\leq1]}$
\end_inset

.
 Consider the stages 
\begin_inset Formula $t\in T_{0}$
\end_inset

 that satisfy the property:
 Someone has just been added to 
\begin_inset Formula $B^{[0]}$
\end_inset

,
 and no one before it will be added to 
\begin_inset Formula $B^{[0]}$
\end_inset

 again.
 At such stages,
 lock 1 will never regress past what it currently is,
 and here is why:
 Suppose that,
 at this moment,
 the lock has locked the use up to a value of 
\begin_inset Formula $x$
\end_inset

.
 Then,
 the only way for the lock to regress is if someone is added behind the use of the elements up to 
\begin_inset Formula $x$
\end_inset

.
 But none of these elements use anyone past the new element (because,
 if they did,
 the lock would have regressed further),
 and by assumption no one will be added behind the new element.
 Thus,
 the lock will never regress,
 and these stages are lower bounds for everything that happens past them.
 As such,
 following the lock along these stages provides a sequence converging to the 
\begin_inset Formula $\liminf$
\end_inset

,
 and so an algorithm similar to the one used for 
\begin_inset Formula $A^{[0]}$
\end_inset

 can be used to compute 
\begin_inset Formula $A^{[1]}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Okay,
 let's see if we're able to generalize this.
 Assume by induction that we've already constructed (uniformly) a program to compute 
\begin_inset Formula $A^{[<e]}$
\end_inset

 from 
\begin_inset Formula $B^{[<e]}$
\end_inset

.
 Let us now look at 
\begin_inset Formula $\Phi_{e}^{A}$
\end_inset

.
\end_layout

\begin_layout Standard
Suppose 
\begin_inset Formula $\Phi_{e}^{A}=C$
\end_inset

.
 We show that then 
\begin_inset Formula $B^{[<e]}$
\end_inset

 computes 
\begin_inset Formula $C$
\end_inset

.
 This is because,
 to find 
\begin_inset Formula $C(x)$
\end_inset

,
 we can do the following.
 First,
 wait until the initial segment of length 
\begin_inset Formula $x$
\end_inset

 of 
\begin_inset Formula $\Phi_{e}^{A}$
\end_inset

 and 
\begin_inset Formula $C$
\end_inset

 seem to agree.
 At this point,
 ask 
\begin_inset Formula $A^{[<e]}$
\end_inset

 (computable from 
\begin_inset Formula $B^{[<e]}$
\end_inset

) if everyone it uses from 
\begin_inset Formula $A^{[<e]}$
\end_inset

 is set in stone.
 If they are,
 this computation will never be broken,
 and 
\begin_inset Formula $C(x)$
\end_inset

 is found.
 Otherwise,
 keep waiting – it will eventually happen.
\end_layout

\begin_layout Standard
Okay,
 now let us show that 
\begin_inset Formula $B^{[\leq e]}$
\end_inset

 computes 
\begin_inset Formula $A^{[\leq e]}$
\end_inset

.
 It suffices to find a lower bound for the position of locks 
\begin_inset Formula $0$
\end_inset

 through 
\begin_inset Formula $e$
\end_inset

,
 and we also assume by induction that such lower bounds have been found for all locks up to but excluding 
\begin_inset Formula $e$
\end_inset

,
 so let's do just that one.
 Consider the collection 
\begin_inset Formula $T_{e}$
\end_inset

 of stages on which someone is added to 
\begin_inset Formula $B^{[<e]}$
\end_inset

 but no one before it is ever added in the future.
 On these stages,
 lock 
\begin_inset Formula $e$
\end_inset

 is broken up to the use of 
\begin_inset Formula $\Phi_{e}^{A}$
\end_inset

 up to some 
\begin_inset Formula $x$
\end_inset

,
 none of whose elements use anyone from 
\begin_inset Formula $B^{[<e]}$
\end_inset

 behind it.
 Thus,
 at this point,
 lock 
\begin_inset Formula $e$
\end_inset

 will never again be broken,
 furnishing a lower bound.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Okay,
 let's take stock of what we have.
 We've shown that 
\begin_inset Formula $B^{[<e]}$
\end_inset

 computes 
\begin_inset Formula $A^{[<e]}$
\end_inset

 uniformly,
 and hence that 
\begin_inset Formula $B$
\end_inset

 computes 
\begin_inset Formula $A$
\end_inset

.
 We've shown that 
\begin_inset Formula $\Phi_{e}^{A}$
\end_inset

 is never equal to 
\begin_inset Formula $C$
\end_inset

.
 The only thing that remains to show is that 
\begin_inset Formula $A$
\end_inset

 is thick in 
\begin_inset Formula $B$
\end_inset

.
 To this effect,
 it suffices to find stages on which all locks up to 
\begin_inset Formula $e$
\end_inset

 equal their 
\begin_inset Formula $\liminf$
\end_inset

,
 and to show that all these 
\begin_inset Formula $\liminf$
\end_inset

s are finite.
\end_layout

\begin_layout Standard
Consider the set 
\begin_inset Formula $T$
\end_inset

 of true stages of the enumeration of 
\begin_inset Formula $A$
\end_inset

.
 (Why are they infinitely many?) We show that,
 for every particular 
\begin_inset Formula $e$
\end_inset

,
 lock 
\begin_inset Formula $e$
\end_inset

 restricted to these stages converges to a finite limit.
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $x$
\end_inset

 be the smallest value at which 
\begin_inset Formula $\Phi_{e}^{A}(x)\neq C(x)$
\end_inset

.
 If this is because 
\begin_inset Formula $\Phi_{e}^{A}(x)$
\end_inset

 halts with a different value than 
\begin_inset Formula $C(x)$
\end_inset

,
 then if we wait long enough that both of these expressions have stabilized,
 the lock will never increase again.
 If this is because 
\begin_inset Formula $\Phi_{e}^{A}(x)$
\end_inset

 does not halt,
 we show that it does not halt at any true stage of 
\begin_inset Formula $A$
\end_inset

.
 Indeed,
 if the element that has just been added to 
\begin_inset Formula $A$
\end_inset

 contributes to the value of 
\begin_inset Formula $\Phi_{e}^{A}(x)$
\end_inset

,
 the lock has just been reset to what it was for the values below 
\begin_inset Formula $x$
\end_inset

.
 If it does not contribute,
 then 
\begin_inset Formula $\Phi_{e}^{A}(x)$
\end_inset

 cannot have halted yet (otherwise it would halt at the end),
 and so the lock is also stuck at the use of values below 
\begin_inset Formula $x$
\end_inset

.
\end_layout

\begin_layout Standard
So...
 Why are there infinitely many true stages of 
\begin_inset Formula $A$
\end_inset

?
 There are two cases:
 Either every column of 
\begin_inset Formula $B$
\end_inset

 is finite (in which case any subset of 
\begin_inset Formula $B$
\end_inset

 is thick in it),
 or there is a first infinite column 
\begin_inset Formula $B^{[e]}$
\end_inset

.
 In the latter case,
 note that all locks before 
\begin_inset Formula $e$
\end_inset

 get injured finitely often,
 and therefore can grow finitely much.
 Now,
 wait until all elements that were ever going to agree with 
\begin_inset Formula $C$
\end_inset

 do,
 and that 
\begin_inset Formula $C$
\end_inset

 itself has stabilized in this initial segment 
\begin_inset Formula $x$
\end_inset

.
 Then,
 either 
\begin_inset Formula $\Phi_{e}^{A}(x)$
\end_inset

 is well-defined but disagrees with 
\begin_inset Formula $C$
\end_inset

,
 in which case this lock also grows finitely much and so 
\begin_inset Formula $A^{[e]}$
\end_inset

 is infinite,
 or it fails to terminate,
 in which case it shall be reset every true stage of 
\begin_inset Formula $B^{[e]}$
\end_inset

 by an argument similar to previous cases.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "bibliography"
options "plain"
encoding "default"

\end_inset


\end_layout

\end_body
\end_document
