#LyX 2.4 created this file. For more info see https://www.lyx.org/
\lyxformat 620
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{amsmath}
\usepackage{listings}
\lstset{
basicstyle=\ttfamily\footnotesize,
keepspaces=true,
tabsize=4,
breaklines=true,
columns=fullflexible,
mathescape=true
}
\usepackage{fullpage}
\usepackage{tikz}
\usetikzlibrary{shapes}
\usetikzlibrary{positioning}
\usepackage{braket}
\end_preamble
\use_default_options true
\begin_modules
duarte_theorems
enumitem
\end_modules
\maintain_unincluded_children no
\language english
\language_package default
\inputencoding auto-legacy
\fontencoding auto
\font_roman "lmodern" "default"
\font_sans "lmss" "default"
\font_typewriter "lmtt" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_roman_osf false
\font_sans_osf false
\font_typewriter_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\float_alignment class
\paperfontsize default
\spacing single
\use_hyperref false
\papersize letter
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_formatted_ref 0
\use_minted 0
\use_lineno 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tablestyle default
\tracking_changes false
\output_changes false
\change_bars false
\postpone_fragile_content false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\docbook_table_output 0
\docbook_mathml_prefix 1
\end_header

\begin_body

\begin_layout Title
Approximating 
\begin_inset Formula $\Sigma_{n}$
\end_inset

 Classes by 
\begin_inset Formula $\Sigma_{n}$
\end_inset

 Opens
\end_layout

\begin_layout Author
Duarte Maia
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "C:/Users/gaming/Desktop/theorems/misc/lyx/macros_logic.lyx"
literal "false"

\end_inset


\begin_inset FormulaMacro
\newcommand{\calC}{\mathcal{C}}
\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
The context for this document is Section 6.8 of 
\begin_inset CommandInset citation
LatexCommand cite
key "algrand_downey_hirschfeldt"
literal "false"

\end_inset

.
 In trying to read it,
 more than in other sections,
 I found that I was not appropriately appreciating the distinction between a 
\begin_inset Formula $\Sigma_{n}$
\end_inset

 class an an open generated by a 
\begin_inset Formula $\Sigma_{n}$
\end_inset

 set,
 because the difference is not relevant in the 
\begin_inset Formula $n=1$
\end_inset

 case.
 In this document,
 I will clarify (to myself) the distinction,
 and subsequently prove a relevant approximation lemma.
\end_layout

\begin_layout Section
Classes vs.
 Opens
\end_layout

\begin_layout Standard
First,
 let us be clear about the spaces of discussion.
 On one hand,
 we have the space of finite strings 
\begin_inset Formula $2^{<\omega}$
\end_inset

.
 A subset of this space is referred to as a 
\begin_inset Quotes eld
\end_inset

set of strings
\begin_inset Quotes erd
\end_inset

,
 or just as a 
\begin_inset Quotes eld
\end_inset

set
\begin_inset Quotes erd
\end_inset

.
 On the other hand,
 we have Cantor space 
\begin_inset Formula $2^{\omega}$
\end_inset

.
 A subset of this space is referred to as a 
\begin_inset Quotes eld
\end_inset

class
\begin_inset Quotes erd
\end_inset

.
 We will relentlessly fail to distinguish between the following two views on what an element of Cantor space is:
 A subset of 
\begin_inset Formula $\N$
\end_inset

,
 or a sequence of zeros and ones.
\end_layout

\begin_layout Standard
The definition of 
\begin_inset Formula $\Sigma_{n}$
\end_inset

 set and 
\begin_inset Formula $\Sigma_{n}$
\end_inset

 space is almost the same,
 with some notational distinctions.
 We will restrict ourselves to the case 
\begin_inset Formula $n\geq1$
\end_inset

.
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "def:set"

\end_inset

A 
\begin_inset Formula $\Sigma_{n}$
\end_inset

 set of strings is a set of the form
\begin_inset Formula 
\[
A=\{\,\sigma\in2^{<\omega}\mid\exists_{x_{1}}\forall_{x_{2}}\dots Q_{x_{n}}P(\sigma,x_{1},\dots,x_{n})\,\},
\]

\end_inset

where 
\begin_inset Formula $P$
\end_inset

 is a recursive predicate.
 
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "def:class"

\end_inset

A 
\begin_inset Formula $\Sigma_{n}$
\end_inset

 class is a collection of sets of numbers of the form
\begin_inset Formula 
\[
\mathcal{C}=\{\,A\in2^{\omega}\mid\exists_{x_{1}}\forall_{x_{2}}\dots Q_{x_{n}}P(A,x_{1},\dots,x_{n})\,\},
\]

\end_inset

where 
\begin_inset Formula $P$
\end_inset

 is a recursive predicate.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "def:index"

\end_inset

An 
\emph on
index
\emph default
 for a 
\begin_inset Formula $\Sigma_{n}$
\end_inset

 set/class consists of an index for the recursive predicate 
\begin_inset Formula $P$
\end_inset

.
\end_layout

\begin_layout Standard
It is worth going into a little more depth about the meaning of 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $P$
\end_inset

 is a recursive predicate
\begin_inset Quotes erd
\end_inset

 in Definition 
\begin_inset CommandInset ref
LatexCommand ref
reference "def:class"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 notably when it comes to the meaning of 
\begin_inset Formula $A$
\end_inset

 being given as input.
 One way to see it is one that can be computed by a Turing machine whose initial tape contains the tuple 
\begin_inset Formula $\vec{x}=\braket{x_{1},\dots,x_{n}}$
\end_inset

 and that has access to 
\begin_inset Formula $A$
\end_inset

 as an oracle tape.
 In other words,
 we may instead write 
\begin_inset Formula $P(A,x_{1},\dots,x_{n})$
\end_inset

 as 
\begin_inset Formula $P^{A}(x_{1},\dots,x_{n})$
\end_inset

.
 Note that the recursiveness requirement means that the Turing machine in question will halt regardless of input,
 including 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Standard
Note that a finite computation can only check a finite amount of data from 
\begin_inset Formula $A$
\end_inset

.
 In other words,
 the value of 
\begin_inset Formula $P(A,x_{1},\dots,x_{n})$
\end_inset

 depends only on a certain long enough prefix of 
\begin_inset Formula $A$
\end_inset

,
 the length of which depends on the 
\begin_inset Formula $x_{i}$
\end_inset

 and on 
\begin_inset Formula $A$
\end_inset

 itself.
 It turns out,
 however,
 that given 
\begin_inset Formula $\vec{x}$
\end_inset

 we can (recursively) find a uniform bound on how long a prefix of 
\begin_inset Formula $A$
\end_inset

 is necessary to determine the value of 
\begin_inset Formula $P$
\end_inset

.
\begin_inset FormulaMacro
\newcommand{\upto}{\mathbin{\!\upharpoonright\!}}
{\mathbin{\upharpoonright}}
\end_inset


\end_layout

\begin_layout Proposition
Let 
\begin_inset Formula $P(X,x)$
\end_inset

 be a recursive predicate whose first input is an element of Cantor space and whose second input is a natural number.
 Then,
 there exists a recursive function 
\begin_inset Formula $f$
\end_inset

 such that the value of 
\begin_inset Formula $P(X,x)$
\end_inset

 depends only on 
\begin_inset Formula $X\upto f(x)$
\end_inset

.
\end_layout

\begin_layout Proof
Consider the following computable binary tree 
\begin_inset Formula $T\equiv T(x)$
\end_inset

.
 We say a string 
\begin_inset Formula $\sigma$
\end_inset

 is in 
\begin_inset Formula $T$
\end_inset

 if the computation of 
\begin_inset Formula $P(\sigma,x)$
\end_inset

 either consults elements of the input tape past the length of 
\begin_inset Formula $\sigma$
\end_inset

,
 or has not terminated after 
\begin_inset Formula $\abs{\sigma}$
\end_inset

 steps.
 Now,
 since 
\begin_inset Formula $P$
\end_inset

 is recursive and thus terminates on every input,
 there is no path through 
\begin_inset Formula $T$
\end_inset

,
 and thus 
\begin_inset Formula $T$
\end_inset

 must be finite.
 A brute force search will easily find the depth of the tree 
\begin_inset Formula $T(x)$
\end_inset

,
 which provides the desired function 
\begin_inset Formula $f(x)$
\end_inset

.
\end_layout

\begin_layout Corollary
Let 
\begin_inset Formula $P(X,x)$
\end_inset

 be a recursive predicate as above.
 Then,
 for any value of 
\begin_inset Formula $x\in\N$
\end_inset

 there is a finite collection of strings 
\begin_inset Formula $D(x)$
\end_inset

,
 computable from 
\begin_inset Formula $x$
\end_inset

,
 such that
\begin_inset Formula 
\[
P(X,x)\text{ iff }\bigvee_{\sigma\in D(x)}\sigma\leq X,
\]

\end_inset

where 
\begin_inset Formula $\sigma\leq X$
\end_inset

 means that 
\begin_inset Formula $\sigma$
\end_inset

 is a prefix of 
\begin_inset Formula $X$
\end_inset

.
\end_layout

\begin_layout Standard
Now,
 let us go back to Definition 
\begin_inset CommandInset ref
LatexCommand ref
reference "def:class"

\end_inset

,
 and let us momentarily focus on the case where 
\begin_inset Formula $Q=\exists$
\end_inset

.
 In this case,
 
\begin_inset Formula $\exists_{x_{n}}P(A,\vec{x})$
\end_inset

 may be replaced by 
\begin_inset Formula $\exists_{x_{n}}\exists_{i\leq N(\vec{x})}\sigma(\vec{x},i)\leq A,$
\end_inset

 where 
\begin_inset Formula $\sigma(\vec{x},0),\dots\sigma(\vec{x},N(\vec{x}))$
\end_inset

 is some enumeration of 
\begin_inset Formula $D(\vec{x})$
\end_inset

.
 On the other hand,
 the case where 
\begin_inset Formula $Q=\forall$
\end_inset

 may be rearranged using quantifier laws to yield
\end_layout

\begin_layout Corollary
\begin_inset CommandInset label
LatexCommand label
name "cor:opens1"

\end_inset

Every 
\begin_inset Formula $\Sigma_{n}$
\end_inset

 class may be written in the form
\begin_inset Formula 
\[
\mathcal{C}=\{\,A\in2^{\omega}\mid\exists_{x_{1}}\neg\exists_{x_{2}}\dots\neg\exists_{x_{n}}(R(\vec{x})\land\sigma(\vec{x})\leq A)\,\},
\]

\end_inset

where an index for the recursive functions 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $\sigma$
\end_inset

 may be effectively found from an index for the class.
\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rmk:writeclasses"

\end_inset

We only need to include 
\begin_inset Formula $R$
\end_inset

 in our discussion because of the possibility that,
 for some tuple 
\begin_inset Formula $\vec{x}$
\end_inset

,
 the set 
\begin_inset Formula $D(\vec{x})$
\end_inset

 is empty.
 It may be avoided by having our variables 
\begin_inset Formula $x_{i}$
\end_inset

 range over recursive/c.e.
\begin_inset space \space{}
\end_inset

sets that may depend on the previous 
\begin_inset Formula $x_{j}$
\end_inset

.
 We will take this approach henceforth.
\end_layout

\begin_layout Standard
Let us now briefly go over an important topological facet of this corollary.
 For the sake of notation,
 we will momentarily restrict our attention to 
\begin_inset Formula $n=1$
\end_inset

,
 
\begin_inset Formula $2$
\end_inset

,
 and 
\begin_inset Formula $3$
\end_inset

,
 but similar considerations hold at all levels.
\end_layout

\begin_layout Standard
Recall that we define a topology on 
\begin_inset Formula $2^{\omega}$
\end_inset

,
 which is generated by the basic open sets
\begin_inset Formula 
\[
U_{\sigma}=\{\,A\in2^{\omega}\mid\sigma\leq A\,\}.
\]

\end_inset


\end_layout

\begin_layout Standard
As a consequence,
 Corollary 
\begin_inset CommandInset ref
LatexCommand ref
reference "cor:opens1"

\end_inset

 may be interpreted as follows:
\end_layout

\begin_layout Itemize
Any 
\begin_inset Formula $\Sigma_{1}$
\end_inset

 class may be written as 
\begin_inset Formula $\mathcal{C}=\cup_{x}U_{\sigma(x)}$
\end_inset

,
\end_layout

\begin_layout Itemize
Any 
\begin_inset Formula $\Sigma_{2}$
\end_inset

 class may be written as 
\begin_inset Formula $\mathcal{C}=\cup_{x}\cap_{y}U_{\sigma(x,y)}^{c}$
\end_inset

,
\end_layout

\begin_layout Itemize
Any 
\begin_inset Formula $\Sigma_{3}$
\end_inset

 class may be written as 
\begin_inset Formula $\mathcal{C}=\cup_{x}\cap_{y}\cup_{z}U_{\sigma(x,y,z)}$
\end_inset

,
\end_layout

\begin_layout Itemize
And so on,
\end_layout

\begin_layout Standard
where in either case 
\begin_inset Formula $\sigma$
\end_inset

 is a recursive function and each variable ranges over a recursive set depending on the previous variables.
 In other words,
 
\begin_inset Formula $x$
\end_inset

 ranges over a recursive set 
\begin_inset Formula $C$
\end_inset

,
 
\begin_inset Formula $y$
\end_inset

 ranges over a uniformly recursive set 
\begin_inset Formula $C'(x)$
\end_inset

,
 and 
\begin_inset Formula $z$
\end_inset

 ranges over a uniformly recursive set 
\begin_inset Formula $C''(x,y)$
\end_inset

.
 We can also assume without loss of generality that only the 
\emph on
last
\emph default
 variable ranges over a set that varies,
 and that all variables preceding it vary over all of 
\begin_inset Formula $\N$
\end_inset

.
 It's also worth noting that everything that has been done thus far is reversible,
 and indeed in each instance the written expression determines a 
\begin_inset Formula $\Sigma_{n}$
\end_inset

 class.
\end_layout

\begin_layout Standard
Thus,
 we obtain that a 
\begin_inset Formula $\Sigma_{1}$
\end_inset

 class is an 
\begin_inset Quotes eld
\end_inset

effective open
\begin_inset Quotes erd
\end_inset

.
 In other words,
 while a 
\begin_inset Quotes eld
\end_inset

general
\begin_inset Quotes erd
\end_inset

 open is a union of basic open sets,
 a 
\begin_inset Formula $\Sigma_{1}$
\end_inset

 class is a union of basic open sets where the list of basic open sets in question can be recursively enumerated.
 In a similar vein,
 a 
\begin_inset Formula $\Sigma_{2}$
\end_inset

 class is an 
\begin_inset Quotes eld
\end_inset

effective 
\begin_inset Formula $F_{\sigma}$
\end_inset

 set
\begin_inset Quotes erd
\end_inset

,
 and so on.
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
Let us discuss this idea of 
\begin_inset Quotes eld
\end_inset

effective open
\begin_inset Quotes erd
\end_inset

 a little further.
 It lends itself to a trivial generalization:
\end_layout

\begin_layout Definition
If 
\begin_inset Formula $X$
\end_inset

 is an oracle,
 an 
\emph on

\begin_inset Formula $X$
\end_inset

-effective open
\emph default
 is a set of the form 
\begin_inset Formula $U=\cup_{x\in\N}U_{\sigma^{X}(x)}$
\end_inset

,
 where 
\begin_inset Formula $\sigma^{X}$
\end_inset

 is an 
\begin_inset Formula $X$
\end_inset

-computable enumeration of strings.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Technically,
 an edge case must be made in this definition for the case where 
\begin_inset Formula $U$
\end_inset

 is the empty set.
 This can be fixed in several ways,
 such as having the union range over an arbitrary computable/c.e.
\begin_inset space \space{}
\end_inset

set instead of 
\begin_inset Formula $\N$
\end_inset

,
 or allowing 
\begin_inset Formula $\sigma^{X}$
\end_inset

 to be nontotal.
 That said,
 the definition that follows is better in this respect.
 
\end_layout

\end_inset

 Equivalently,
 an 
\begin_inset Formula $X$
\end_inset

-effective open is a union 
\begin_inset Formula $U=\cup_{\sigma\in A}U_{\sigma}$
\end_inset

,
 where 
\begin_inset Formula $A$
\end_inset

 is an 
\begin_inset Formula $X$
\end_inset

-enumerable set.
\end_layout

\begin_layout Standard
By considering the case where 
\begin_inset Formula $X=0^{(n-1)}$
\end_inset

,
 we obtain that a 
\begin_inset Formula $0^{(n-1)}$
\end_inset

-effective open is one which is generated by a 
\begin_inset Formula $\Sigma_{n}$
\end_inset

set of basic opens,
 so we make the following definition (which I believe is not standard in the literature):
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "def:sigmanopen"

\end_inset

For 
\begin_inset Formula $n\geq1$
\end_inset

,
 a 
\emph on

\begin_inset Formula $\Sigma_{n}$
\end_inset

 open
\emph default
 means the same as a 
\begin_inset Formula $0^{(n-1)}$
\end_inset

-effective open.
\end_layout

\begin_layout Section
Relating Terms and Open Approximations
\end_layout

\begin_layout Standard
We now relate the following three objects of discussion,
 all of which are classes of subsets of Cantor space:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\Sigma_{n}$
\end_inset

 open sets.
\end_layout

\begin_layout Itemize
Open 
\begin_inset Formula $\Sigma_{n}$
\end_inset

classes,
\end_layout

\begin_layout Itemize
\begin_inset Formula $\Sigma_{n}$
\end_inset

 classes,
\end_layout

\begin_layout Standard
We now proceed to relate them.
 It is worthy of note that all the theorems that will be stated henceforth,
 as well as their proofs,
 are effective,
 but to avoid clutter we will neglect to mention that fact.
\end_layout

\begin_layout Proposition
Every 
\begin_inset Formula $\Sigma_{n}$
\end_inset

 open is a 
\begin_inset Formula $\Sigma_{n}$
\end_inset

 class.
 In particular,
\begin_inset Formula 
\[
\text{\ensuremath{\Sigma_{n}} open}\implies\text{Open \ensuremath{\Sigma_{n}} class}\implies\text{\ensuremath{\Sigma_{n}} class}.
\]

\end_inset


\end_layout

\begin_layout Proof
A 
\begin_inset Formula $\Sigma_{n}$
\end_inset

 open is of the form
\begin_inset Formula 
\[
U=\{\,A\in2^{\omega}\mid\exists_{\sigma}[(\vec{Q}_{\vec{x}}P(\sigma,\vec{x}))\land\sigma\leq A]\,\},
\]

\end_inset

where 
\begin_inset Formula $\vec{Q}_{\vec{x}}$
\end_inset

 abbreviates an alternation of 
\begin_inset Formula $n$
\end_inset

 quantifiers starting with an 
\begin_inset Formula $\exists$
\end_inset

.
 Now,
 the formula at hand can be rearranged as to make it a 
\begin_inset Formula $\Sigma_{n}$
\end_inset

 formula in 
\begin_inset Formula $A$
\end_inset

.
 To be precise,
 we get
\begin_inset Formula 
\[
U=\{\,A\in2^{\omega}\mid\exists_{\sigma}\exists_{x_{0}}\forall_{x_{1}}\dots Q_{x_{n}}(P(\sigma,\vec{x})\land\sigma\leq A)\,\}.
\]

\end_inset

Note that the predicate 
\begin_inset Formula $(A,\sigma,\vec{x})\mapsto P(\sigma,\vec{x})\land\sigma\leq A$
\end_inset

 is recursive,
 and so the proof is complete.
\end_layout

\begin_layout Standard
We now show that the three classes coincide when 
\begin_inset Formula $n=1$
\end_inset

,
 but not for 
\begin_inset Formula $n\geq2$
\end_inset

.
\end_layout

\begin_layout Proposition
\begin_inset CommandInset label
LatexCommand label
name "prop:sigma1classissigma1open"

\end_inset

Every 
\begin_inset Formula $\Sigma_{1}$
\end_inset

 class is a 
\begin_inset Formula $\Sigma_{1}$
\end_inset

 open.
\end_layout

\begin_layout Proof
A 
\begin_inset Formula $\Sigma_{1}$
\end_inset

 class 
\begin_inset Formula $\mathcal{C}$
\end_inset

 is the set of 
\begin_inset Formula $A\in2^{\omega}$
\end_inset

 satisfying 
\begin_inset Formula $\exists_{\sigma}\exists_{x}(P(\sigma,x)\land\sigma\leq A)$
\end_inset

.
 In other words,
 
\begin_inset Formula $\mathcal{C}$
\end_inset

 is the union of 
\begin_inset Formula $U_{\pi_{1}(p)}$
\end_inset

,
 where 
\begin_inset Formula $p$
\end_inset

 ranges over the set of pairs 
\begin_inset Formula $(\sigma,x)$
\end_inset

 that satisfy 
\begin_inset Formula $P(\sigma,x)$
\end_inset

,
 which is evidently enumerable.
\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\zero}{0}
\end_inset


\begin_inset FormulaMacro
\newcommand{\njmp}[1]{\zero^{(#1)}}
\end_inset


\end_layout

\begin_layout Corollary
A 
\begin_inset Formula $\Sigma_{n}$
\end_inset

 open is the same as a 
\begin_inset Formula $\Sigma_{1}^{\zero^{(n-1)}}$
\end_inset

 class,
 where the superscript denotes relativization in the obvious way.
\end_layout

\begin_layout Proof
Inspection of the proof of Proposition 
\begin_inset CommandInset ref
LatexCommand ref
reference "prop:sigma1classissigma1open"

\end_inset

 will show,
 by relativization,
 that to define a 
\begin_inset Formula $\Sigma_{1}^{\zero^{(n-1)}}$
\end_inset

 class is the same as to define a 
\begin_inset Formula $\zero^{(n-1)}$
\end_inset

-enumerable collection of basic open sets,
 i.e.
\begin_inset space \space{}
\end_inset

a 
\begin_inset Formula $\Sigma_{n}$
\end_inset

 collection of basic open sets.
\end_layout

\begin_layout Proposition
For 
\begin_inset Formula $n\geq2$
\end_inset

 there is a 
\begin_inset Formula $\Sigma_{n}$
\end_inset

 class that is not open,
 and an open 
\begin_inset Formula $\Sigma_{n}$
\end_inset

 class that is not a 
\begin_inset Formula $\Sigma_{n}$
\end_inset

 open set.
\end_layout

\begin_layout Proof
For the first part,
 it suffices to find a 
\begin_inset Formula $\Sigma_{2}$
\end_inset

 class that is not open,
 and here it is:
 The singleton 
\begin_inset Formula $\{0\}$
\end_inset

.
\end_layout

\begin_layout Proof
For the second part,
 we also reduce to the case 
\begin_inset Formula $n=2$
\end_inset

,
 by showing that there is an open 
\begin_inset Formula $\Sigma_{2}$
\end_inset

 class that is not a 
\begin_inset Formula $\Sigma_{1}^{\zero'}$
\end_inset

 class.
 The general case follows by relativization to 
\begin_inset Formula $\njmp{n-1}$
\end_inset

,
 to get an open 
\begin_inset Formula $\Sigma_{2}^{\njmp{n-1}}$
\end_inset

 class – which is easily seen to be a 
\begin_inset Formula $\Sigma_{n}$
\end_inset

 class – which is not a 
\begin_inset Formula $\Sigma_{1}^{(\njmp{n-1})'}$
\end_inset

 class,
 i.e.
\begin_inset space \space{}
\end_inset

a 
\begin_inset Formula $\Sigma_{1}^{\njmp n}$
\end_inset

 class,
 i.e.
\begin_inset space \space{}
\end_inset

a 
\begin_inset Formula $\Sigma_{n}$
\end_inset

 open.
\end_layout

\begin_layout Proof
The following argument is adapted from page 76 of 
\begin_inset CommandInset citation
LatexCommand cite
key "algrand_downey_hirschfeldt"
literal "false"

\end_inset

.
 The idea is to build an open set 
\begin_inset Formula $U$
\end_inset

 that is of the form 
\begin_inset Formula $U=2^{\omega}\setminus\{A\}$
\end_inset

,
 with 
\begin_inset Formula $A$
\end_inset

 built in such a way as not to be 
\begin_inset Formula $\zero'$
\end_inset

-computable.
 We shall ensure that 
\begin_inset Formula $A$
\end_inset

 is 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 enough that there is a 
\begin_inset Formula $\Sigma_{2}$
\end_inset

 formula that determines membership in 
\begin_inset Formula $U$
\end_inset

,
 making 
\begin_inset Formula $U$
\end_inset

 an open 
\begin_inset Formula $\Sigma_{2}$
\end_inset

 class.
 On the other hand,
 the fact that 
\begin_inset Formula $A$
\end_inset

 is not 
\begin_inset Formula $\zero'$
\end_inset

-computable will guarantee that 
\begin_inset Formula $U$
\end_inset

 is not a 
\begin_inset Formula $\Sigma_{2}$
\end_inset

 open,
 because in this case 
\begin_inset Formula $A$
\end_inset

 would be 
\begin_inset Formula $0'$
\end_inset

-computable as follows:
 To determine 
\begin_inset Formula $A(n)$
\end_inset

,
 enumerate basic open sets of 
\begin_inset Formula $U$
\end_inset

 until you've either entirely covered 
\begin_inset Formula $\{B\mid B(n)=0\}$
\end_inset

 or 
\begin_inset Formula $\{B\mid B(n)=1$
\end_inset

}.
 This happens in finite time because each of these subsets of Cantor space is compact,
 and one of them (the one which does not contain 
\begin_inset Formula $A$
\end_inset

) is contained in 
\begin_inset Formula $U$
\end_inset

.
\end_layout

\begin_layout Proof
The definition of 
\begin_inset Formula $A$
\end_inset

 requires the following lemma,
 whose proof we relegate to below:
\end_layout

\begin_deeper
\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:complicatedtree"

\end_inset

There is a computable binary tree 
\begin_inset Formula $T$
\end_inset

 that admits a unique path 
\begin_inset Formula $A$
\end_inset

 that does not terminate in infinitely many zeros.
 Moreover,
 
\begin_inset Formula $A$
\end_inset

 is not 
\begin_inset Formula $\zero'$
\end_inset

-computable.
\end_layout

\end_deeper
\begin_layout Proof
With this lemma:
 The class 
\begin_inset Formula $\{A\}$
\end_inset

 is easily seen to be a 
\begin_inset Formula $\Pi_{2}$
\end_inset

 class:
\begin_inset Formula 
\[
\{A\}=\{\,B\in2^{\omega}\mid\forall_{x}(\text{\ensuremath{A\upto x} is in \ensuremath{T}})\land\forall_{x}\exists_{y}(y>x\land A(x)=1)\,\}.
\]

\end_inset

Thus,
 the complement 
\begin_inset Formula $2^{\omega}\setminus\{A\}$
\end_inset

 is a 
\begin_inset Formula $\Sigma_{2}$
\end_inset

 class.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Proof
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:complicatedtree"

\end_inset


\end_layout

\end_inset

We shall diagonalize against every limit computable function.
 To this effect,
 let 
\begin_inset Formula $\lambda_{en}$
\end_inset

 be a partial computable universal collection of sequences of 
\begin_inset Formula $0,1$
\end_inset

-valued functions,
 with 
\begin_inset Formula $\lambda_{e}(x):=\lim_{n}\lambda_{en}(x)$
\end_inset

 being an enumeration of limit-computable 
\begin_inset Formula $0,1$
\end_inset

-valued functions.
 We will outline the way in which we diagonalize against 
\begin_inset Formula $\lambda_{0}$
\end_inset

,
 then explain how the process proceeds recursively.
\end_layout

\begin_layout Proof
The top of the tree looks as follows,
 with the left starting out as a path containing only zeros,
 and the right branch starting with 
\begin_inset Formula $1$
\end_inset

,
 followed by a tree that we call 
\begin_inset Formula $T_{0}$
\end_inset

 whose purpose will be to diagonalize against 
\begin_inset Formula $\lambda_{1}$
\end_inset

.
\end_layout

\begin_layout Proof
\begin_inset Float figure
placement document
alignment document
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1,
\end_layout

\begin_layout Plain Layout

triangle/.style={draw,
 regular polygon,
 regular polygon sides=3}]
\end_layout

\begin_layout Plain Layout

%uncomment if require:
 
\backslash
path (0,300);
 %set diagram left start at 0,
 and has height of 300
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Text Node
\end_layout

\begin_layout Plain Layout


\backslash
node (T0) at (230,33) [anchor=north] [triangle,
 align=center] {$T_{0}$};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%Straight Lines [id:da2436835957991541] 
\end_layout

\begin_layout Plain Layout


\backslash
draw[->]    (T0.north) -- (200,10) -- (130,80) ;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
The start of the construction of 
\begin_inset Formula $T$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

Now,
 in parallel with making the tree grow,
 we evaluate 
\begin_inset Formula $\lambda_{0n}(0)$
\end_inset

 for larger and larger values of 
\begin_inset Formula $n$
\end_inset

.
 More precisely,
 we will in parallel evaluate 
\begin_inset Formula $\lambda_{0n}(0)$
\end_inset

 for 
\emph on
every
\emph default
 
\begin_inset Formula $n\in\N$
\end_inset

 in parallel,
 until this expression halts for some value of 
\begin_inset Formula $n=n_{0}$
\end_inset

.
\end_layout

\begin_layout Proof
If 
\begin_inset Formula $\lambda_{0n_{0}}(0)\iswd=0$
\end_inset

,
 we continue as we were,
 but we shall now only evaluate 
\begin_inset Formula $\lambda_{0n}(0)$
\end_inset

 for 
\begin_inset Formula $n>n_{0}$
\end_inset

.
 On the other hand,
 if 
\begin_inset Formula $\lambda_{0n_{0}}(0)\iswd=1$
\end_inset

,
 we 
\emph on
suspend
\emph default
 the construction of 
\begin_inset Formula $T_{0}$
\end_inset

,
 in a sense to be made precise soon.
 At this point,
 on the left hand side,
 we branch off and do something similar to what was done at the origin:
 On the left,
 we keep appending just 
\begin_inset Formula $0$
\end_inset

,
 and on the right we construct a new subtree 
\begin_inset Formula $T_{1}$
\end_inset

 whose purpose is to diagonalize against 
\begin_inset Formula $\lambda_{1}$
\end_inset

.
\end_layout

\begin_layout Proof
\begin_inset Float figure
placement document
alignment document
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1,
\end_layout

\begin_layout Plain Layout

triangle/.style={draw,
 regular polygon,
 regular polygon sides=3,
 inner sep=0pt},
\end_layout

\begin_layout Plain Layout

lbl/.style={inner sep=0pt}]
\end_layout

\begin_layout Plain Layout

%uncomment if require:
 
\backslash
path (0,300);
 %set diagram left start at 0,
 and has height of 300
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Text Node
\end_layout

\begin_layout Plain Layout


\backslash
node (T0) at (230,33) [anchor=north] [triangle,
 align=center] {$T_{0}$};
\end_layout

\begin_layout Plain Layout


\backslash
node[below=0cm of T0.south,lbl]{(Suspended)};
\end_layout

\begin_layout Plain Layout

% Text Node
\end_layout

\begin_layout Plain Layout


\backslash
node (T1) at (156,100) [anchor=north] [triangle,
 align=center] {$T_{1}$};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%Straight Lines [id:da2436835957991541] 
\end_layout

\begin_layout Plain Layout


\backslash
draw    (T0.north) -- (200,10) -- (130,80) ;
\end_layout

\begin_layout Plain Layout

%Straight Lines [id:da4638448203205108] 
\end_layout

\begin_layout Plain Layout


\backslash
draw[<-]    (100,110) -- (130,80) -- (T1.north) ;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
After we've guessed 
\begin_inset Formula $\lambda_{0}(0)=1$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Proof
After this point,
 we continue evaluating 
\begin_inset Formula $\lambda_{0n}(0)$
\end_inset

 in parallel for 
\begin_inset Formula $n>n_{0}$
\end_inset

.
 If we find 
\begin_inset Formula $\lambda_{0n}(0)\iswd=1$
\end_inset

,
 we continue the process as we were.
 On the other hand,
 if we find 
\begin_inset Formula $\lambda_{0n}(0)\iswd=0$
\end_inset

,
 for 
\begin_inset Formula $n=n_{1}$
\end_inset

 say,
 we will switch back to 
\begin_inset Formula $T_{0}$
\end_inset

.
 More concretely,
 we 
\emph on
permanently 
\emph default
suspend the construction of 
\begin_inset Formula $T_{1}$
\end_inset

,
 and 
\emph on
un
\emph default
suspend the construction of 
\begin_inset Formula $T_{0}$
\end_inset

.
 Again,
 the meaning of suspension will be defined shortly.
\end_layout

\begin_layout Proof
\begin_inset Float figure
placement document
alignment document
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1,
\end_layout

\begin_layout Plain Layout

triangle/.style={draw,
 regular polygon,
 regular polygon sides=3,
 inner sep=0pt},
\end_layout

\begin_layout Plain Layout

lbl/.style={inner sep=0pt}]
\end_layout

\begin_layout Plain Layout

%uncomment if require:
 
\backslash
path (0,300);
 %set diagram left start at 0,
 and has height of 300
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Text Node
\end_layout

\begin_layout Plain Layout


\backslash
node (T0) at (230,33) [anchor=north] [triangle,
 align=center] {$T_{0}$};
\end_layout

\begin_layout Plain Layout

% Text Node
\end_layout

\begin_layout Plain Layout


\backslash
node (T1) at (156,100) [anchor=north] [triangle,
 align=center] {$T_{1}$};
\end_layout

\begin_layout Plain Layout


\backslash
node (T1s) [below=0cm of T1.south,lbl]{(Suspended)};
\end_layout

\begin_layout Plain Layout


\backslash
node[below=0cm of T1s.south,lbl]{(Forever)};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%Straight Lines [id:da2436835957991541] 
\end_layout

\begin_layout Plain Layout


\backslash
draw    (T0.north) -- (200,10) -- (130,80) ;
\end_layout

\begin_layout Plain Layout

%Straight Lines [id:da4638448203205108] 
\end_layout

\begin_layout Plain Layout


\backslash
draw[<-]    (80,130) -- (130,80) -- (T1.north) ;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
After we've guessed 
\begin_inset Formula $\lambda_{0}(0)=1$
\end_inset

,
 followed by 
\begin_inset Formula $\lambda_{0}(0)=0$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Proof
The process continues,
 evaluating 
\begin_inset Formula $\lambda_{0n}(0)$
\end_inset

 for 
\begin_inset Formula $n>n_{1}$
\end_inset

.
 If we find a result of 
\begin_inset Formula $0$
\end_inset

,
 we continue the process as we were.
 Otherwise,
 we again suspend 
\begin_inset Formula $T_{0}$
\end_inset

 and begin the construction of a 
\emph on
new
\emph default
 tree 
\begin_inset Formula $T_{2}$
\end_inset

on the left branch.
\end_layout

\begin_layout Proof
\begin_inset Float figure
placement document
alignment document
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1,
\end_layout

\begin_layout Plain Layout

triangle/.style={draw,
 regular polygon,
 regular polygon sides=3,
 inner sep=0pt},
\end_layout

\begin_layout Plain Layout

lbl/.style={inner sep=0pt}]
\end_layout

\begin_layout Plain Layout

%uncomment if require:
 
\backslash
path (0,300);
 %set diagram left start at 0,
 and has height of 300
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Text Node
\end_layout

\begin_layout Plain Layout


\backslash
node (T0) at (230,33) [anchor=north] [triangle,
 align=center] {$T_{0}$};
\end_layout

\begin_layout Plain Layout


\backslash
node[below=0cm of T0.south,lbl]{(Suspended)};
\end_layout

\begin_layout Plain Layout

% Text Node
\end_layout

\begin_layout Plain Layout


\backslash
node (T1) at (156,100) [anchor=north] [triangle,
 align=center] {$T_{1}$};
\end_layout

\begin_layout Plain Layout


\backslash
node (T1s) [below=0cm of T1.south,lbl]{(Suspended)};
\end_layout

\begin_layout Plain Layout


\backslash
node [below=0cm of T1s.south,lbl]{(Forever)};
\end_layout

\begin_layout Plain Layout

% Text Node
\end_layout

\begin_layout Plain Layout


\backslash
node (T2) at (80.5,191) [triangle]{$T_2$};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%Straight Lines [id:da2436835957991541] 
\end_layout

\begin_layout Plain Layout


\backslash
draw    (T0.north) -- (200,10) -- (130,80) ;
\end_layout

\begin_layout Plain Layout

%Straight Lines [id:da4638448203205108] 
\end_layout

\begin_layout Plain Layout


\backslash
draw[<-]    (12.12,197.88) -- (130,80) -- (T1.north) ;
\end_layout

\begin_layout Plain Layout

%Straight Lines [id:da30292580609920505] 
\end_layout

\begin_layout Plain Layout


\backslash
draw    (60,150) -- (T2.north) ;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
After we've guessed 
\begin_inset Formula $\lambda_{0}(0)=1$
\end_inset

,
 then 
\begin_inset Formula $0$
\end_inset

,
 then 
\begin_inset Formula $1$
\end_inset

 again.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Proof
This process continues indefinitely.
 We will now explain the construction of the subtrees 
\begin_inset Formula $T_{i}$
\end_inset

.
 They are constructed the exact same way,
 only with the following differences:
\end_layout

\begin_deeper
\begin_layout Itemize
The trees we have been referring to so far should be built as to diagonalize against 
\begin_inset Formula $\lambda_{1}$
\end_inset

 instead of 
\begin_inset Formula $\lambda_{0}$
\end_inset

.
 In turn,
 they will have their own subtrees,
 which should be built as to diagonalize against 
\begin_inset Formula $\lambda_{2}$
\end_inset

,
 and so on.
\end_layout

\begin_layout Itemize
In particular,
 the diagonalization must take the tree's position into account.
 In other words,
 
\begin_inset Formula $T_{0}$
\end_inset

 will be keeping track of 
\begin_inset Formula $\lambda_{1}(1)$
\end_inset

,
 but if 
\begin_inset Formula $T_{1}$
\end_inset

 has its root node at 
\begin_inset Formula $\sigma$
\end_inset

,
 it needs to keep track of 
\begin_inset Formula $\lambda_{1}(\abs{\sigma})$
\end_inset

,
 and so on.
\end_layout

\begin_layout Itemize
Finally,
 there is the matter of suspension,
 which we now explain.
\end_layout

\end_deeper
\begin_layout Proof
As we said,
 the trees 
\begin_inset Formula $T_{i}$
\end_inset

 should be constructed recursively in the same way as the big tree we've been describing,
 except that these subtrees may be told to suspend sometime during the construction.
 This means that all branching and function evaluation is put on pause,
 and while this happens,
 every currently-hanging leaf is to continue growing to the left.
 This means that a tree that is left suspended forever will have a finite fixed number of paths,
 all of which terminate in an infinite string of zeros.
 On the other hand,
 a tree (in the above case,
 only 
\begin_inset Formula $T_{0}$
\end_inset

,
 but this will apply to other trees that are built from the recursion) may eventually be told to 
\begin_inset Quotes eld
\end_inset

unsuspend
\begin_inset Quotes erd
\end_inset

.
 This simply means that it should resume diagonalizing and branching from where it left off.
\end_layout

\begin_layout Proof
\begin_inset VSpace medskip
\end_inset

Now that the construction of the tree – let's call it 
\begin_inset Formula $T$
\end_inset

 – is complete,
 let us show that it satisfies the required properties.
 It is clearly computable,
 so we show that it admits exactly one path 
\begin_inset Formula $A$
\end_inset

 that does not terminate in all zeros,
 and that this path 
\begin_inset Formula $A$
\end_inset

 is not 
\begin_inset Formula $\zero'$
\end_inset

-computable.
\end_layout

\begin_layout Proof
To describe the path 
\begin_inset Formula $A$
\end_inset

,
 we begin with the following observation.
 Either the tree changes its mind about 
\begin_inset Formula $\lambda_{0}(0)$
\end_inset

 infinitely often,
 or it does not.
 In the former case,
 we see that 
\begin_inset Formula $T_{0}$
\end_inset

 (as above) is the only subtree that is left unsuspended for an infinite amount of time (though not consecutively).
 In the latter case,
 it will eventually stop alternating suspensions,
 and thus there is a subtree 
\begin_inset Formula $T_{i}$
\end_inset

 that is left unsuspended for an infinite amount of time.
 In either case,
 there is a unique subtree 
\begin_inset Formula $T_{i}$
\end_inset

 that is left unsuspended for infinite time,
 and our path 
\begin_inset Formula $A$
\end_inset

 starts by going to the root of that subtree.
 Note that any path that does not do the same is forced by construction to terminate in an infinite string of zeros!
\end_layout

\begin_layout Proof
In turn,
 a similar reasoning shows that 
\begin_inset Formula $T_{i}$
\end_inset

 admits exactly one sub-subtree that is left unsuspended for an infinite amount of time,
 and so on;
 at each step,
 the path 
\begin_inset Formula $A$
\end_inset

 follows the subtree that is left unsuspended for an infinite amount of time.
\end_layout

\begin_layout Proof
Now that we've shown that 
\begin_inset Formula $A$
\end_inset

 is the only path that does not terminate in an infinite string of zeros,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Note that at each subtree we descend to we gain a 
\begin_inset Formula $1$
\end_inset

,
 which is why 
\begin_inset Formula $A$
\end_inset

 does not end with only zeros.
 Another way to prove this is to note that if ended with a string of zeros,
 it would be computable and therefore 
\begin_inset Formula $\zero'$
\end_inset

-computable,
 contrary to what we are about to show.
\end_layout

\end_inset

 we turn to proving that 
\begin_inset Formula $A$
\end_inset

 is not 
\begin_inset Formula $\zero'$
\end_inset

-computable.
\end_layout

\begin_layout Proof
Suppose that 
\begin_inset Formula $A$
\end_inset

 was 
\begin_inset Formula $\zero'$
\end_inset

-computable,
 or equivalently limit-computable.
 Suppose that 
\begin_inset Formula $A=\lambda_{n}$
\end_inset

.
 Let 
\begin_inset Formula $\sigma$
\end_inset

 be the root of the 
\begin_inset Formula $(\text{sub})^{n}$
\end_inset

tree that 
\begin_inset Formula $A$
\end_inset

 passes through.
 Then,
 
\begin_inset Formula $q=\lambda_{n}(\abs{\sigma})$
\end_inset

 is well-defined,
 and this subtree is given infinitely much time to approximate it,
 whence the tree's approximation of 
\begin_inset Formula $\lambda_{n}(\abs{\sigma})$
\end_inset

 will eventually converge.
 Thus,
 every subtree below 
\begin_inset Formula $\sigma q$
\end_inset

 is suspended,
 and will stay suspended forever.
 Thus,
 
\begin_inset Formula $A$
\end_inset

 must follow 
\begin_inset Formula $\sigma(1-q)$
\end_inset

,
 which contradicts the assumption that 
\begin_inset Formula $A=\lambda_{n}$
\end_inset

.
 The proof is thus complete.
\end_layout

\begin_layout Standard
Regardless of the above result,
 it turns out that any 
\begin_inset Formula $\Sigma_{n}$
\end_inset

 class can be (effectively) approximated arbitrarily closely from the outside by 
\begin_inset Formula $\Sigma_{n}$
\end_inset

 opens.
 This is precisely what is necessary to ensure that (cf.
\begin_inset space \space{}
\end_inset

§6.8 of 
\begin_inset CommandInset citation
LatexCommand cite
key "algrand_downey_hirschfeldt"
literal "false"

\end_inset

) the notions of Martin-Löf test corresponding to each of these collections of classes provide the same notion of randomness.
\end_layout

\begin_layout Standard
Instead of directly proving the full result,
 we start with an attempt at providing intuition by manually doing the cases 
\begin_inset Formula $n=1$
\end_inset

,
 
\begin_inset Formula $2$
\end_inset

,
 
\begin_inset Formula $3$
\end_inset

,
 and 
\begin_inset Formula $4$
\end_inset

.
\end_layout

\begin_layout Proposition
\begin_inset CommandInset label
LatexCommand label
name "prop:approxsigma1"

\end_inset

Given a 
\begin_inset Formula $\Sigma_{1}$
\end_inset

 class 
\begin_inset Formula $\mathcal{C}$
\end_inset

 and a rational 
\begin_inset Formula $\varepsilon>0$
\end_inset

,
 there is a 
\begin_inset Formula $\Sigma_{1}$
\end_inset

open 
\begin_inset Formula $U\supseteq\mathcal{C}$
\end_inset

 so that 
\begin_inset Formula $\mu(U)<\mu(\calC)+\varepsilon$
\end_inset

.
\end_layout

\begin_layout Proof
By Proposition 
\begin_inset CommandInset ref
LatexCommand ref
reference "prop:sigma1classissigma1open"

\end_inset

,
 just set 
\begin_inset Formula $U=\calC$
\end_inset

.
\end_layout

\begin_layout Proposition
\begin_inset CommandInset label
LatexCommand label
name "prop:approxsigma2"

\end_inset

Given a 
\begin_inset Formula $\Sigma_{2}$
\end_inset

 class 
\begin_inset Formula $\calC$
\end_inset

 and a rational 
\begin_inset Formula $\varepsilon>0$
\end_inset

,
 there is a 
\begin_inset Formula $\Sigma_{2}$
\end_inset

 open 
\begin_inset Formula $U\supseteq\calC$
\end_inset

 so that 
\begin_inset Formula $\mu(U)<\mu(\calC)+\varepsilon$
\end_inset

.
\end_layout

\begin_layout Proof
By Remark 
\begin_inset CommandInset ref
LatexCommand ref
reference "rmk:writeclasses"

\end_inset

,
 we can write 
\begin_inset Formula $\calC$
\end_inset

 in the form
\begin_inset Formula 
\[
\calC=\bigcup_{x}\bigcap_{y}U_{\sigma(x,y)}^{c},
\]

\end_inset

where 
\begin_inset Formula $x$
\end_inset

 ranges over the natural numbers and 
\begin_inset Formula $y$
\end_inset

 ranges over some computable set that depends uniformly on 
\begin_inset Formula $x$
\end_inset

.
 Our approach will be as follows:
 We know that each 
\begin_inset Formula $U_{\sigma(x,y)}$
\end_inset

 is actually clopen,
 with 
\begin_inset Formula $U_{\sigma(x,y)}^{c}$
\end_inset

 being the union of 
\begin_inset Formula $U_{\tau}$
\end_inset

 over all 
\begin_inset Formula $\tau$
\end_inset

 of same size as 
\begin_inset Formula $\sigma(x,y)$
\end_inset

 that disagree with it.
 As such,
 for each fixed 
\begin_inset Formula $x$
\end_inset

,
 
\begin_inset Formula $F_{x}:=\cap_{y}U_{\sigma(x,y)}^{c}$
\end_inset

 can be approximated from the outside by open sets by considering the partial (finite) intersections.
 We will show that this can be done uniformly with good control of the measure:
\end_layout

\begin_deeper
\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:approxpi1"

\end_inset

Given a 
\begin_inset Formula $\Pi_{1}$
\end_inset

 class 
\begin_inset Formula $F$
\end_inset

 and a rational 
\begin_inset Formula $\varepsilon>0$
\end_inset

,
 there is a 
\begin_inset Formula $\zero'$
\end_inset

-effective open 
\begin_inset Formula $U\supseteq F$
\end_inset

 so that 
\begin_inset Formula $\mu(U)<\mu(F)+\varepsilon$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Proof
Once we have established Lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:approxpi1"

\end_inset

,
 the proof of Proposition 
\begin_inset CommandInset ref
LatexCommand ref
reference "prop:approxsigma2"

\end_inset

 follows as such:
 Approximate each 
\begin_inset Formula $F_{x}$
\end_inset

 by a 
\begin_inset Formula $\zero'$
\end_inset

-effective open set 
\begin_inset Formula $U_{x}=\cup_{y}U_{\nu(x,y)}$
\end_inset

 within 
\begin_inset Formula $2^{-x-1}\varepsilon$
\end_inset

 measure,
 and elementary measure estimates yield that
\begin_inset Formula 
\begin{equation}
U=\bigcup_{x,y}U_{\nu(x,y)}\label{eq:upi1}
\end{equation}

\end_inset

is the desired open approximation of 
\begin_inset Formula $\calC$
\end_inset

.
\end_layout

\begin_layout Standard
It remains only to establish Lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:approxpi1"

\end_inset

.
\end_layout

\begin_layout Proof
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:approxpi1"

\end_inset


\end_layout

\end_inset

Let 
\begin_inset Formula $F=\cap_{y}U_{\sigma(y)}^{c}$
\end_inset

,
 and suppose 
\begin_inset Formula $\varepsilon>0$
\end_inset

 has been given.
 Define 
\begin_inset Formula $F^{k}=\cap_{y<k}U_{\sigma(y)}^{c}$
\end_inset

 as the 
\begin_inset Formula $k$
\end_inset

-th approximation of 
\begin_inset Formula $F$
\end_inset

.
 The function 
\begin_inset Formula $k\mapsto\mu(F^{k})$
\end_inset

 is easily seen to be computable,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
This requires writing 
\begin_inset Formula $F^{k}$
\end_inset

 as a disjoint (finite) union 
\begin_inset Formula $\cup_{z}U_{\sigma'(z)}$
\end_inset

 and adding up 
\begin_inset Formula $\sum_{z}2^{-\abs{\sigma'(z)}}$
\end_inset

.
\end_layout

\end_inset

 as well as decreasing,
 so it furnishes an approximation of 
\begin_inset Formula $\mu(F)$
\end_inset

 from above.
 Moreover,
 using 
\begin_inset Formula $\zero'$
\end_inset

,
 we can find approximations from below.
 More precisely,
 given a rational 
\begin_inset Formula $q$
\end_inset

 we ask 
\begin_inset Quotes eld
\end_inset

will 
\begin_inset Formula $\mu(F^{k})$
\end_inset

 ever be below 
\begin_inset Formula $q$
\end_inset

?
\begin_inset Quotes erd
\end_inset

,
 and if the answer is 
\begin_inset Quotes eld
\end_inset

no
\begin_inset Quotes erd
\end_inset

 we now know that 
\begin_inset Formula $\mu(F)\geq q$
\end_inset

.
 As such,
 
\begin_inset Formula $\zero'$
\end_inset

 is able to find some 
\begin_inset Formula $k$
\end_inset

 such that 
\begin_inset Formula $\mu(F)\geq\mu(F^{k})-\varepsilon$
\end_inset

.
 This 
\begin_inset Formula $F^{k}$
\end_inset

 is an effective open,
 and so furnishes the desired approximation.
\end_layout

\begin_layout Remark
This proof of Lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:approxpi1"

\end_inset

 actually proves the following stronger statement:
 Given 
\begin_inset Formula $F\in\Pi_{1}$
\end_inset

 and 
\begin_inset Formula $\varepsilon$
\end_inset

,
 there is a 
\emph on
computable
\emph default
 (cl)open approximating 
\begin_inset Formula $F$
\end_inset

 from the outside within 
\begin_inset Formula $\varepsilon$
\end_inset

 measure.
 However,
 the process is only 
\begin_inset Formula $0'$
\end_inset

-effective.
 In other words,
 in Equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:upi1"

\end_inset

,
 for each fixed value of 
\begin_inset Formula $x$
\end_inset

 the set of valid indices 
\begin_inset Formula $\braket{x,y}$
\end_inset

 and the function 
\begin_inset Formula $\nu(x,y)$
\end_inset

 on these indices are both computable,
 but not uniformly in 
\begin_inset Formula $x$
\end_inset

;
 the entire aggregation is only 
\begin_inset Formula $\zero'$
\end_inset

-computable.
\end_layout

\begin_layout Proposition
\begin_inset CommandInset label
LatexCommand label
name "prop:approxsigma3"

\end_inset

Given a 
\begin_inset Formula $\Sigma_{3}$
\end_inset

 class 
\begin_inset Formula $\calC$
\end_inset

 and a rational 
\begin_inset Formula $\varepsilon>0$
\end_inset

,
 there is a 
\begin_inset Formula $\Sigma_{3}$
\end_inset

 open 
\begin_inset Formula $U\supseteq\calC$
\end_inset

 so that 
\begin_inset Formula $\mu(U)<\mu(\calC)+\varepsilon$
\end_inset

.
\end_layout

\begin_layout Proof
By Remark 
\begin_inset CommandInset ref
LatexCommand ref
reference "rmk:writeclasses"

\end_inset

,
 write
\begin_inset Formula 
\[
\calC=\bigcup_{x}\bigcap_{y}\bigcup_{z}U_{\sigma(x,y,z)}.
\]

\end_inset


\end_layout

\begin_layout Proof
As with Proposition 
\begin_inset CommandInset ref
LatexCommand ref
reference "prop:approxsigma2"

\end_inset

,
 the main step is to approximate each 
\begin_inset Formula $F_{x}=\cap_{y}\cup_{z}U_{\sigma(x,y,z)}$
\end_inset

 from the outside by an open set.
 In a similar fashion to the proof thereof,
 we will want to look at the partial approximations 
\begin_inset Formula $F_{x}^{k}=\cap_{y<k}\cup_{z}U_{\sigma(x,y,z)}$
\end_inset

,
 each of which is open,
 and find a (
\begin_inset Formula $\zero''$
\end_inset

-effective) value of 
\begin_inset Formula $k$
\end_inset

 for which 
\begin_inset Formula $F_{x}^{k}$
\end_inset

 has at most 
\begin_inset Formula $2^{-x-1}\varepsilon$
\end_inset

 excess measure.
\end_layout

\begin_layout Proof
For a fixed value of 
\begin_inset Formula $k$
\end_inset

,
 we can write 
\begin_inset Formula $F_{x}^{k}$
\end_inset

 as a computable union of opens,
 say 
\begin_inset Formula $\cup_{w}U_{\sigma'(x,k,w)}$
\end_inset

.
 Unlike in the proof of Lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:approxpi1"

\end_inset

,
 we cannot compute 
\begin_inset Formula $\mu(F_{x}^{k})$
\end_inset

,
 and indeed it will generally not be a rational.
 However,
 there is a computable sequence 
\begin_inset Formula $\{m_{i}\}_{i\in\N}$
\end_inset

 that approximates 
\begin_inset Formula $\mu(F_{x}^{k})$
\end_inset

 from below.
 This means that there is a 
\begin_inset Formula $\zero'$
\end_inset

-computable way to approximate 
\begin_inset Formula $\mu(F_{x}^{k})$
\end_inset

 from above,
 namely,
 for a given 
\begin_inset Formula $q\in\Q$
\end_inset

,
 ask the Halting Problem if 
\begin_inset Formula $m_{i}$
\end_inset

 ever exceeds 
\begin_inset Formula $q$
\end_inset

.
\end_layout

\begin_layout Proof
By enumerating the values of 
\begin_inset Formula $q\in\Q$
\end_inset

 that are above 
\begin_inset Formula $\mu(F_{x}^{k})$
\end_inset

 for 
\emph on
some 
\emph default

\begin_inset Formula $k\in\N$
\end_inset

,
 that is,
 the set
\begin_inset Formula 
\[
\{\,q\in\Q\mid\exists_{k}q>\mu(F_{x}^{k})\,\},
\]

\end_inset

we can provide a sequence 
\begin_inset Formula $\{q_{i}\}_{i\in\N}$
\end_inset

 that approximates 
\begin_inset Formula $\mu(F_{x})=\mu(\cap_{k\in\N}F_{x}^{k})$
\end_inset

 from above.
 Finally,
 
\begin_inset Formula $\zero''$
\end_inset

 can use the 
\begin_inset Quotes eld
\end_inset

does this sequence ever go below 
\begin_inset Formula $p\in\Q$
\end_inset


\begin_inset Quotes erd
\end_inset

 trick to find a sequence 
\begin_inset Formula $\{p_{i}\}_{i\in\N}$
\end_inset

 that approximates 
\begin_inset Formula $\mu(F_{x})$
\end_inset

 from below.
 Thus,
 
\begin_inset Formula $\zero''$
\end_inset

 can compute arbitrary approximations to 
\begin_inset Formula $\mu(F_{x})$
\end_inset

,
 and moreover it can find a value of 
\begin_inset Formula $k$
\end_inset

 for which 
\begin_inset Formula $\mu(F_{x}^{k})<\mu(F_{x})+\delta$
\end_inset

 for a given 
\begin_inset Formula $\delta$
\end_inset

:
 Simply find an approximation 
\begin_inset Formula $M$
\end_inset

 of 
\begin_inset Formula $\mu(F_{x})$
\end_inset

 that is sure to be within 
\begin_inset Formula $\delta/2$
\end_inset

 of the real thing,
 followed by seeking out a value of 
\begin_inset Formula $k$
\end_inset

 for which 
\begin_inset Formula $M+\delta/2$
\end_inset

 is an approximation of 
\begin_inset Formula $\mu(F_{x}^{k})$
\end_inset

 by excess.
\end_layout

\begin_layout Proof
To conclude the proof:
 Let 
\begin_inset Formula $k(x)$
\end_inset

 be a 
\begin_inset Formula $\zero''$
\end_inset

-computable function so that 
\begin_inset Formula $\mu(F_{x}^{k(x)})<\mu(F_{x})+2^{-x-1}\varepsilon$
\end_inset

.
 Then,
 
\begin_inset Formula $U=\cup_{x}F_{x}^{k(x)}$
\end_inset

 is a 
\begin_inset Formula $0''$
\end_inset

-effective open set that approximates 
\begin_inset Formula $\calC$
\end_inset

 from above with at most 
\begin_inset Formula $\varepsilon$
\end_inset

 excess measure,
 as was desired.
\end_layout

\begin_layout Proposition
\begin_inset CommandInset label
LatexCommand label
name "prop:approxsigma4"

\end_inset

Given a 
\begin_inset Formula $\Sigma_{4}$
\end_inset

 class 
\begin_inset Formula $\calC$
\end_inset

 and a rational 
\begin_inset Formula $\varepsilon>0$
\end_inset

,
 there is a 
\begin_inset Formula $\Sigma_{4}$
\end_inset

 open 
\begin_inset Formula $U\supseteq\calC$
\end_inset

,
 so that 
\begin_inset Formula $\mu(U)<\mu(\calC)+\varepsilon$
\end_inset

.
\end_layout

\begin_layout Proof
By Remark 
\begin_inset CommandInset ref
LatexCommand ref
reference "rmk:writeclasses"

\end_inset

,
 write
\begin_inset Formula 
\[
\calC=\bigcup_{x}\bigcap_{y}\bigcup_{z}\bigcap_{w}U_{\sigma(x,y,z,w)}^{c}.
\]

\end_inset

This high in the hierarchy,
 an induction starts to reveal itself.
 In order to simplify the problem down to something managable,
 we would like to approximate 
\begin_inset Formula $Q_{xy}=\cup_{z}\cap_{w}U_{\sigma(x,y,z,w)}^{c}$
\end_inset

 by an open superset 
\begin_inset Formula $V_{xy}$
\end_inset

.
 This can be done 
\begin_inset Formula $\zero'$
\end_inset

-effectively by Proposition 
\begin_inset CommandInset ref
LatexCommand ref
reference "prop:approxsigma2"

\end_inset

,
 and the sets 
\begin_inset Formula $V_{xy}$
\end_inset

 are 
\begin_inset Formula $\Sigma_{2}$
\end_inset

 opens.
 It should sound plausible – and we will do the details shortly – that if we're careful in how we go about it,
 we can set things up so that
\begin_inset Formula 
\begin{equation}
\mu\left(\bigcap_{y}V_{xy}\right)<\mu\left(\bigcap_{y}Q_{xy}\right)+2^{-x-1}\varepsilon=\mu\left(\bigcap_{y}\bigcup_{z}\bigcap_{w}U_{\sigma(x,y,z,w)}^{c}\right)+2^{-x-1}\varepsilon,\label{eq:relVQ}
\end{equation}

\end_inset

and therefore so that
\begin_inset Formula 
\[
\mu\left(\bigcup_{x}\bigcap_{y}V_{xy}\right)<\mu\left(\bigcup_{x}\bigcap_{y}\bigcup_{z}\bigcap_{w}U_{\sigma(x,y,z,w)}^{c}\right)+\varepsilon=\mu(\calC)+\varepsilon.
\]

\end_inset


\end_layout

\begin_layout Proof
Now the result follows by relativization of Proposition 
\begin_inset CommandInset ref
LatexCommand ref
reference "prop:approxsigma2"

\end_inset

.
 More precisely,
 we have in our hands a 
\begin_inset Formula $\Sigma_{2}^{\zero''}$
\end_inset

 class,
 namely 
\begin_inset Formula $\calC'=\cup_{x}\cap_{y}V_{xy}$
\end_inset

,
 and Proposition 
\begin_inset CommandInset ref
LatexCommand ref
reference "prop:approxsigma2"

\end_inset

 gives us a 
\begin_inset Formula $\Sigma_{2}^{\zero''}$
\end_inset

 open that approximates 
\begin_inset Formula $\calC'$
\end_inset

 from above with at most 
\begin_inset Formula $\varepsilon$
\end_inset

 excess measure,
 and therefore approximates 
\begin_inset Formula $\calC$
\end_inset

 from above with at most 
\begin_inset Formula $2\varepsilon$
\end_inset

 measure.
 The result therefore follows by noticing that by Definition 
\begin_inset CommandInset ref
LatexCommand ref
reference "def:sigmanopen"

\end_inset

 a 
\begin_inset Formula $\Sigma_{2}^{\zero''}$
\end_inset

 open is the same as a 
\begin_inset Formula $(\zero'')'$
\end_inset

-computable open,
 i.e.
\begin_inset space \space{}
\end_inset

a 
\begin_inset Formula $\njmp 3$
\end_inset

-computable open,
 i.e.
\begin_inset space \space{}
\end_inset

a 
\begin_inset Formula $\Sigma_{4}$
\end_inset

 open.
\end_layout

\begin_layout Proof
\begin_inset VSpace medskip
\end_inset

The only thing remaining to finish the proof is to be a little more careful about the definition of 
\begin_inset Formula $V_{xy}$
\end_inset

.
 The following argument is a little clumsy,
 but it's straightforward.
 Set 
\begin_inset Formula $V_{xy}$
\end_inset

 to approximate 
\begin_inset Formula $Q_{xy}$
\end_inset

 by at most 
\begin_inset Formula $\delta_{y}=2^{-x-y-2}\varepsilon$
\end_inset

.
 In other words,
 we have 
\begin_inset Formula $V_{xy}=Q_{xy}\cup E_{xy}$
\end_inset

,
 with 
\begin_inset Formula $\mu(E_{xy})<\delta_{y}$
\end_inset

.
 Then,
 we have the set-theoretic inclusion
\begin_inset Formula 
\[
\bigcap_{y}V_{xy}\subseteq\bigcap_{y}Q_{xy}\:\cup\:\bigcup_{y}E_{xy}.
\]

\end_inset

As a consequence,
 we have the inequality
\begin_inset Formula 
\[
\mu\left(\bigcap_{y}V_{xy}\right)\leq\mu\left(\bigcap_{y}Q_{xy}\right)+\sum_{y}\mu(E_{xy})=\mu\left(\bigcap_{y}Q_{xy}\right)+\sum_{y}\delta_{y}=\mu\left(\bigcap_{y}Q_{xy}\right)+2^{-x-1}\varepsilon.
\]

\end_inset

This is sufficient to establish Equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:relVQ"

\end_inset

,
 and the proof is complete.
\end_layout

\begin_layout Standard
We are finally in a position to establish the general result.
\end_layout

\begin_layout Theorem
Given a 
\begin_inset Formula $\Sigma_{n}$
\end_inset

 class 
\begin_inset Formula $\calC$
\end_inset

 and a rational 
\begin_inset Formula $\varepsilon>0$
\end_inset

,
 there is a 
\begin_inset Formula $\Sigma_{n}$
\end_inset

 open 
\begin_inset Formula $U\supseteq\calC$
\end_inset

 so that 
\begin_inset Formula $\mu(U)<\mu(\calC)+\varepsilon$
\end_inset

.
 This procedure is 
\begin_inset Formula $\njmp{n-1}$
\end_inset

-effective.
\end_layout

\begin_layout Proof
The proof follows by induction,
 with step size equal to 2.
 The cases 
\begin_inset Formula $n=1$
\end_inset

 and 
\begin_inset Formula $n=2$
\end_inset

 are Propositions 
\begin_inset CommandInset ref
LatexCommand ref
reference "prop:approxsigma1"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "prop:approxsigma2"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
 For the induction step,
 assume that the case for 
\begin_inset Formula $n$
\end_inset

 has been proven,
 and we shall now prove the case 
\begin_inset Formula $n+2$
\end_inset

.
\end_layout

\begin_layout Proof
To proceed,
 write the 
\begin_inset Formula $\Sigma_{n+2}$
\end_inset

 class 
\begin_inset Formula $\calC$
\end_inset

 as
\begin_inset Formula 
\[
\calC=\bigcup_{x}\bigcap_{y}Q_{xy},
\]

\end_inset

where 
\begin_inset Formula $\{Q_{xy}\}_{x,y\in\N}$
\end_inset

 is an effective family of 
\begin_inset Formula $\Sigma_{n}$
\end_inset

 classes.
 As in the proof of Proposition 
\begin_inset CommandInset ref
LatexCommand ref
reference "prop:approxsigma4"

\end_inset

,
 approximate each of these 
\begin_inset Formula $\njmp{n-1}$
\end_inset

-effectively by a 
\begin_inset Formula $\Sigma_{n}$
\end_inset

 open 
\begin_inset Formula $V_{xy}$
\end_inset

,
 with excess measure less than 
\begin_inset Formula $2^{-x-y-2}\varepsilon$
\end_inset

.
 Then,
 following a relativized version of the proof of Proposition 
\begin_inset CommandInset ref
LatexCommand ref
reference "prop:approxsigma4"

\end_inset

,
 we obtain a 
\begin_inset Formula $\njmp{n+1}$
\end_inset

-effective approximation of 
\begin_inset Formula $\calC$
\end_inset

 with excess measure less than 
\begin_inset Formula $\varepsilon$
\end_inset

,
 which proves the desired result.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "bibliography"
options "plain"
encoding "default"

\end_inset


\end_layout

\end_body
\end_document
