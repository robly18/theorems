#LyX 2.4 created this file. For more info see https://www.lyx.org/
\lyxformat 620
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble

\usepackage{listings}
\lstset{
basicstyle=\ttfamily\footnotesize,
keepspaces=true,
tabsize=4,
breaklines=true,
columns=fullflexible,
mathescape=true
}
\usepackage{fullpage}
\usepackage{braket}


\usepackage[cal=euler]{mathalpha}

\setlist[enumerate,2]{ref=\theenumi.\theenumii}
\setlist[enumerate,3]{ref=\theenumi.\theenumii.\theenumiii}
\setlist[enumerate,4]{ref=\theenumi.\theenumii.\theenumiii.\theenumiv}


\newref{sec}{refcmd={Section \ref{#1}}}

\usepackage[style=numeric]{biblatex}
\DeclareFieldFormat{postnote}{#1}
\end_preamble
\use_default_options true
\begin_modules
duarte_theorems_sec_subsec
enumitem
InStar
duarte_theorems_unnumbered_prop
duarte_theorems_unnumbered_def
duarte_theorems_ind_numbered_question
\end_modules
\maintain_unincluded_children no
\language english
\language_package default
\inputencoding auto-legacy
\fontencoding auto
\font_roman "lmodern" "default"
\font_sans "lmss" "default"
\font_typewriter "lmtt" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_roman_osf false
\font_sans_osf false
\font_typewriter_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 1
\bibtex_command default
\index_command default
\float_placement H
\float_alignment class
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize letter
\use_geometry false
\use_package amsmath 2
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine biblatex
\cite_engine_type authoryear
\biblio_style plain
\biblatex_bibstyle numeric
\biblatex_citestyle numeric
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_formatted_ref 1
\use_minted 0
\use_lineno 0
\index Index
\shortcut idx
\color #008000
\end_index
\spellchecker_ignore english QETP
\spellchecker_ignore english QEWTP
\spellchecker_ignore english WQETP
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tablestyle default
\tracking_changes false
\output_changes false
\change_bars false
\postpone_fragile_content false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\docbook_table_output 0
\docbook_mathml_prefix 1
\end_header

\begin_body

\begin_layout Title
Escaping Tennenbaum's Theorem and a Strong Jump Inversion Theorem
\end_layout

\begin_layout Author
Duarte Maia
\end_layout

\begin_layout In Preamble
\begin_inset FormulaMacro
\newcommand{\N}{\mathbb{N}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Z}{\mathbb{Z}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Q}{\mathbb{Q}}
\end_inset


\end_layout

\begin_layout In Preamble
\begin_inset FormulaMacro
\newcommand{\Lang}{\mathcal{L}}
\end_inset


\end_layout

\begin_layout In Preamble
\begin_inset FormulaMacro
\newcommand{\iswd}{\mathord{\downarrow}}
\end_inset


\end_layout

\begin_layout In Preamble
\begin_inset FormulaMacro
\newcommand{\isnotwd}{\mathord{\uparrow}}
\end_inset


\end_layout

\begin_layout In Preamble
\begin_inset FormulaMacro
\newcommand{\turing}{\mathrm{T}}
\end_inset


\end_layout

\begin_layout In Preamble
\begin_inset FormulaMacro
\newcommand{\upto}{\mathord{\upharpoonright}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\ZFniptc}{\mathsf{ZF}\mathord{-}\mathsf{inf}\mathord{+}\mathsf{TC}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\ZFfinptc}{\mathsf{ZFfin}\mathord{+}\mathsf{TC}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\restrict}[1]{\left.#1\right|}
\end_inset


\begin_inset FormulaMacro
\newcommand{\PP}{\mathcal{P}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\PPfin}{\PP^{\mathrm{fin}}}
\end_inset


\end_layout

\begin_layout In Preamble
\begin_inset FormulaMacro
\newcommand{\llor}{\bigvee\mathchoice{\hspace{-1.1em}}{\hspace{-0.7em}}{\hspace{-0.7em}}{\hspace{-0.6em}}\bigvee}
{\bigvee\bigvee}
\end_inset


\begin_inset FormulaMacro
\newcommand{\lland}{\bigwedge\mathchoice{\hspace{-1.1em}}{\hspace{-0.7em}}{\hspace{-0.7em}}{\hspace{-0.6em}}\bigwedge}
{\bigwedge\bigwedge}
\end_inset


\begin_inset FormulaMacro
\newcommand{\llorc}{\llor^{\mathrm{c}}}
\end_inset


\end_layout

\begin_layout Section
Acknowledgements
\end_layout

\begin_layout Standard
I would like to thank Denis Hirschfeldt,
 Miles Kretschmer,
 and Patrick Lutz for their valuable feedback,
 help,
 and advice,
 without which this work would not have been possible.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Subsection
Background – Tennenbaum's Theorem
\end_layout

\begin_layout Standard
\begin_inset CommandInset citation
LatexCommand nocite
key "lutz_walsh_tennenbaum"
literal "false"

\end_inset


\end_layout

\begin_layout Standard
It is a well-known result of Stanley Tennenbaum (see e.g.
\begin_inset space \space{}
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "kaye_book"
literal "false"

\end_inset

) that 
\begin_inset Formula $\mathsf{PA}$
\end_inset

,
 the first-order theory of Peano Arithmetic,
 does not admit any non-standard computable model.
 In fact,
 in every non-standard model of 
\begin_inset Formula $\mathsf{PA}$
\end_inset

,
 neither addition nor multiplication are computable.
 Generalizations of this theorem can be found in the literature,
 including versions of it for weaker fragments of 
\begin_inset Formula $\mathsf{PA}$
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "wilmers_PA"
literal "false"

\end_inset

,
 alternative operations 
\begin_inset CommandInset citation
LatexCommand cite
key "schmerl_tennenbaum_recursive_reducts"
literal "false"

\end_inset

,
 and finite set theory 
\begin_inset CommandInset citation
LatexCommand cite
key "mancini_zambella_set_theories,computable_quotient_arithmetic_set_theory"
literal "false"

\end_inset

,
 to name a few.
 However,
 all of these approaches and variations appear to depend heavily on the specificities of the chosen signature.
 This was observed by Fedor Pakhomov,
 who in 2022 
\begin_inset CommandInset citation
LatexCommand cite
key "pakhomov"
literal "false"

\end_inset

 constructed a theory that is definitionally equivalent to 
\begin_inset Formula $\mathsf{PA}$
\end_inset

 (the meaning of which will be described shortly,
 but roughly means 
\begin_inset Quotes eld
\end_inset

it's 
\begin_inset Formula $\mathsf{PA}$
\end_inset

 but with a different choice of signature
\begin_inset Quotes erd
\end_inset

) for which there is a computable nonstandard model.
 This shows that Tennenbaum's theorem really is reliant on the choice of signature.
\end_layout

\begin_layout Standard
Let us elaborate on the way in which this theory is 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\mathsf{PA}$
\end_inset

 with a different signature
\begin_inset Quotes erd
\end_inset

,
 by means of an example.
 In the literature,
 the choice of signature used to define 
\begin_inset Formula $\mathsf{PA}$
\end_inset

 is not set in stone.
 Some authors choose to include a symbol for successor,
 while others choose to omit it.
 This is not a problem,
 as long as a symbol for 
\begin_inset Formula $1$
\end_inset

 and a symbol for 
\begin_inset Formula $+$
\end_inset

 remain in the signature,
 because the successor of 
\begin_inset Formula $x$
\end_inset

 can always be rewritten as 
\begin_inset Formula $x+1$
\end_inset

.
 In a similar vein,
 some authors choose to omit a symbol for 
\begin_inset Formula $1$
\end_inset

,
 opting instead to write it as the successor of zero.
 Thus,
 we have two distinct axiomatizations of 
\begin_inset Formula $\mathsf{PA}$
\end_inset

,
 in two signatures neither of which contains the other,
 but which are intuitively seen to both be able to define the missing symbols from their counterpart.
 This idea of defining new symbols in terms of previous ones underlies the notion of 
\emph on
definitional extension
\emph default
,
 and the way in which 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\mathsf{PA}$
\end_inset

 without successor
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\mathsf{PA}$
\end_inset

 without 
\begin_inset Formula $1$
\end_inset


\begin_inset Quotes erd
\end_inset

 are 
\begin_inset Quotes els
\end_inset

kind of the same theory
\begin_inset Quotes ers
\end_inset

 corresponds to the notion of 
\emph on
definitional equivalence
\emph default
.
\end_layout

\begin_layout Definition
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Definitional Extension
\end_layout

\end_inset

Let 
\begin_inset Formula $T$
\end_inset

 be a theory over a signature 
\begin_inset Formula $\Lang$
\end_inset

.
 A 
\emph on
definitional extension
\emph default
 of 
\begin_inset Formula $T$
\end_inset

 is a theory 
\begin_inset Formula $S\supseteq T$
\end_inset

,
 over a language 
\begin_inset Formula $\Lang'\supseteq\Lang$
\end_inset

,
 such that
\end_layout

\begin_deeper
\begin_layout Itemize
Every theorem of 
\begin_inset Formula $S$
\end_inset

 that only uses symbols from the language 
\begin_inset Formula $\Lang$
\end_inset

 is also a theorem of 
\begin_inset Formula $T$
\end_inset

,
 and
\end_layout

\begin_layout Itemize
Every symbol of 
\begin_inset Formula $\Lang'\setminus\Lang$
\end_inset

 is 
\begin_inset Formula $S$
\end_inset

-definable in terms of symbols in 
\begin_inset Formula $\Lang$
\end_inset

.
 For example,
 if 
\begin_inset Formula $P$
\end_inset

 is any propositional symbol in 
\begin_inset Formula $\Lang'$
\end_inset

,
 there is an 
\begin_inset Formula $\Lang$
\end_inset

-formula 
\begin_inset Formula $\varphi$
\end_inset

 such that
\begin_inset Formula 
\[
S\vdash\forall_{\vec{x}}(P(\vec{x})\leftrightarrow\varphi(\vec{x})),
\]

\end_inset

and a similar statement holds for function symbols.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Definitional Equivalence
\end_layout

\end_inset

Let 
\begin_inset Formula $T_{1}$
\end_inset

 and 
\begin_inset Formula $T_{2}$
\end_inset

 be two theories,
 whose signatures 
\begin_inset Formula $\Lang_{1}$
\end_inset

 and 
\begin_inset Formula $\Lang_{2}$
\end_inset

 respectively are assumed to be disjoint with no loss of generality.
 We say that 
\begin_inset Formula $T_{1}$
\end_inset

 and 
\begin_inset Formula $T_{2}$
\end_inset

 are 
\emph on
definitionally equivalent
\emph default
 if there is a theory 
\begin_inset Formula $T$
\end_inset

 which is a definitional extension of both.
\end_layout

\begin_layout Standard
The notion of definitional equivalence is related,
 but not identical,
 to a more common notion of 
\begin_inset Quotes eld
\end_inset

equal power of theories
\begin_inset Quotes erd
\end_inset

 called bi-interpretability:
 definitional equivalence is strictly stronger,
 though these two notions coincide for most natural examples.
 The interested reader will find a thorough comparison of these two notions in 
\begin_inset CommandInset citation
LatexCommand cite
key "biinterpretabilityvssynonymy"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
A nontrivial example of two definitionally equivalent theories is that of 
\begin_inset Formula $\mathsf{PA}$
\end_inset

 and a specific version of finite set theory,
 which we will refer to as 
\begin_inset Formula $\ZFfinptc$
\end_inset

.
 This theory,
 and a closely related one,
 shall play an important role in the sequel,
 so we formally introduce them to the reader.
\end_layout

\begin_layout Definition
The theory 
\begin_inset Formula $\ZFniptc$
\end_inset

 consists of the usual axioms of Zermelo-Fraenkel set theory,
 with the removal of the axiom of infinity,
 and with the addition of the so-called 
\begin_inset Quotes eld
\end_inset

axiom of transitive closure
\begin_inset Quotes erd
\end_inset

,
 which states that any set is contained in a transitive set.
\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rmk:vonneumann"

\end_inset

Under the remaining axioms of 
\begin_inset Formula $\mathsf{ZF}$
\end_inset

 (minus infinity),
 the axiom of transitive closure is equivalent to the validity of 
\begin_inset Formula $\in$
\end_inset

-induction.
 It is also equivalent (under the same circumstances) to the claim that every set is in some level of the von
\begin_inset space ~
\end_inset

Neumann hierarchy 
\begin_inset Formula $V_{\alpha}$
\end_inset

.
 This is,
 in fact,
 the principal way in which this axiom will be necessary for our work.
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
The theory 
\begin_inset Formula $\ZFfinptc$
\end_inset

 consists of 
\begin_inset Formula $\ZFniptc$
\end_inset

,
 together with the negation of the axiom of infinity.
\end_layout

\begin_layout Remark
The usual theory of 
\begin_inset Formula $\mathsf{ZF}$
\end_inset

 consists of 
\begin_inset Formula $\ZFniptc$
\end_inset

,
 together with the axiom of infinity – the axiom of transitive closure adds no deductive power in this case.
 In other words,
 the axiom of transitive closure can be proven in 
\begin_inset Formula $\mathsf{ZF}$
\end_inset

.
 This is because the transitive closure of a set can be obtained by iterating the operation 
\begin_inset Formula $x\mapsto x\cup\bigcup x$
\end_inset

 countably many times,
 but to define this countable iteration requires recourse to 
\begin_inset Formula $\omega$
\end_inset

.
 This recourse cannot be avoided,
 and indeed it turns out that 
\begin_inset Formula $\mathsf{ZF}-\mathsf{inf}+\neg\mathsf{TC}$
\end_inset

 is consistent;
 see 
\begin_inset CommandInset citation
LatexCommand cite
key "mancini_zambella_set_theories"
literal "false"

\end_inset

 or 
\begin_inset CommandInset citation
LatexCommand cite
key "kaye_wong"
literal "false"

\end_inset

 for a proof.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:pazffineqv"

\end_inset

The theories 
\begin_inset Formula $\mathsf{PA}$
\end_inset

 and 
\begin_inset Formula $\ZFfinptc$
\end_inset

 are definitionally equivalent.
\end_layout

\begin_layout Proof
See 
\begin_inset CommandInset citation
LatexCommand cite
key "kaye_wong"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
Besides serving as an interesting example of definitional equivalence,
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:pazffineqv"

\end_inset

 also underlies the entirety of Pakhomov's construction,
 as it is more convenient to work with a set-theoretical framework than it would be to work directly with 
\begin_inset Formula $\mathsf{PA}$
\end_inset

.
 It also gives us a little bit more flexibility,
 allowing us to construct computable models of theories definitionally equivalent to 
\begin_inset Formula $\mathsf{ZF}$
\end_inset

 or 
\begin_inset Formula $\mathsf{ZFC}$
\end_inset

,
 though we will not explore this avenue in this document.
 We now briefly present the idea behind Pakhomov's construction,
 before elaborating on our original contributions.
\end_layout

\begin_layout Subsection
Pakhomov's Construction and New Results
\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\Tboth}{T_{\mathrm{both}}}
\end_inset

In Fedor Pakhomov's paper 
\begin_inset Quotes eld
\end_inset

How to Escape Tennenbaum's Theorem
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "pakhomov"
literal "false"

\end_inset

,
 the author defines a theory 
\begin_inset Formula $T_{S}$
\end_inset

,
 definitionally equivalent to 
\begin_inset Formula $\ZFniptc$
\end_inset

,
 which axiomatizes a certain ternary predicate 
\begin_inset Formula $S(x,y,z)$
\end_inset

.
 This ternary predicate acts as 
\begin_inset Quotes eld
\end_inset

set membership with witnesses
\begin_inset Quotes erd
\end_inset

,
 and is initially defined in 
\begin_inset Formula $\ZFniptc$
\end_inset

 by transfinite recursion in the von
\begin_inset space ~
\end_inset

Neumann hierarchy (see also 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rmk:vonneumann"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

) in such a way as to satisfy the rule
\begin_inset Formula 
\begin{equation}
\ZFniptc\vdash\forall_{x,y}(x\in y\leftrightarrow\forall_{z}S(x,y,z)).\label{eq:Sdef}
\end{equation}

\end_inset

Since 
\begin_inset Formula $S$
\end_inset

 is initially defined in the context of set theory,
 it is definable in terms of set membership,
 and Equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Sdef"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 ensures that set membership is itself definable in terms of 
\begin_inset Formula $S$
\end_inset

,
 which is why these two theories are definitionally equivalent.
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "def:tboth"

\end_inset

Henceforth,
 
\begin_inset Formula $\Tboth$
\end_inset

 denotes the set of all sentences provable from 
\begin_inset Formula $\ZFniptc$
\end_inset

 plus the definition of 
\begin_inset Formula $S$
\end_inset

 in the signature containing both 
\begin_inset Formula $S$
\end_inset

 and set inclusion.
 Moreover,
 
\begin_inset Formula $T_{S}$
\end_inset

 denotes the theory of 
\begin_inset Formula $S$
\end_inset

,
 that is,
 
\begin_inset Formula $\Tboth$
\end_inset

 restricted to the sentences containing only the predicate 
\begin_inset Formula $S$
\end_inset

.
 
\end_layout

\begin_layout Standard
The main property of this predicate 
\begin_inset Formula $S$
\end_inset

 is that it is endowed with a certain 
\begin_inset Quotes els
\end_inset

flexibility
\begin_inset Quotes ers
\end_inset

 or 
\begin_inset Quotes els
\end_inset

genericity
\begin_inset Quotes ers
\end_inset

.
 As we will later make precise,
 if we are attempting to build a model of 
\begin_inset Formula $T_{S}$
\end_inset

 and make some mistakes along the way,
 any extra 
\begin_inset Quotes els
\end_inset

trash
\begin_inset Quotes ers
\end_inset

 elements we might have added on accident can still be reused as 
\begin_inset Quotes els
\end_inset

real
\begin_inset Quotes ers
\end_inset

 elements added later on.
 Pakhomov exploits this flexibility to prove:
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:premain"

\end_inset

If 
\begin_inset Formula $T$
\end_inset

 is a consistent c.e.
\begin_inset space \space{}
\end_inset

theory extending 
\begin_inset Formula $T_{S}$
\end_inset

,
 then 
\begin_inset Formula $T$
\end_inset

 admits a computable model.
\end_layout

\begin_layout Standard
Pakhomov proves this using an explicit 
\begin_inset Quotes eld
\end_inset

Henkin construction
\begin_inset Quotes erd
\end_inset

 type of argument.
 We reframe his work in terms of the following stronger result:
\end_layout

\begin_layout Theorem*
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:basic_pakhomov_jump_inversion"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset


\end_layout

\end_inset

If 
\begin_inset Formula $D$
\end_inset

 is a 
\begin_inset Formula $0'$
\end_inset

-computable model of 
\begin_inset Formula $\Tboth$
\end_inset

,
 the reduct 
\begin_inset Formula $D\upto S$
\end_inset

 admits a computable copy.
\end_layout

\begin_layout Standard
We provide a brief sketch of how 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:basic_pakhomov_jump_inversion"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 implies 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:premain"

\end_inset

.
 If 
\begin_inset Formula $T$
\end_inset

 is a consistent c.e.
\begin_inset space \space{}
\end_inset

theory extending 
\begin_inset Formula $T_{S}$
\end_inset

,
 consider the consistent c.e.
\begin_inset space \space{}
\end_inset

theory 
\begin_inset Formula $\bar{T}=T\cup T_{\mathrm{both}}$
\end_inset

.
 By the computable completeness theorem,
 there is a 
\begin_inset Formula $0'$
\end_inset

-computable model 
\begin_inset Formula $M$
\end_inset

 of 
\begin_inset Formula $\bar{T}$
\end_inset

,
 whose computable reduct to 
\begin_inset Formula $S$
\end_inset

 is a computable model of 
\begin_inset Formula $T$
\end_inset

 by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:basic_pakhomov_jump_inversion"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
\end_layout

\begin_layout Standard
We broadly generalize the methods used by Pakhomov to answer a question posed by him in the affirmative:
\end_layout

\begin_layout Question*
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Pakhomov 
\begin_inset CommandInset citation
LatexCommand cite
key "pakhomov"
literal "false"

\end_inset


\end_layout

\end_inset

Fix a value of 
\begin_inset Formula $n$
\end_inset

.
 Are there theories definitionally equivalent to 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\mathsf{PA}$
\end_inset

 plus all true 
\begin_inset Formula $\Pi_{n}$
\end_inset

 sentences
\begin_inset Quotes erd
\end_inset

 that have computable non-standard models?
\end_layout

\begin_layout Standard
The motivation for this question is that,
 as Pakhomov proved in 
\begin_inset CommandInset citation
LatexCommand cite
key "pakhomov"
literal "false"

\end_inset

,
 this statement is not true 
\begin_inset Quotes els
\end_inset

in the limit
\begin_inset Quotes ers
\end_inset

.
 More precisely,
 Pakhomov showed that any nonstandard model of a theory that is definitionally equivalent to true arithmetic cannot be computable.
 This leads to the question of whether a partial result can be recovered.
\end_layout

\begin_layout Standard
We answer Pakhomov's question via the following improvement on the construction of Pakhomov's theory 
\begin_inset Formula $T_{S}$
\end_inset

:
\end_layout

\begin_layout Theorem*
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:nestedpakhomov"

\end_inset


\end_layout

\end_inset

There is a nested sequence of consistent c.e.
\begin_inset space \space{}
\end_inset

theories 
\begin_inset Formula $\ZFniptc\subseteq T^{0}\subseteq T^{1}\subseteq T^{2}\subseteq\cdots$
\end_inset

 satisfying the following properties:
\end_layout

\begin_deeper
\begin_layout Itemize
Each 
\begin_inset Formula $T^{n}$
\end_inset

 is in the signature containing 
\begin_inset Formula $\in$
\end_inset

 and predicates 
\begin_inset Formula $S^{0}$
\end_inset

,
 
\begin_inset Formula $\dots$
\end_inset

,
 
\begin_inset Formula $S^{n}$
\end_inset

,
 with each 
\begin_inset Formula $S^{i}$
\end_inset

 being an 
\begin_inset Formula $(i+2)$
\end_inset

-ary predicate symbol,
\end_layout

\begin_layout Itemize
All of these extensions are conservative over 
\begin_inset Formula $\ZFniptc$
\end_inset

,
 in the sense that they contain no additional theorems in the predicate 
\begin_inset Formula $\in$
\end_inset

,
\end_layout

\begin_layout Itemize
The predicates 
\begin_inset Formula $\in$
\end_inset

 and 
\begin_inset Formula $S^{n}$
\end_inset

 are definable in terms of the other within 
\begin_inset Formula $T^{n}$
\end_inset

,
 and
\end_layout

\begin_layout Itemize
Given a 
\begin_inset Formula $0'$
\end_inset

-computable model 
\begin_inset Formula $D$
\end_inset

 of 
\begin_inset Formula $T^{n}$
\end_inset

 restricted to the language containing 
\begin_inset Formula $S^{i}$
\end_inset

,
 
\begin_inset Formula $\dots$
\end_inset

,
 and 
\begin_inset Formula $S^{n}$
\end_inset

,
 there is a computable copy 
\begin_inset Formula $M$
\end_inset

 of 
\begin_inset Formula $D\upto(S^{i+1},\dots,S^{n})$
\end_inset

.
\end_layout

\begin_layout Standard
The last item relativizes:
 Given an 
\begin_inset Formula $X'$
\end_inset

-computable model of 
\begin_inset Formula $T^{n}$
\end_inset

 implementing the last 
\begin_inset Formula $k$
\end_inset

 predicates,
 there is an 
\begin_inset Formula $X$
\end_inset

-computable copy of its reduct to the last 
\begin_inset Formula $k-1$
\end_inset

 predicates.
\end_layout

\end_deeper
\begin_layout Remark
The second and third bullet point imply that,
 for every 
\begin_inset Formula $n$
\end_inset

,
 
\begin_inset Formula $\ZFniptc$
\end_inset

 and 
\begin_inset Formula $T^{n}\upto S^{n}$
\end_inset

 are definitionally equivalent.
\end_layout

\begin_layout Standard
From 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:nestedpakhomov"

\end_inset

,
 we conclude one of the main results of this paper:
\end_layout

\begin_layout Theorem*
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:pakhomov_answer"

\end_inset


\end_layout

\end_inset

For every 
\begin_inset Formula $n$
\end_inset

,
 there is a theory definitionally equivalent to 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\mathsf{PA}$
\end_inset

 plus all true 
\begin_inset Formula $\Pi_{n}$
\end_inset

 sentences
\begin_inset Quotes erd
\end_inset

 that admits a computable non-standard model.
\end_layout

\begin_layout Proof
First,
 note that the theory 
\begin_inset Formula $T$
\end_inset

 containing 
\begin_inset Formula $\mathsf{PA}$
\end_inset

 plus all true 
\begin_inset Formula $\Pi_{n}$
\end_inset

 sentences is a 
\begin_inset Formula $0^{(n)}$
\end_inset

-c.e.
\begin_inset space \space{}
\end_inset

theory.
 By the results of Kaye and Wong 
\begin_inset CommandInset citation
LatexCommand cite
key "kaye_wong"
literal "false"

\end_inset

,
 
\begin_inset Formula $\mathsf{PA}$
\end_inset

 is definitionally equivalent to 
\begin_inset Formula $\ZFfinptc$
\end_inset

,
 and therefore 
\begin_inset Formula $T$
\end_inset

 is definitionally equivalent to a 
\begin_inset Formula $0^{(n)}$
\end_inset

-c.e.
\begin_inset space \space{}
\end_inset

extension of the theory 
\begin_inset Formula $T^{n+1}$
\end_inset

 from 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:nestedpakhomov"

\end_inset

.
 Say 
\begin_inset Formula $\bar{T}$
\end_inset

 is this theory,
 and let 
\begin_inset Formula $\bar{T}^{+}$
\end_inset

 be the same with an added constant 
\begin_inset Formula $c$
\end_inset

 and an axiom schema ensuring that 
\begin_inset Formula $c$
\end_inset

 is a nonstandard element.
 Let 
\begin_inset Formula $D$
\end_inset

 be a 
\begin_inset Formula $0^{(n+1)}$
\end_inset

-computable model of 
\begin_inset Formula $\bar{T}^{+}$
\end_inset

,
 in the signature containing the 
\begin_inset Formula $n+2$
\end_inset

 predicates 
\begin_inset Formula $S^{0}$
\end_inset

 to 
\begin_inset Formula $S^{n+1}$
\end_inset

,
 which exists by the computable completeness theorem (see 
\begin_inset CommandInset citation
LatexCommand cite
key "harizanov"
literal "false"

\end_inset

).
 Then,
 apply the relativized version of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:nestedpakhomov"

\end_inset

 
\begin_inset Formula $n+1$
\end_inset

 times,
 obtaining a computable model of 
\begin_inset Formula $\bar{T}\upto S^{n+1}$
\end_inset

.
 This shows that 
\begin_inset Formula $\bar{T}\upto S^{n+1}$
\end_inset

 is the theory we sought:
 It is definitionally equivalent to 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\mathsf{PA}$
\end_inset

 plus all true 
\begin_inset Formula $\Pi_{n}$
\end_inset

 sentences
\begin_inset Quotes erd
\end_inset

,
 and it admits a computable nonstandard model.
\end_layout

\begin_layout Standard
As an aside,
 we note that Pakhomov posed another question in his original paper,
 which has since been answered by Lutz and Walsh.
\end_layout

\begin_layout Question*
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Pakhomov 
\begin_inset CommandInset citation
LatexCommand cite
key "pakhomov"
literal "false"

\end_inset


\end_layout

\end_inset

Is there a c.e.
\begin_inset space \space{}
\end_inset

theory 
\begin_inset Formula $T$
\end_inset

 such that no definitionally equivalent theory 
\begin_inset Formula $T'$
\end_inset

 admits a computable model?
\end_layout

\begin_layout Theorem
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Lutz–Walsh 
\begin_inset CommandInset citation
LatexCommand cite
key "lutz_walsh_tennenbaum"
literal "false"

\end_inset


\end_layout

\end_inset

There is a c.e.
\begin_inset space \space{}
\end_inset

theory 
\begin_inset Formula $T$
\end_inset

 such that every model of every theory 
\begin_inset Formula $T'$
\end_inset

 definitionally equivalent to 
\begin_inset Formula $T$
\end_inset

 is noncomputable.
\end_layout

\begin_layout Subsection
A Strong Jump Inversion Theorem
\end_layout

\begin_layout Standard
In the process of answering Pakhomov's question,
 it happened that certain parts of our construction were not specific to the particularities of arithmetic,
 and so we were able to extract a general-purpose theorem for strong jump inversion.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Patrick Lutz was the first person to bring the idea of a broad generalization to my attention.
 He also provided a working conjecture that was very useful in developing the theory.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For our purposes,
 a strong jump inversion type theorem is one of the following form:
 
\begin_inset Quotes eld
\end_inset

If [structure of a certain type with a lot of data] admits a copy computable in 
\begin_inset Formula $X'$
\end_inset

,
 then [reduct of the same structure with fewer data] admits a copy computable in 
\begin_inset Formula $X$
\end_inset

.
\begin_inset Quotes erd
\end_inset

 (See 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rmk:jumpinversion"

\end_inset

 below for a much more detailed description.) Here are a few examples.
 We state them for the computable case,
 but they all relativize uniformly in the obvious way.
\begin_inset Note Note
status open

\begin_layout Plain Layout
does rice complete shenanigans apply to pakhomov's S and my sequence of S relations?
 conjecture:
 
\begin_inset Formula $\in$
\end_inset

 is (co?)rice-complete in 
\begin_inset Formula $S$
\end_inset

.
\end_layout

\end_inset


\begin_inset FormulaMacro
\newcommand{\eqvrel}{\simeq}
\end_inset


\end_layout

\begin_layout Theorem
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Folklore,
 
\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "cst_downey_melnikov"
posttextlist "cst_downey_melnikov Theorem 9.1.4"
literal "false"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "thm:JIeqv"

\end_inset

Suppose that 
\begin_inset Formula $(E,\eqvrel)$
\end_inset

 is an equivalence relation with infinitely many infinite equivalence classes,
 and for 
\begin_inset Formula $n\in\N$
\end_inset

 let 
\begin_inset Formula $P_{\geq n}(x)$
\end_inset

 be the predicate 
\begin_inset Quotes eld
\end_inset

the equivalence class of 
\begin_inset Formula $x$
\end_inset

 has at least 
\begin_inset Formula $n$
\end_inset

 elements
\begin_inset Quotes erd
\end_inset

.
 If 
\begin_inset Formula $(E,\eqvrel,\{P_{\geq n}\}_{n\in\N})$
\end_inset

 admits a 
\begin_inset Formula $0'$
\end_inset

-computable copy,
 then 
\begin_inset Formula $(E,\eqvrel)$
\end_inset

 admits a computable copy.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Theorem
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Knight–Stob 
\begin_inset CommandInset citation
LatexCommand cite
key "knight_stob_computable_boolean_algebras"
literal "false"

\end_inset

,
 Downey–Jockusch 
\begin_inset CommandInset citation
LatexCommand cite
key "downey_jockusch_boolean"
literal "false"

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "thm:JIbool"

\end_inset

Suppose that 
\begin_inset Formula $B$
\end_inset

 is a Boolean algebra,
 and suppose that the structure 
\begin_inset Formula $(B,\land,\lor,\mathrm{isAtom})$
\end_inset

 admits a 
\begin_inset Formula $0'$
\end_inset

-computable copy.
 Then,
 the structure 
\begin_inset Formula $(B,\land,\lor)$
\end_inset

 admits a computable copy.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Theorem
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Fellner,
 
\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "montalban_cst"
posttextlist "montalban_cst VII.26"
literal "false"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "thm:JIlinear"

\end_inset

Suppose that 
\begin_inset Formula $L$
\end_inset

 is a linear order for which every element admits a successor and predecessor,
 and suppose that the structure 
\begin_inset Formula $(L,<,S)$
\end_inset

 admits a 
\begin_inset Formula $0'$
\end_inset

-computable copy,
 where 
\begin_inset Formula $S(x,y)$
\end_inset

 is the successor relation.
 Then,
 the structure 
\begin_inset Formula $(L,<)$
\end_inset

 admits a computable copy.
\end_layout

\begin_layout Standard
It would be interesting to find a broad theorem from which Theorems 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:JIeqv"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:JIbool"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:JIlinear"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 could follow as corollaries.
 We have had some amount of success:
 Our general-purpose 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 is (with some work) able to subsume Theorems 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:JIeqv"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:JIlinear"

\end_inset

 (respectively in Sections 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:eqvrelsinf"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:linord"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

),
 as well as some other theorems in the literature (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:prevs_applications"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

).
 We have not yet had success in obtaining 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:JIbool"

\end_inset

,
 but we do not believe this to be impossible – rather,
 it happens that Boolean algebras are more complex than most structures we work with in this paper,
 and would require more significant effort to apply 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 to.
\end_layout

\begin_layout Standard
We are not the first to seek such a theorem – the 2018 paper 
\begin_inset CommandInset citation
LatexCommand cite
key "strong_jump_inversion"
literal "false"

\end_inset

 also contains a general-purpose theorem (Theorem 2.5) from which results related to the above are partially recovered.
 Our theorem seems to follow similar themes as the theorem found in 
\begin_inset CommandInset citation
LatexCommand cite
key "strong_jump_inversion"
literal "false"

\end_inset

,
 but our assumptions have a different flavor and our conclusion goes in a different direction.
 Notably,
 our result requires some amount of creativity in its application – one must,
 in most cases,
 construct an intermediate structure to apply our 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 to in order to obtain a jump inversion result,
 while Theorem 2.5 from 
\begin_inset CommandInset citation
LatexCommand cite
key "strong_jump_inversion"
literal "false"

\end_inset

 is relatively straight-forward in its application to examples.
\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rmk:jumpinversion"

\end_inset

 For a general framework on the meaning of 
\begin_inset Quotes eld
\end_inset

jump inversion theorem
\begin_inset Quotes erd
\end_inset

,
 we refer the reader to Section 1.1 of 
\begin_inset CommandInset citation
LatexCommand cite
key "strong_jump_inversion"
literal "false"

\end_inset

.
 For completeness and conciseness,
 we provide a very brief summary.
 The content and nomenclature of this remark is mostly taken from 
\begin_inset CommandInset citation
LatexCommand cite
key "montalban_cst"
literal "false"

\end_inset

.
\end_layout

\begin_layout Remark
First,
 let us remark that there is a standard notion of 
\begin_inset Quotes eld
\end_inset

the jump of a structure
\begin_inset Quotes erd
\end_inset

,
 see e.g.
\begin_inset space \space{}
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "montalban_cst"
posttextlist "montalban_cst Definition IX.1"
literal "false"

\end_inset

,
 which is known to subsume several other different notions of 
\begin_inset Quotes eld
\end_inset

jump of a structure
\begin_inset Quotes erd
\end_inset

 that have arisen over the decades;
 see Historical Remark IX.2 in 
\begin_inset CommandInset citation
LatexCommand cite
key "montalban_cst"
literal "false"

\end_inset

 and Remark 1.11 in 
\begin_inset CommandInset citation
LatexCommand cite
key "strong_jump_inversion"
literal "false"

\end_inset

.
 The notion of 
\begin_inset Quotes eld
\end_inset

jump of a structure
\begin_inset Quotes erd
\end_inset

 under discussion consists of adding a certain predicate,
 or rather,
 countable family of predicates,
 called Kleene's r.i.c.e.
\begin_inset space \space{}
\end_inset

complete relation,
 to the language of a structure.
\end_layout

\begin_layout Remark
While the definition of Kleene's r.i.c.e.
\begin_inset space \space{}
\end_inset

complete relation is completely generic and applies to any structure in the usual sense,
 it is markedly unnatural,
 in the sense that it has surely never arisen outside the context of computability.
 However,
 for some particular types of structures,
 Kleene's relation may be replaced (up to 
\begin_inset Quotes eld
\end_inset

relative Turing equivalence
\begin_inset Quotes erd
\end_inset

,
 which is a natural type of equivalence of relations on a structure which compares their intrinsic computable complexity) by much more natural families of relations.
 For example,
 on an arbitrary linear ordering 
\begin_inset Formula $(L,\leq)$
\end_inset

,
 the adjacency relation together with 
\begin_inset Formula $0'$
\end_inset

 (encoded as a countable family of zero-ary predicates) is relatively Turing equivalent to Kleene's r.i.c.e.
\begin_inset space \space{}
\end_inset

complete relation 
\begin_inset CommandInset citation
LatexCommand cite
key "montalban_cst"
posttextlist "montalban_cst Example II.29"
literal "false"

\end_inset

,
 and thus it is reasonable to identify the jump of a linear ordering 
\begin_inset Formula $(L,\leq)$
\end_inset

 with the structure 
\begin_inset Formula $(L,\leq,S)$
\end_inset

 plus an oracle for 
\begin_inset Formula $0'$
\end_inset

.
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fn:adjvsnegadj"

\end_inset

We may instead prefer the negation of the adjacency relation,
 because checking non-adjacency in a linear order is c.e.
\begin_inset space \space{}
\end_inset

while checking adjacency is co-c.e.
\end_layout

\end_inset


\end_layout

\begin_layout Remark
The fact that this oracle for 
\begin_inset Formula $0'$
\end_inset

 appears,
 even when the rest of the 
\begin_inset Quotes eld
\end_inset

computable information
\begin_inset Quotes erd
\end_inset

 of the jump has been nicely encompassed by the natural relation 
\begin_inset Formula $S$
\end_inset

,
 may be seen as a flaw.
 This gives rise to the notion of 
\begin_inset Quotes eld
\end_inset

the/a structural jump of a structure
\begin_inset Quotes erd
\end_inset

.
 We refer to Definition 1.12 in 
\begin_inset CommandInset citation
LatexCommand cite
key "strong_jump_inversion"
literal "false"

\end_inset

,
 which we paraphrase in slightly different but equivalent terms:
\end_layout

\begin_deeper
\begin_layout Definition*
A structural jump of a structure 
\begin_inset Formula $\mathcal{A}$
\end_inset

 is an expansion 
\begin_inset Formula $\mathcal{A}'=(\mathcal{A},(R_{i})_{i\in\N})$
\end_inset

 such that the relations 
\begin_inset Formula $R_{i}$
\end_inset

 are uniformly r.i.c.e.
\begin_inset space \space{}
\end_inset

in 
\begin_inset Formula $\mathcal{A}$
\end_inset

 (this is the natural analogue of the notion of c.e.
\begin_inset space \space{}
\end_inset

in this context),
 and such that Kleene's r.i.c.e.
\begin_inset space \space{}
\end_inset

complete relation 
\begin_inset Formula $K^{\mathcal{A}}$
\end_inset

 is relatively intrinsically computable from 
\begin_inset Formula $\mathcal{A}'\oplus0'$
\end_inset

 (this the natural analogue of computable from the oracle 
\begin_inset Formula $\mathcal{A}'\oplus0'$
\end_inset

).
\end_layout

\begin_layout Standard
It should be noted that the jump of a structure is always a structural jump of said structure,
 but the benefit of this definition is that,
 in some cases,
 there exist natural structural jumps,
 where natural means 
\begin_inset Quotes eld
\end_inset

has been studied by non-logicians
\begin_inset Quotes erd
\end_inset

.
 The following three examples should seem familiar:
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $(E,\eqvrel)$
\end_inset

 is an equivalence relation,
 the expansion 
\begin_inset Formula $(E,\eqvrel,\{P_{\geq n}\}_{n\in\N})$
\end_inset

 from 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:JIeqv"

\end_inset

 is a structural jump of 
\begin_inset Formula $(E,\eqvrel)$
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "montalban_cst"
posttextlist "montalban_cst Exercise II.45.(b)"
literal "false"

\end_inset

,
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $B$
\end_inset

 is a Boolean algebra,
 the expansion 
\begin_inset Formula $(B,\mathrm{isAtom})$
\end_inset

 is a structural jump of 
\begin_inset Formula $B$
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "strong_jump_inversion"
literal "false"

\end_inset

,
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $(L,\leq)$
\end_inset

 is a linear ordering,
 the expansion 
\begin_inset Formula $(L,\leq,\neg S)$
\end_inset

 is a structural jump of 
\begin_inset Formula $(L,\leq)$
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "strong_jump_inversion"
literal "false"

\end_inset

.
\begin_inset Foot
status open

\begin_layout Plain Layout
The authors claim that 
\begin_inset Quotes eld
\end_inset

[to form the structural jump,] the relation 
\begin_inset Formula $\mathit{succ}(x,y)$
\end_inset

 is sufficient for linear orders
\begin_inset Quotes erd
\end_inset

,
 but this is a typo,
 in letter if not in spirit,
 because as mentioned in Footnote 
\begin_inset CommandInset ref
LatexCommand ref
reference "fn:adjvsnegadj"

\end_inset

,
 the successor relation is co-r.i.c.e.
 and not r.i.c.e.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There is an established analogue of the Friedberg Jump Inversion theorem in this context,
 due to Soskov and Soskova 
\begin_inset CommandInset citation
LatexCommand cite
key "soskova_soskov_jump_inversion"
literal "false"

\end_inset

,
 and later independently rediscovered by Montalban 
\begin_inset CommandInset citation
LatexCommand cite
key "montalban_notes_jump_structure"
literal "false"

\end_inset

.
 Two versions thereof,
 slightly different to each other,
 may be found in 
\begin_inset CommandInset citation
LatexCommand cite
key "montalban_cst"
posttextlist "montalban_cst Theorem IX.9"
literal "false"

\end_inset

 and 
\begin_inset CommandInset citation
LatexCommand cite
key "strong_jump_inversion"
posttextlist "strong_jump_inversion Theorem 1.13"
literal "false"

\end_inset

.
 We state only a particular case:
\end_layout

\begin_layout Theorem*
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Soskov–Soskova 
\begin_inset CommandInset citation
LatexCommand cite
key "soskova_soskov_jump_inversion"
literal "false"

\end_inset

,
 Montalban 
\begin_inset CommandInset citation
LatexCommand cite
key "montalban_notes_jump_structure"
literal "false"

\end_inset


\end_layout

\end_inset

If there is a 
\begin_inset Formula $0'$
\end_inset

-computable copy of a structural jump of a structure,
 then there is a low copy of the original structure.
\end_layout

\begin_layout Standard
If this is the theorem that we may refer to by the name of 
\begin_inset Quotes eld
\end_inset

jump inversion
\begin_inset Quotes erd
\end_inset

,
 then it stands to reason that we might make the following definition:
\end_layout

\begin_layout Definition*
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Strong definition
\end_layout

\end_inset

A 
\emph on
strong jump inversion theorem
\emph default
 is one of the type:
 If there is a 
\begin_inset Formula $0'$
\end_inset

-computable copy of the structural jump of a [insert class of structures here],
 then there is a 
\bar under
computable
\bar default
 copy of the original structure.
\end_layout

\begin_layout Standard
We prefer to slightly weaken this 
\begin_inset Quotes eld
\end_inset

definition
\begin_inset Quotes erd
\end_inset

,
 so that we are not beholden every time to verifying that certain relations make up a structural jump of a structure,
 leading to a wider class of possible results:
\end_layout

\begin_layout Definition*
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Weak definition
\end_layout

\end_inset

A 
\emph on
strong jump inversion theorem
\emph default
 is one of the type:
 If there is a 
\begin_inset Formula $0'$
\end_inset

-computable copy of a [insert class of structures here],
 say 
\begin_inset Formula $\mathcal{A}$
\end_inset

,
 together with [additional structure],
 then there is a computable copy of 
\begin_inset Formula $\mathcal{A}$
\end_inset

.
\end_layout

\begin_layout Standard
We finish this remark with the following fact,
 which further justifies how we've chosen to weaken the notion of strong jump inversion theorem.
 Suppose that we've shown that,
 for structures 
\begin_inset Formula $\mathcal{A}$
\end_inset

 in some class,
 if there is a 
\begin_inset Formula $0'$
\end_inset

-computable copy of 
\begin_inset Formula $\mathcal{A}$
\end_inset

 together with additional relations 
\begin_inset Formula $(R_{i})_{i\in\N}$
\end_inset

,
 then there is a computable copy of 
\begin_inset Formula $\mathcal{A}$
\end_inset

.
 Then,
 under some relatively weak assumptions on the relations 
\begin_inset Formula $(R_{i})_{i\in\N}$
\end_inset

 (e.g.
\begin_inset space \space{}
\end_inset

that they are uniformly r.i.c.e.,
 or more generally that they're relatively intrinsically computable from the jump of 
\begin_inset Formula $\mathcal{A}$
\end_inset

) we can actually conclude that if there's a 
\begin_inset Formula $0'$
\end_inset

-computable copy of 
\emph on
any
\emph default
 structural jump of 
\begin_inset Formula $\mathcal{A}$
\end_inset

 then there is a computable copy of 
\begin_inset Formula $\mathcal{A}$
\end_inset

.
 This is because 
\begin_inset Formula $0'$
\end_inset

 plus any structural jump of 
\begin_inset Formula $\mathcal{A}$
\end_inset

 suffices to uniformly compute the relations 
\begin_inset Formula $(R_{i})_{i\in\N}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
We will now present our main result,
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 but first we must make some necessary definitions.
 There are two important components to 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

:
 A computable-structure-theoretic definition (
\begin_inset CommandInset ref
LatexCommand formatted
reference "def:cetypedpresentation"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

),
 and an almost entirely model-theoretic condition (
\begin_inset CommandInset ref
LatexCommand formatted
reference "def:qetp"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

).
\end_layout

\begin_layout Standard
Henceforth,
 we restrict our attention to relational structures.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "def:atomicformula"

\end_inset

For our purposes,
 an 
\emph on
atomic formula
\emph default
 in the variables 
\begin_inset Formula $\vec{x}$
\end_inset

 is a formula obtained by applying a single predicate to some of the variables in the tuple 
\begin_inset Formula $\vec{x}$
\end_inset

 (possibly repeated and reordered).
 Notably,
 under our definition,
 the atomic formulas are 
\emph on
not
\emph default
 closed under negation – over the signature 
\begin_inset Formula $\Lang=\{\leq\}$
\end_inset

 of a linear order,
 
\begin_inset Formula $x\leq y$
\end_inset

 is considered an atomic formula,
 but 
\begin_inset Formula $\neg(x\leq y)$
\end_inset

 is not.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "def:atomictype"

\end_inset

An 
\emph on
atomic type
\emph default
 in the variables 
\begin_inset Formula $\vec{x}$
\end_inset

 is simply a set of atomic formulas in 
\begin_inset Formula $\vec{x}$
\end_inset

.
 For a tuple of elements 
\begin_inset Formula $\vec{b}$
\end_inset

 in a structure,
 the 
\emph on
atomic type of 
\begin_inset Formula $\vec{b}$
\end_inset


\emph default
 consists of the set of atomic formulas satisfied by 
\begin_inset Formula $\vec{b}$
\end_inset

.
\end_layout

\begin_layout Remark
It is important to note that,
 while atomic types and quantifier-free types contain the same data in a lot of contexts,
 the same shall not be the case in our scenario.
 We will work with c.e.
\begin_inset space \space{}
\end_inset

indices for atomic types,
 from which it is not generally possible to obtain a c.e.
\begin_inset space \space{}
\end_inset

index for the corresponding quantifier-free type (which,
 indeed,
 may not even be c.e.).
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition*
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand ref
reference "def:cetypedpresentation"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset


\end_layout

\end_inset

Let 
\begin_inset Formula $\Lang'$
\end_inset

 be a computable relational signature.
\begin_inset FormulaMacro
\newcommand{\tp}{\mathrm{tp}}
\end_inset

 A
\emph on
 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed structure
\emph default
 
\begin_inset Formula $D$
\end_inset

 consists of a 
\begin_inset Formula $0'$
\end_inset

-computable function 
\begin_inset Formula $t$
\end_inset

,
 whose domain is the finite power-set of an initial segment of 
\begin_inset Formula $\N$
\end_inset

 (this initial segment we call the 
\emph on
domain
\emph default
 of 
\begin_inset Formula $D$
\end_inset

),
 which takes as input the strong index of a finite set of natural numbers 
\begin_inset Formula $\vec{n}=\{n_{0}<n_{1}<\dots<n_{k-1}\}$
\end_inset

 and outputs the c.e.
\begin_inset space \space{}
\end_inset

index 
\begin_inset Formula $t(\vec{n})$
\end_inset

 for an atomic 
\begin_inset Formula $\Lang'$
\end_inset

-type 
\begin_inset Formula $\tp(\vec{n})$
\end_inset

 in the variables 
\begin_inset Formula $(x_{n_{0}},\dots,x_{n_{k-1}})$
\end_inset

,
 with the compatibility condition that if 
\begin_inset Formula $\vec{n}\subseteq\vec{m}$
\end_inset

 then 
\begin_inset Formula $\tp(\vec{n})\subseteq\tp(\vec{m})$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
A 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed structure 
\begin_inset Formula $D$
\end_inset

 induces a natural 
\begin_inset Formula $\Lang'$
\end_inset

 structure on the domain of 
\begin_inset Formula $D$
\end_inset

.
 Thus,
 in a slight abuse of notation we often identify 
\begin_inset Formula $D$
\end_inset

 with the 
\begin_inset Formula $\Lang'$
\end_inset

-structure obtained in this manner,
 allowing us to speak,
 for example,
 of an isomorphism between a 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed structure and other structures.
 In particular,
 if 
\begin_inset Formula $D_{0}$
\end_inset

 is a pre-existing 
\begin_inset Formula $\Lang'$
\end_inset

-structure we define a 
\emph on

\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed copy of 
\begin_inset Formula $D_{0}$
\end_inset


\emph default
 to mean a 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed structure 
\begin_inset Formula $D$
\end_inset

 which is isomorphic to 
\begin_inset Formula $D_{0}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
\begin_inset CommandInset ref
LatexCommand formatted
reference "def:cetypedpresentation"

\end_inset

 is very much not symmetric with regard to negation of predicates.
 It can make a stark difference as to whether our language includes,
 for every predicate 
\begin_inset Formula $P$
\end_inset

,
 its negation 
\begin_inset Formula $\neg P$
\end_inset

 or not.
\end_layout

\begin_layout Standard
In order to introduce our model-theoretic definition,
 we need to recall some concepts from computable structure theory.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition*
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand ref
reference "def:comp_inf_lang"

\end_inset


\end_layout

\end_inset

We shall work in the Computable Infinitary Language,
 as described in 
\begin_inset CommandInset citation
LatexCommand cite
key "montalban_cst2"
posttextlist "montalban_cst2 Chapter III"
literal "false"

\end_inset

.
 We will only work with a very small fragment of this language,
 which we now describe.
\end_layout

\begin_layout Definition*
Given a relational signature 
\begin_inset Formula $\Lang'$
\end_inset

,
 we define the set of 
\emph on
positive finitary conjunctive formulas
\emph default
 as the set of formulas of the type 
\begin_inset Formula $\varphi(\vec{x})\equiv P_{1}\land\dots\land P_{n}$
\end_inset

,
 where each 
\begin_inset Formula $P_{j}$
\end_inset

 denotes a relation in 
\begin_inset Formula $\Lang'$
\end_inset

 being applied to a tuple of variables from 
\begin_inset Formula $\vec{x}$
\end_inset

,
 in any order,
 with the possibility of repeated or omitted variables.
 We also allow for 
\begin_inset Formula $P_{j}$
\end_inset

 to denote 
\begin_inset Formula $\top$
\end_inset

,
 the 
\begin_inset Quotes eld
\end_inset

true
\begin_inset Quotes erd
\end_inset

 predicate,
 and 
\begin_inset Formula $\bot$
\end_inset

,
 the 
\begin_inset Quotes eld
\end_inset

false
\begin_inset Quotes erd
\end_inset

 predicate.
\end_layout

\begin_layout Definition*
We define the set of
\emph on
 positive computable quantifier-free disjunctive formulas
\emph default
,
 denoted by 
\begin_inset Formula $\llorc$
\end_inset

,
 as the set of formulas in finitely many variables of the type
\begin_inset Formula 
\[
\varphi(\vec{x})\equiv\llor_{i<\omega}\varphi_{i}(\vec{x}),
\]

\end_inset

where 
\begin_inset Formula $\{\varphi_{i}\}_{i<\omega}$
\end_inset

 is a computable sequence of positive finitary conjunctive formulas.
\end_layout

\begin_layout Definition*
Finally,
 we define a third set of formulas,
 denoted by 
\begin_inset Formula $\llorc_{2}$
\end_inset

,
 as those formulas in finitely many variables of the type
\begin_inset Formula 
\[
\varphi(\vec{x})\equiv\llor_{i<\omega}\left(\psi_{i}(\vec{x})\land\neg\varphi_{i}(\vec{x})\right),
\]

\end_inset

where 
\begin_inset Formula $\{\psi_{i}\}_{i<\omega}$
\end_inset

 is a computable sequence of positive finitary conjunctive formulas,
 and 
\begin_inset Formula $\{\varphi_{i}\}_{i<\omega}$
\end_inset

 is a computable sequence of 
\begin_inset Formula $\llorc$
\end_inset

 formulas.
\end_layout

\begin_layout Definition*
One can imagine iterating this definition to obtain a hierarchy of quantifier-free formulas 
\begin_inset Formula $\left\{ \llorc_{n}\right\} _{n\in\N}$
\end_inset

 in the computable infinitary language,
 but these first two levels will be enough for our work.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
Given a formula in the computable infinitary language,
 say 
\begin_inset Formula $\varphi(\vec{x})$
\end_inset

,
 a structure 
\begin_inset Formula $D$
\end_inset

,
 and a tuple of elements 
\begin_inset Formula $\vec{b}$
\end_inset

 of 
\begin_inset Formula $D$
\end_inset

,
 we assign a truth value to the expression 
\begin_inset Formula $D\vDash\varphi(\vec{b})$
\end_inset

 in the obvious way.
 See 
\begin_inset CommandInset citation
LatexCommand cite
key "montalban_cst2"
posttextlist "montalban_cst2 Chapter III"
literal "false"

\end_inset

 for more details.
\end_layout

\begin_layout Standard
We are now ready to make our model-theoretic definition.
 It is quite technical,
 so we first provide some intuition and motivation.
\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rmk:qetpmotivation"

\end_inset

Many strong jump inversion type results follow a pattern as follows.
 We are given a 
\begin_inset Formula $0'$
\end_inset

-computable structure.
 Using ideas similar to Shoenfield's Limit Lemma,
 imagine this structure as being given by a computable process that sometimes makes mistakes (particularly,
 sometimes adds 
\begin_inset Quotes eld
\end_inset

fake
\begin_inset Quotes erd
\end_inset

 elements and later realizes this error).
 Now,
 we construct a computable copy of our structure as follows:
 Copy the limit-computable process,
 and when you realize that an element was incorrectly added,
 repurpose it to serve as another element that you somehow know exists – oftentimes,
 the structure you are working with admits a class of elements that can be reliably used to 
\begin_inset Quotes eld
\end_inset

dispose of trash
\begin_inset Quotes erd
\end_inset

.
 For example,
 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:JIeqv"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 any element added by accident can be relegated to an infinite equivalence class.
 This will be the role of the 
\begin_inset Formula $\tau$
\end_inset

 predicate defined in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "def:qetp"

\end_inset

.
 (The letter 
\begin_inset Formula $\tau$
\end_inset

 was chosen to stand for 
\begin_inset Quotes eld
\end_inset

trash
\begin_inset Quotes erd
\end_inset

,
 in the sense of 
\begin_inset Quotes eld
\end_inset

thing to be disposed of
\begin_inset Quotes erd
\end_inset

.)
\end_layout

\begin_layout Remark
Sometimes,
 we do not immediately know what kind of trash a given element will be relegated to.
 As an example,
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:eqvfin"

\end_inset

 below regards a certain type of equivalence relation with only finitely many infinite equivalence relations.
 Then,
 if an element 
\begin_inset Formula $x$
\end_inset

 is meant to be disposed of,
 we cannot relegate it to an infinite equivalence class – instead,
 we relegate it to a 
\begin_inset Quotes eld
\end_inset

large enough
\begin_inset Quotes erd
\end_inset

 equivalence class.
 If the set of sizes of equivalence classes is c.e.,
 this is easy enough,
 but 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:eqvfin"

\end_inset

 also encompasses some situations in which the set of sizes of equivalence classes is not c.e.
\begin_inset space \space{}
\end_inset

(or even 
\begin_inset Formula $0'$
\end_inset

-c.e.).
 Thus,
 we provide relatively weak assumptions on the computability of 
\begin_inset Formula $\tau$
\end_inset

.
\end_layout

\begin_layout Remark
There are a few more considerations.
 Some mistakes are too costly to recover from.
 For example,
 back to 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:JIeqv"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 we cannot tolerate adding an element that breaks the assumption that 
\begin_inset Formula $\eqvrel$
\end_inset

 is an equivalence relation – e.g.
\begin_inset space \space{}
\end_inset

an element 
\begin_inset Formula $x$
\end_inset

 with 
\begin_inset Formula $x\eqvrel y$
\end_inset

 and 
\begin_inset Formula $x\not\eqvrel z$
\end_inset

,
 where 
\begin_inset Formula $y$
\end_inset

 and 
\begin_inset Formula $z$
\end_inset

 are two previously-added elements with 
\begin_inset Formula $y\eqvrel z$
\end_inset

.
 In most concrete cases,
 it is easy to assume without loss of generality that such pathological cases never show up,
 but this must be explicitly handled when creating a general-purpose theorem.
 This will be the role of the 
\begin_inset Formula $\chi$
\end_inset

 predicate defined in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "def:qetp"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
\end_layout

\begin_layout Remark
For technical reasons,
 we also introduce a third predicate,
 which we call
\begin_inset FormulaMacro
\newcommand{\etau}{\mathord{\varepsilon\tau}}
\end_inset

 
\begin_inset Formula $\etau$
\end_inset

 (where the 
\begin_inset Formula $\varepsilon$
\end_inset

 stands for 
\begin_inset Quotes eld
\end_inset

exists
\begin_inset Quotes erd
\end_inset

).
 The motivation for why this predicate is necessary is a little too elaborate to explain shortly in words,
 but very roughly,
 it has to do with the fact that,
 if an element has been relegated to be trash by 
\begin_inset Formula $\tau$
\end_inset

,
 but it has been relegated to an 
\begin_inset Quotes els
\end_inset

incorrect
\begin_inset Quotes ers
\end_inset

 or 
\begin_inset Quotes els
\end_inset

fake
\begin_inset Quotes ers
\end_inset

 trash element,
 the feasibility of adding more elements (satisfying some prescription 
\begin_inset Formula $Q$
\end_inset

) as measured by 
\begin_inset Formula $\chi$
\end_inset

 is unreliable.
 As such,
 we need a proxy for 
\begin_inset Formula $\chi(\vec{x},y)\equiv\exists_{\vec{z}}Q(\vec{x},y,\vec{z})$
\end_inset

 that doesn't rely on 
\begin_inset Formula $y$
\end_inset

,
 which is thus the role of 
\begin_inset Formula $\etau(\vec{x})\equiv\exists_{y}\exists_{\vec{z}}\left[\tau(\vec{x},y)\land Q(\vec{x},y,\vec{z})\right]$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition*
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand ref
reference "def:qetp"

\end_inset


\end_layout

\end_inset

Let 
\begin_inset Formula $\Lang\subseteq\Lang'$
\end_inset

 be computable signatures,
 and let 
\begin_inset Formula $D$
\end_inset

 be a structure over 
\begin_inset Formula $\Lang'$
\end_inset

.
 We say that 
\begin_inset Formula $D$
\end_inset

 satisfies the 
\emph on
Computable Positive Quantifier Elimination and Trash Existence Property
\emph default
,
 abbreviated to 
\emph on
QETP,

\emph default
 if the following properties hold:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

label=(
\backslash
alph*)
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\Lang$
\end_inset

 is finite,
 closed under negation,
 and includes the predicate 
\begin_inset Formula $\neq$
\end_inset

,
\end_layout

\begin_layout Enumerate
For every quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

 formula 
\begin_inset Formula $q(\vec{x},\vec{y})$
\end_inset

,
 there is a 
\begin_inset Formula $\llorc$
\end_inset


\emph on
 
\emph default

\begin_inset Formula $\Lang'$
\end_inset

-formula 
\begin_inset Formula $\chi_{q}(\vec{x})$
\end_inset

,
 computable from 
\begin_inset Formula $q$
\end_inset

,
 such that
\begin_inset Formula 
\[
D\vDash\forall_{\vec{x}}\left[\chi_{q}(\vec{x})\leftrightarrow\exists_{\vec{y}}q(\vec{x},\vec{y})\right],
\]

\end_inset


\end_layout

\begin_layout Enumerate
There is a 
\begin_inset Formula $0'$
\end_inset

-computable 
\emph on
partial
\emph default
 function denoted 
\begin_inset Formula $\tau$
\end_inset

,
 which takes as input a pair 
\begin_inset Formula $(q(\vec{x},y,\vec{z}),\varphi(\vec{x}))$
\end_inset

,
 where 
\begin_inset Formula $q(\vec{x},y,\vec{z})$
\end_inset

 is a quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

-type and 
\begin_inset Formula $\varphi(\vec{x})$
\end_inset

 is a 
\emph on
finitary
\emph default
 quantifier-free 
\begin_inset Formula $\Lang'$
\end_inset

-formula,
 whose output is a 
\begin_inset Formula $\llorc_{2}$
\end_inset

 formula denoted 
\begin_inset Formula $\tau_{q\varphi}(\vec{x},y)$
\end_inset

 that satisfies the following two properties:
\end_layout

\begin_deeper
\begin_layout Itemize
For every tuple 
\begin_inset Formula $(\vec{x},y,\vec{z})$
\end_inset

 of elements in 
\begin_inset Formula $D$
\end_inset

,
 of 
\begin_inset Formula $\Lang$
\end_inset

-type 
\begin_inset Formula $q(\vec{x},y,\vec{z})$
\end_inset

,
 there is a formula 
\begin_inset Formula $\varphi(\vec{x})$
\end_inset

 satisfied by 
\begin_inset Formula $\vec{x}$
\end_inset

 such that 
\begin_inset Formula $(q,\varphi)$
\end_inset

 is in the domain of 
\begin_inset Formula $\tau$
\end_inset

.
 Equivalently,
 if 
\begin_inset Formula $\vec{b}$
\end_inset

 is a tuple of elements in 
\begin_inset Formula $D$
\end_inset

 such that 
\begin_inset Formula $D\vDash\chi_{q}(\vec{b})$
\end_inset

,
 there is 
\begin_inset Formula $\varphi(\vec{x})$
\end_inset

 such that 
\begin_inset Formula $(q,\varphi)$
\end_inset

 is in the domain of 
\begin_inset Formula $\tau$
\end_inset

 and 
\begin_inset Formula $D\vDash\varphi(\vec{b})$
\end_inset

.
 Moreover,
\end_layout

\begin_layout Itemize
The following formula holds in 
\begin_inset Formula $D$
\end_inset

:
\begin_inset Formula 
\[
D\vDash\forall_{\vec{x}}\left[\chi_{q}(\vec{x})\land\varphi(\vec{x})\rightarrow\exists_{y}\tau_{q\varphi}(\vec{x},y)\right].
\]

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
denis idea:
 assume that tau only hits the true tau i.o.
 instead of a.e.
 and try to get a 
\begin_inset Formula $0''$
\end_inset

 isomorphism
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Given a pair 
\begin_inset Formula $(q(\vec{x},y,\vec{z}),\varphi(\vec{x}))$
\end_inset

 in the domain of 
\begin_inset Formula $\tau$
\end_inset

 as above,
 together with a quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

-type 
\begin_inset Formula $Q(\vec{x},y,\vec{z},\vec{w})$
\end_inset

 extending 
\begin_inset Formula $q(\vec{x},y,\vec{z})$
\end_inset

,
 there is a 
\begin_inset Formula $\llorc$
\end_inset

 formula 
\begin_inset Formula $\etau_{q\varphi Q}(\vec{x})$
\end_inset

,
 computable from the triple 
\begin_inset Formula $(q,\varphi,Q)$
\end_inset

,
 such that
\begin_inset Formula 
\[
D\vDash\forall_{\vec{x}}\left[\exists_{y}\left[\chi_{Q}(\vec{x},y)\land\tau_{q\varphi}(\vec{x},y)\right]\leftrightarrow\etau_{q\varphi Q}(\vec{x})\right].
\]

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:qetp3-1"

\end_inset

Finally,
 for all 
\begin_inset Formula $q$
\end_inset

,
 
\begin_inset Formula $\varphi$
\end_inset

,
 
\begin_inset Formula $Q$
\end_inset

,
 we require 
\begin_inset Formula 
\[
D\vDash\forall_{\vec{x},y}\left[\etau_{q\varphi Q}(\vec{x})\land\tau_{q\varphi}(\vec{x},y)\rightarrow\chi_{Q}(\vec{x},y)\right].
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
We now are now ready to state the central result of this paper.
\end_layout

\begin_layout Theorem*
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:main_final"

\end_inset


\end_layout

\end_inset

If 
\begin_inset Formula $D$
\end_inset

 is a 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed structure over the signature 
\begin_inset Formula $\Lang'\supseteq\Lang$
\end_inset

 satisfying the QETP,
 then the reduct 
\begin_inset Formula $D\upto\Lang$
\end_inset

 admits a computable copy 
\begin_inset Formula $M$
\end_inset

.
 There is a 
\begin_inset Formula $0'$
\end_inset

-computable isomorphism between 
\begin_inset Formula $D\upto\Lang$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

.
 This result is uniform in the index for 
\begin_inset Formula $D$
\end_inset

 and an index for witnesses that 
\begin_inset Formula $D$
\end_inset

 satisfies the QETP,
\begin_inset Foot
status open

\begin_layout Plain Layout
This includes:
 An index for which predicates in 
\begin_inset Formula $\Lang$
\end_inset

 are the negation of each other,
 an index for the computable functions 
\begin_inset Formula $\chi$
\end_inset

 and 
\begin_inset Formula $\etau$
\end_inset

,
 and an index for the 
\begin_inset Formula $0'$
\end_inset

-computable function 
\begin_inset Formula $\tau$
\end_inset

.
\end_layout

\end_inset

 and relativizes uniformly.
\end_layout

\begin_layout Standard
As previously mentioned,
 we have been able to obtain pre-existing results from the literature as corollaries of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"

\end_inset

,
 some examples of which are found in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:prevs_applications"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
 We will now briefly describe another one of these applications as a toy example,
 to give the reader a flavor of the type of argument that we use.
\end_layout

\begin_layout Definition
If 
\begin_inset Formula $T$
\end_inset

 is a tree and 
\begin_inset Formula $\sigma$
\end_inset

 is a node,
 we use the term 
\begin_inset Quotes eld
\end_inset

parent of 
\begin_inset Formula $\sigma$
\end_inset


\begin_inset Quotes erd
\end_inset

 to mean the unique,
 if it exists,
 node that has 
\begin_inset Formula $\sigma$
\end_inset

 as a child.
 We use the term 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $a$
\end_inset

-th parent of 
\begin_inset Formula $\sigma$
\end_inset


\begin_inset Quotes erd
\end_inset

 to mean,
 if it exists,
 the parent of the parent of ...
 (repeated 
\begin_inset Formula $a$
\end_inset

 times) of the parent of 
\begin_inset Formula $\sigma$
\end_inset

.
 In particular,
 the 
\begin_inset Formula $0$
\end_inset

-th parent of 
\begin_inset Formula $\sigma$
\end_inset

 is 
\begin_inset Formula $\sigma$
\end_inset

 itself.
\end_layout

\begin_layout Proposition*
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand ref
reference "prop:trees"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 
\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "strong_jump_inversion"
posttextlist "strong_jump_inversion Proposition 3.8"
literal "false"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset FormulaMacro
\newcommand{\leaf}{\mathop{\mathrm{leaf}}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Shat}[2]{S_{#1\hat{\phantom{i}}#2}}
{S_{#1\hat{\ }#2}}
\end_inset

Let 
\begin_inset Formula $T$
\end_inset

 be an infinite tree in 
\begin_inset Formula $\omega^{<\omega}$
\end_inset

 (i.e.
\begin_inset space \space{}
\end_inset

a nonempty subset of 
\begin_inset Formula $\omega^{<\omega}$
\end_inset

 closed under prefixes) such that every node of 
\begin_inset Formula $T$
\end_inset

 is either a leaf or admits infinitely many children,
 of which finitely many are leaves.
 Define on 
\begin_inset Formula $T$
\end_inset

 the predicates:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\leaf(x)$
\end_inset

,
 meaning 
\begin_inset Formula $x$
\end_inset

 has no children,
\end_layout

\begin_layout Itemize
\begin_inset Formula $\Shat ab(x,y)$
\end_inset

,
 meaning that 
\begin_inset Formula $x$
\end_inset

 admits an 
\begin_inset Formula $a$
\end_inset

-th parent,
 and 
\begin_inset Formula $y$
\end_inset

 admits a 
\begin_inset Formula $b$
\end_inset

-th parent,
 and that these two are the same,
\end_layout

\begin_layout Itemize
\begin_inset Formula $R_{a}(x)$
\end_inset

,
 meaning that 
\begin_inset Formula $x$
\end_inset

 admits the root of the tree as an 
\begin_inset Formula $a$
\end_inset

-th parent,
\end_layout

\begin_layout Standard
which have as particular cases the predicates 
\begin_inset Formula $S(x,y)\equiv\Shat 01(x,y)$
\end_inset

,
 meaning that 
\begin_inset Formula $y$
\end_inset

 is a child of 
\begin_inset Formula $x$
\end_inset

,
 and 
\begin_inset Formula $R_{0}(x)$
\end_inset

,
 meaning that 
\begin_inset Formula $x$
\end_inset

 is the root.
\end_layout

\begin_layout Standard
Then,
 if the structure 
\begin_inset Formula $(T,\leaf,S,R_{0})$
\end_inset

 admits a 
\begin_inset Formula $0'$
\end_inset

-computable copy,
 the structure 
\begin_inset Formula $(T,S,R_{0})$
\end_inset

 admits a computable copy.
\end_layout

\end_deeper
\begin_layout Proof
We will only briefly sketch the proof.
 A more detailed proof can be found in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:trees"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
\end_layout

\begin_layout Proof
First,
 from a 
\begin_inset Formula $0'$
\end_inset

-computable copy of 
\begin_inset Formula $(T,\leaf,S,R_{0})$
\end_inset

 we uniformly compute a 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed copy of 
\begin_inset Formula $(T,\neg\leaf,\{\Shat ab,\neg\Shat ab\}_{a,b\in\N},\{R_{a},\neg R_{a}\}_{a\in\N})$
\end_inset

,
 and thus it suffices to show that the structure 
\begin_inset Formula $T$
\end_inset

 satisfies the QETP,
 over the signatures
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\Lang=(S,\neg S,R_{0},\neg R_{0},=,\neq)$
\end_inset

,
 and
\end_layout

\begin_layout Itemize
\begin_inset Formula $\Lang'$
\end_inset

 equals 
\begin_inset Formula $\Lang$
\end_inset

,
 plus 
\begin_inset Formula $\neg\leaf$
\end_inset

 and all predicates 
\begin_inset Formula $\Shat ab$
\end_inset

,
 
\begin_inset Formula $\neg\Shat ab$
\end_inset

,
 
\begin_inset Formula $R_{a}$
\end_inset

,
 and 
\begin_inset Formula $\neg R_{a}$
\end_inset

.
\end_layout

\begin_layout Standard
To this effect,
 we need to construct the functions 
\begin_inset Formula $\chi$
\end_inset

,
 
\begin_inset Formula $\tau$
\end_inset

,
 and 
\begin_inset Formula $\etau$
\end_inset

.
\end_layout

\begin_layout Itemize
To construct 
\begin_inset Formula $\chi$
\end_inset

:
 This is tantamount to proving a quantifier-elimination result for this type of structure.
 We relegate the (standard for quantifier-elimination type results) details to Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:trees"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
\end_layout

\begin_layout Itemize
To construct 
\begin_inset Formula $\tau$
\end_inset

:
 In our construction,
 the domain of 
\begin_inset Formula $\tau$
\end_inset

 is the set of pairs 
\begin_inset Formula $(q,\top)$
\end_inset

.
 In other words.
 
\begin_inset Formula $\varphi(\vec{x})$
\end_inset

 will always be 
\begin_inset Formula $\top$
\end_inset

 here.
\end_layout

\begin_deeper
\begin_layout Standard
Suppose that we are given the quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

-type 
\begin_inset Formula $q(\vec{x},y,\vec{z})$
\end_inset

.
 Our goal in defining 
\begin_inset Formula $\tau$
\end_inset

 is to define what it means for an element 
\begin_inset Formula $y$
\end_inset

 to be 
\begin_inset Quotes eld
\end_inset

trash
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

generic
\begin_inset Quotes erd
\end_inset

 relative to the remaining data.
 In this,
 there are two cases:
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $q$
\end_inset

 already prescribes that 
\begin_inset Formula $y$
\end_inset

 is related to some 
\begin_inset Formula $x_{i}$
\end_inset

 (e.g.
\begin_inset space \space{}
\end_inset

it includes the data 
\begin_inset Formula $S(x_{1},y)$
\end_inset

,
 or 
\begin_inset Formula $S(x_{1},z_{1})\land S(z_{1},y)$
\end_inset

),
 the position of 
\begin_inset Formula $y$
\end_inset

 in the tree relative to 
\begin_inset Formula $\vec{x}$
\end_inset

 is 
\begin_inset Quotes els
\end_inset

forced
\begin_inset Quotes ers
\end_inset

.
 In this case,
 we demand that 
\begin_inset Formula $y$
\end_inset

 is not a leaf.
 Thus,
 in this case,
 
\begin_inset Formula $\tau_{q\top}(\vec{x},y)\equiv\chi_{q}(\vec{x},y)\land\neg\leaf(y)$
\end_inset

.
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $q$
\end_inset

 does not prescribe the position of 
\begin_inset Formula $y$
\end_inset

 relative to any 
\begin_inset Formula $x_{i}$
\end_inset

,
 we would like to set 
\begin_inset Formula $y$
\end_inset

 to be an arbitrary child of the root.
 This will not necessarily work,
 because perhaps 
\begin_inset Formula $q$
\end_inset

 includes enough data to say that 
\begin_inset Formula $y$
\end_inset

 has some number of direct predecessors.
 Thus,
 we let 
\begin_inset Formula $N$
\end_inset

 be the least number of predecessors that 
\begin_inset Formula $q$
\end_inset

 guarantees 
\begin_inset Formula $y$
\end_inset

 has,
 and set 
\begin_inset Formula $\tau_{q\top}(\vec{x},y)$
\end_inset

 to mean 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $y$
\end_inset

 is not a leaf,
 has exactly 
\begin_inset Formula $N$
\end_inset

 predecessors,
 and no common ancestors with any 
\begin_inset Formula $x_{i}$
\end_inset

 other than the root
\begin_inset Quotes erd
\end_inset

.
 Note that we don't have any predicate 
\begin_inset Formula $Q(x_{i},y)$
\end_inset

 representing that two elements only have the root as common ancestor,
 but this can be expressed as a 
\begin_inset Formula $\llorc$
\end_inset

 sentence in 
\begin_inset Formula $\Lang'$
\end_inset

 as:
 for some 
\begin_inset Formula $a,b\in\N$
\end_inset

,
 
\begin_inset Formula $x_{i}$
\end_inset

 has depth 
\begin_inset Formula $a$
\end_inset

,
 
\begin_inset Formula $y$
\end_inset

 has depth 
\begin_inset Formula $b$
\end_inset

,
 and 
\begin_inset Formula $\neg\Shat{a-1}{b-1}(x,y)$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
To construct 
\begin_inset Formula $\etau$
\end_inset

:
 Given a quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

-type 
\begin_inset Formula $q(\vec{x},y,\vec{z})$
\end_inset

 and another,
 
\begin_inset Formula $Q(\vec{x},y,\vec{z},\vec{w})$
\end_inset

,
 extending it,
 we wish to determine,
 in terms of 
\begin_inset Formula $\vec{x}$
\end_inset

,
 whether there exists 
\begin_inset Formula $y$
\end_inset

 satisfying 
\begin_inset Formula $\chi_{Q}(\vec{x},y)$
\end_inset

 and 
\begin_inset Formula $\tau_{q\top}(\vec{x},y)$
\end_inset

.
 This consists of (metatheoretically) inspecting the demands that are made of 
\begin_inset Formula $y$
\end_inset

 by 
\begin_inset Formula $\chi_{Q}$
\end_inset

 and by 
\begin_inset Formula $\tau_{q\top}$
\end_inset

 and verifying that none of them interfere with each other.
 If none do,
 set 
\begin_inset Formula $\etau_{q\top Q}(\vec{x})\equiv\chi_{Q}(\vec{x})$
\end_inset

;
 otherwise,
 set 
\begin_inset Formula $\etau_{q\top Q}(\vec{x})\equiv\bot$
\end_inset

.
\end_layout

\begin_layout Standard
This concludes the construction.
 A tedious model-theoretic argument (which,
 of course,
 requires one to have done the details) will show that these formulas satisfy all the conditions of the QETP,
 and thus 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"

\end_inset

 applies,
 whence we obtain a computable copy of the structure 
\begin_inset Formula $(T,S,R_{0})$
\end_inset

.
 In lieu of the details,
 we provide an explanation for why we might expect these conditions to hold.
\end_layout

\begin_layout Standard
Properties 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:qetp0"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:qetp1"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:qetpetau"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 all hold by deliberate construction.
 Property 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:qetp2"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 requires,
 in this context,
 that if 
\begin_inset Formula $\vec{x}$
\end_inset

 satisfies 
\begin_inset Formula $\chi_{q}(\vec{x})$
\end_inset

 then there exists 
\begin_inset Formula $y$
\end_inset

 such that 
\begin_inset Formula $\tau_{q\top}(\vec{x},y)$
\end_inset

,
 and indeed our 
\begin_inset Formula $\tau$
\end_inset

 only makes 
\begin_inset Quotes eld
\end_inset

generic
\begin_inset Quotes erd
\end_inset

 demands,
 such as 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $y$
\end_inset

 is not a leaf
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $y$
\end_inset

 has no common ancestor with 
\begin_inset Formula $\vec{x}$
\end_inset

 except for the root
\begin_inset Quotes erd
\end_inset

,
 which can always be satisfied by infinitely many elements.
 Finally,
 Property 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:qetp3"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 is saying,
 in words:
 Given 
\begin_inset Formula $\vec{x}$
\end_inset

,
 if there is some 
\begin_inset Formula $y$
\end_inset

 that satisfies 
\begin_inset Formula $\chi_{Q}(\vec{x},y)\land\tau_{q\top}(\vec{x},y)$
\end_inset

,
 then any 
\begin_inset Formula $y$
\end_inset

 that satisfies 
\begin_inset Formula $\tau_{q\top}(\vec{x},y)$
\end_inset

 will do so.
 This holds,
 because the only thing that might distinguish any two such 
\begin_inset Formula $y$
\end_inset

 is the pattern of leaves succeeding them (e.g.
\begin_inset space \space{}
\end_inset

perhaps one such 
\begin_inset Formula $y$
\end_inset

 has two leaves as a successor,
 while another 
\begin_inset Formula $y$
\end_inset

 has infinitely many),
 but 
\begin_inset Formula $\chi_{Q}(\vec{x},y)$
\end_inset

 cannot demand anything on the number of leaves succeeding 
\begin_inset Formula $y$
\end_inset

 (or leaves succeeding nodes of 
\begin_inset Formula $y$
\end_inset

,
 etc.) – although it 
\emph on
can 
\emph default
demand that 
\begin_inset Formula $y$
\end_inset

 is not a leaf,
 which is why we added 
\begin_inset Formula $\neg\leaf(y)$
\end_inset

 to the definition of 
\begin_inset Formula $\tau$
\end_inset

 – and thus any two 
\begin_inset Formula $y$
\end_inset

 that satisfy 
\begin_inset Formula $\tau_{q\top}(\vec{x},y)$
\end_inset

 will be indistinguishable from the perspective of 
\begin_inset Formula $\chi_{Q}(\vec{x},y)$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Remark
We would like to highlight two points about 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
 First,
 we note that it reverses the usual way in which jump inversion constructions go:
 Generally,
 one starts with the 
\begin_inset Formula $0'$
\end_inset

-computable structure,
 builds a computable structure out of it,
 and proves that this computable structure is isomorphic to the original.
 On the other hand,
 applications of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 start by constructing a 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed structure out of it,
 proving that this structure is isomorphic to the original,
 and only afterwards constructing the computable copy.
\end_layout

\begin_layout Remark
Another interesting thing about 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 is that,
 in all applications we've found,
 it can be used to black-box all mentions of injury from a proof.
 This does not necessarily make the proof 
\emph on
easier
\emph default
;
 the verifications necessary to apply 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 are often more burdensome,
 if not necessarily more difficult,
 than a standard injury proof would be.
 Regardless,
 we believe that 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 encapsulates a common theme among many different finite injury proofs of jump inversion theorems.
\end_layout

\begin_layout Section
A General Jump Inversion Theorem
\end_layout

\begin_layout Standard
As explained in the introduction,
 there are two main concepts that need to be introduced before we may state and prove the main theorem of this paper,
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
 We will now dedicate some time to defining,
 motivating,
 and explaining these concepts.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:cetypedstructures"

\end_inset

C.e.-typed Structures
\end_layout

\begin_layout Standard
In computable structure theory,
 the most standard notion of what is meant by a computable structure over the finite/computable signature 
\begin_inset Formula $\Lang$
\end_inset

 is:
 A computable set 
\begin_inset Formula $A$
\end_inset

,
 with an interpretation for the symbols from 
\begin_inset Formula $\Lang$
\end_inset

,
 such that the atomic diagram 
\begin_inset Formula $D(A)=\{$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\nospellcheck off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
quantifier-free formulas with parameters from 
\begin_inset Formula $A$
\end_inset

 that hold true in 
\begin_inset Formula $A$
\end_inset


\begin_inset Formula $\}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\nospellcheck default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 is computable.
 This admits an obvious relativization to an arbitrary oracle 
\begin_inset Formula $X$
\end_inset

,
 which induces the standard meaning of 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $X$
\end_inset

-computable structure
\begin_inset Quotes erd
\end_inset

.
 However,
 we've found this notion to be poorly-behaved in some respects,
 especially when it comes to the interplay between infinite signatures (or function symbols) and limit-computability.
\end_layout

\begin_layout Standard
To be more precise,
 let us consider the case where the signature 
\begin_inset Formula $\Lang$
\end_inset

 is finite and relational,
 let 
\begin_inset Formula $A$
\end_inset

 be a 
\begin_inset Formula $0'$
\end_inset

-computable structure.
 Then,
 given a tuple of elements 
\begin_inset Formula $\vec{a}$
\end_inset

 from 
\begin_inset Formula $A$
\end_inset

,
 we have,
 at each instant in time,
 a guess for what the quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

-type of 
\begin_inset Formula $\vec{a}$
\end_inset

 is,
 and this guess will change a finite number of times,
 because the guess for each individual relation (of which there are finitely many) will change a finite number of times.
 However,
 if the signature 
\begin_inset Formula $\Lang$
\end_inset

 is finite,
 the matter becomes more difficult:
 We can no longer be sure that,
 eventually,
 we'll have the right guess for the type of 
\begin_inset Formula $\vec{a}$
\end_inset

,
 only that 
\emph on
for any particular predicate
\emph default
,
 eventually our guess for that predicate will be correct.
 This can pose an issue when trying to perform a finite-injury construction:
 Suppose,
 for example,
 that we wish to perform task 
\begin_inset Formula $A$
\end_inset

 if some element 
\begin_inset Formula $x$
\end_inset

 satisfies one of countably many predicates 
\begin_inset Formula $P_{0}(x)$
\end_inset

,
 
\begin_inset Formula $P_{1}(x)$
\end_inset

,
 etc.,
 and we wish to perform task 
\begin_inset Formula $B$
\end_inset

 instead if it does not.
 Then,
 in a finite injury construction we would perform task 
\begin_inset Formula $B$
\end_inset

 until (unless) we saw 
\begin_inset Formula $x$
\end_inset

 satisfies one of the predicates 
\begin_inset Formula $P_{i}$
\end_inset

,
 in which case we would undo task 
\begin_inset Formula $B$
\end_inset

 and perform task 
\begin_inset Formula $A$
\end_inset

 instead.
 However,
 if all we have are 
\emph on
guesses
\emph default
 for 
\begin_inset Formula $P_{i}$
\end_inset

,
 we can no longer guarantee finite injury:
 It could happen that 
\begin_inset Formula $x$
\end_inset

 satisfies none of the 
\begin_inset Formula $P_{i}$
\end_inset

,
 but that at arbitrarily large times our guess for some 
\begin_inset Formula $P_{N}$
\end_inset

 is that 
\begin_inset Formula $P_{N}(x)$
\end_inset

 holds.
 We could only guarantee finite injury if there was a time past which our guesses for 
\emph on
all
\emph default
 the 
\begin_inset Formula $P_{i}$
\end_inset

 remain the same.
 This,
 we claim,
 makes 
\begin_inset Formula $0'$
\end_inset

-computable structures over infinite signatures poorly-behaved,
 and motivates the definition of what we might call 
\emph on

\begin_inset Formula $0'$
\end_inset

-computable computably typed structure
\emph default
,
 as one for which there is a 
\begin_inset Formula $0'$
\end_inset

-computable function which,
 given a tuple of elements,
 outputs a 
\emph on
computable index
\emph default
 for their quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

-type.
\end_layout

\begin_layout Standard
This already motivates us half-way to the main definition of this section,
 but we generalize a bit further.
 There are some scenarios in which demanding a computable index is far too much:
 Either because the types of the elements of a structure may be too computably complex to represent as a computable index (see e.g.
\begin_inset space \space{}
\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:khisamiev"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 which regards abelian groups with divisibility predicates – even in a computable group,
 the set of integers that divide a given element may be complex enough to encode 
\begin_inset Formula $0'$
\end_inset

),
 or even if the types are themselves simple,
 
\begin_inset Formula $0'$
\end_inset

 may be unable to determine a computable type in finite time (see e.g.
\begin_inset space \space{}
\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:JIlinear-1"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 which regards linear orders with 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $n$
\end_inset

-th successor of
\begin_inset Quotes erd
\end_inset

 predicates – if 
\begin_inset Formula $0'$
\end_inset

 could compute a computable index for the set of 
\begin_inset Formula $n$
\end_inset

 such that 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 are 
\begin_inset Formula $n$
\end_inset

-th successors,
 then it could also determine whether 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 are a finite distance apart (this is called the block relation),
 but one can show that 
\begin_inset Formula $0''$
\end_inset

 could be encoded into the block relation of a linear order,
 so 
\begin_inset Formula $0'$
\end_inset

 must be unable to compute it in general).
 However,
 we've found in both of these cases that a c.e.
\begin_inset space \space{}
\end_inset

index provides a workable middle ground,
 both in the sense that it's a reasonable demand to make of our structures,
 and in the sense that it's sufficient to prove results of interest.
\end_layout

\begin_layout Standard
Of course,
 the c.e.
\begin_inset space \space{}
\end_inset

index for the quantifier-free type of a tuple yields exactly the same information as a computable index – simply wait until either 
\begin_inset Formula $\varphi(\vec{x})$
\end_inset

 or 
\begin_inset Formula $\neg\varphi(\vec{x})$
\end_inset

 is enumerated into the type to determine which holds.
 Thus,
 in order to make any gain from demanding c.e.
\begin_inset space \space{}
\end_inset

instead of computable,
 we need to take care around negations.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "def:cetypedpresentation"

\end_inset

Let 
\begin_inset Formula $\Lang'$
\end_inset

 be a computable relational signature.
\begin_inset FormulaMacro
\renewcommand{\tp}{\mathrm{tp}}
\end_inset

 A
\emph on
 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed structure
\emph default
 
\begin_inset Formula $D$
\end_inset

 consists of a 
\begin_inset Formula $0'$
\end_inset

-computable function 
\begin_inset Formula $t$
\end_inset

,
 whose domain is the finite power-set of an initial segment of 
\begin_inset Formula $\N$
\end_inset

 (this initial segment we call the 
\emph on
domain
\emph default
 of 
\begin_inset Formula $D$
\end_inset

),
 which takes as input the strong index of a finite set of natural numbers 
\begin_inset Formula $\vec{n}=\{n_{0}<n_{1}<\dots<n_{k-1}\}$
\end_inset

 and outputs the c.e.
\begin_inset space \space{}
\end_inset

index 
\begin_inset Formula $t(\vec{n})$
\end_inset

 for an atomic
\begin_inset Foot
status open

\begin_layout Plain Layout
See Definitions 
\begin_inset CommandInset ref
LatexCommand ref
reference "def:atomicformula"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "def:atomictype"

\end_inset

 in the introduction for the distinction between atomic type and quantifier-free type,
 which is important in this context.
\end_layout

\end_inset

 
\begin_inset Formula $\Lang'$
\end_inset

-type 
\begin_inset Formula $\tp(\vec{n})$
\end_inset

 in the variables 
\begin_inset Formula $(x_{n_{0}},\dots,x_{n_{k-1}})$
\end_inset

,
 with the compatibility condition that if 
\begin_inset Formula $\vec{n}\subseteq\vec{m}$
\end_inset

 then 
\begin_inset Formula $\tp(\vec{n})\subseteq\tp(\vec{m})$
\end_inset

.
\end_layout

\begin_layout Remark
As a trivial but noteworthy edge case in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "def:cetypedpresentation"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 by considering the empty set,
 we also have access to a c.e.
\begin_inset space \space{}
\end_inset

index for the atomic 
\begin_inset Formula $\Lang'$
\end_inset

-type of the empty tuple,
 which corresponds to an enumeration of the true zero-ary 
\begin_inset Formula $\Lang'$
\end_inset

-predicates in 
\begin_inset Formula $D$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
\begin_inset CommandInset ref
LatexCommand formatted
reference "def:cetypedpresentation"

\end_inset

 is not symmetric with regard to negation of predicates.
 It can make a stark difference whether our language includes,
 for every predicate 
\begin_inset Formula $P$
\end_inset

,
 its negation 
\begin_inset Formula $\neg P$
\end_inset

 or not.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:qetp"

\end_inset

The QETP
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "def:comp_inf_lang"

\end_inset

We shall work in the Computable Infinitary Language,
 as described in 
\begin_inset CommandInset citation
LatexCommand cite
key "montalban_cst2"
posttextlist "montalban_cst2 Chapter III"
literal "false"

\end_inset

.
 We will only work with a very small fragment of this language,
 which we now describe.
\end_layout

\begin_layout Definition
Given a relational signature 
\begin_inset Formula $\Lang'$
\end_inset

,
 we define the set of 
\emph on
positive finitary conjunctive formulas
\emph default
 as the set of formulas of the type 
\begin_inset Formula $\varphi(\vec{x})\equiv P_{1}\land\dots\land P_{n}$
\end_inset

,
 where each 
\begin_inset Formula $P_{j}$
\end_inset

 denotes a relation in 
\begin_inset Formula $\Lang'$
\end_inset

 being applied to a tuple of variables from 
\begin_inset Formula $\vec{x}$
\end_inset

,
 in any order,
 with the possibility of repeated or omitted variables.
 We also allow for 
\begin_inset Formula $P_{j}$
\end_inset

 to denote 
\begin_inset Formula $\top$
\end_inset

,
 the 
\begin_inset Quotes eld
\end_inset

true
\begin_inset Quotes erd
\end_inset

 predicate,
 and 
\begin_inset Formula $\bot$
\end_inset

,
 the 
\begin_inset Quotes eld
\end_inset

false
\begin_inset Quotes erd
\end_inset

 predicate.
\end_layout

\begin_layout Definition
We define the set of
\emph on
 positive computable quantifier-free disjunctive formulas
\emph default
,
 denoted by 
\begin_inset Formula $\llorc$
\end_inset

,
 as the set of formulas in finitely many variables of the type
\begin_inset Formula 
\[
\varphi(\vec{x})\equiv\llor_{i<\omega}\varphi_{i}(\vec{x}),
\]

\end_inset

where 
\begin_inset Formula $\{\varphi_{i}\}_{i<\omega}$
\end_inset

 is a computable sequence of positive finitary conjunctive formulas.
\end_layout

\begin_layout Definition
Finally,
 we define a third set of formulas,
 denoted by 
\begin_inset Formula $\llorc_{2}$
\end_inset

,
 as those formulas in finitely many variables of the type
\begin_inset Formula 
\[
\varphi(\vec{x})\equiv\llor_{i<\omega}\left(\psi_{i}(\vec{x})\land\neg\varphi_{i}(\vec{x})\right),
\]

\end_inset

where 
\begin_inset Formula $\{\psi_{i}\}_{i<\omega}$
\end_inset

 and 
\begin_inset Formula $\{\varphi_{i}\}_{i<\omega}$
\end_inset

 are a computable sequences of 
\begin_inset Formula $\llorc$
\end_inset

 formulas.
\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rmk:llorc"

\end_inset

The main properties of the 
\begin_inset Formula $\llorc$
\end_inset

 formulas are the following:
\end_layout

\begin_deeper
\begin_layout Itemize
There is a canonical way to associate indices to 
\begin_inset Formula $\llorc$
\end_inset

 formulas,
 so that a computer program may manipulate them,
 and
\end_layout

\begin_layout Itemize
Given a c.e.
\begin_inset space \space{}
\end_inset

index for the atomic 
\begin_inset Formula $\Lang'$
\end_inset

-type of a tuple of elements 
\begin_inset Formula $\vec{b}$
\end_inset

 in some structure,
 and a 
\begin_inset Formula $\llorc$
\end_inset

 formula 
\begin_inset Formula $\varphi(\vec{x})$
\end_inset

 satisfied by 
\begin_inset Formula $\vec{b}$
\end_inset

,
 we can computably confirm in finite time that the tuple 
\begin_inset Formula $\vec{b}$
\end_inset

 satisfies the formula 
\begin_inset Formula $\varphi$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rmk:llorc2"

\end_inset

The main properties of the 
\begin_inset Formula $\llorc_{2}$
\end_inset

 formulas are the following:
\end_layout

\begin_deeper
\begin_layout Itemize
There is a canonical way to associate indices to 
\begin_inset Formula $\llorc_{2}$
\end_inset

 formulas,
\end_layout

\begin_layout Itemize
There is a canonical way to turn the index for a 
\begin_inset Formula $\llorc$
\end_inset

 formula into the index for a logically equivalent 
\begin_inset Formula $\llorc_{2}$
\end_inset

 formula,
 and
\end_layout

\begin_layout Itemize
Given a tuple of elements of a structure and a c.e.
\begin_inset space \space{}
\end_inset

index for their type,
 it is 
\begin_inset Formula $0'$
\end_inset

-c.e.
\begin_inset space \space{}
\end_inset

to determine whether a 
\begin_inset Formula $\llorc_{2}$
\end_inset

 formula holds of the elements.
\end_layout

\begin_layout Standard
Let us briefly elaborate on that last bullet point.
 If 
\begin_inset Formula $\varphi(\vec{x})\equiv\llor_{i}\left(\psi_{i}(\vec{x})\land\neg\varphi_{i}(\vec{x})\right)$
\end_inset

 is a 
\begin_inset Formula $\llorc_{2}$
\end_inset

 formula,
 and 
\begin_inset Formula $\vec{b}$
\end_inset

 is a tuple of elements of a structure for which we have a c.e.
\begin_inset space \space{}
\end_inset

index for the atomic type of 
\begin_inset Formula $\vec{b}$
\end_inset

,
 we can computably create a sequence of guesses for whether 
\begin_inset Formula $\varphi(\vec{b})$
\end_inset

 holds:
 First,
 continuously guess 
\begin_inset Quotes els
\end_inset

no
\begin_inset Quotes ers
\end_inset

,
 whilst dovetailing over the values of 
\begin_inset Formula $i$
\end_inset

 until we find a value for which 
\begin_inset Formula $\psi_{i}(\vec{b})$
\end_inset

 holds.
 If such a value is found,
 continuously guess 
\begin_inset Quotes els
\end_inset

yes
\begin_inset Quotes ers
\end_inset

 until and unless you discover that 
\begin_inset Formula $\varphi_{i}(\vec{b})$
\end_inset

 holds.
 At that point,
 guess 
\begin_inset Quotes els
\end_inset

no
\begin_inset Quotes ers
\end_inset

 once,
 and go back to finding a (new) value 
\begin_inset Formula $j$
\end_inset

 for which 
\begin_inset Formula $\psi_{j}(\vec{b})$
\end_inset

 holds,
 and so on.
 This sequence of guesses will have the following behavior:
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $\varphi(\vec{b})$
\end_inset

 holds,
 we will guess 
\begin_inset Quotes els
\end_inset

yes
\begin_inset Quotes ers
\end_inset

 all but finitely many times,
 and
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $\varphi(\vec{b})$
\end_inset

 does not hold,
 we will guess 
\begin_inset Quotes els
\end_inset

no
\begin_inset Quotes ers
\end_inset

 infinitely many times.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
Compare the properties in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rmk:llorc"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 to the following properties of a related class of computable infinitary formulas.
 The 
\begin_inset Formula $\Sigma_{1}^{c}$
\end_inset

 formulas are those formulas in the Computable Infinitary Language of the form:
\begin_inset Formula 
\[
\llor_{i<\omega}\exists_{\vec{y}_{i}}\varphi_{i}(\vec{x},\vec{y}_{i}),
\]

\end_inset

where the sequence of formulas 
\begin_inset Formula $\{\exists_{\vec{y}_{i}}\varphi_{i}(\vec{x},\vec{y})\}_{i\in\N}$
\end_inset

 is computable,
 and each 
\begin_inset Formula $\varphi_{i}$
\end_inset

 is a finite Boolean combination of predicates applied to variables in the tuple 
\begin_inset Formula $(\vec{x},\vec{y})$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Itemize
The 
\begin_inset Formula $\Sigma_{1}^{c}$
\end_inset

 formulas also admit a canonical way to associate indices,
 and
\end_layout

\begin_layout Itemize
Given a tuple 
\begin_inset Formula $\vec{b}$
\end_inset

 of elements in a computable structure 
\begin_inset Formula $D$
\end_inset

 that satisfy the 
\begin_inset Formula $\Sigma_{1}^{c}$
\end_inset

 formula 
\begin_inset Formula $\varphi(\vec{x})$
\end_inset

,
 we can confirm in finite time that the tuple 
\begin_inset Formula $\vec{b}$
\end_inset

 satisfies the formula 
\begin_inset Formula $\varphi$
\end_inset

.
\end_layout

\begin_layout Standard
Despite the similarities,
 the 
\begin_inset Formula $\llorc$
\end_inset

 formulas shall be more useful in our treatment,
 because to check the truth of a 
\begin_inset Formula $\Sigma_{1}^{c}$
\end_inset

 formula,
 we need access to the entire model (so that we may brute-force the tuples 
\begin_inset Formula $\vec{y}_{i}$
\end_inset

),
 whilst we shall be working with 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed structures,
 which may contain 
\begin_inset Quotes eld
\end_inset

phantom elements
\begin_inset Quotes erd
\end_inset

 that could otherwise lead to false positives.
 Moreover,
 since we only have a c.e.
\begin_inset space \space{}
\end_inset

index for the positive information about elements,
 we cannot computably check arbitrary finite Boolean combinations of predicates – hence why we restrict to positive formulas.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
In the sequence,
 we shall have two nested signatures,
 
\begin_inset Formula $\Lang\subseteq\Lang'$
\end_inset

.
 We shall follow the following conventions:
\end_layout

\begin_deeper
\begin_layout Itemize
Unless indicated otherwise,
 all formulas are assumed to be quantifier-free,
\end_layout

\begin_layout Itemize
All named 
\begin_inset Formula $\Lang$
\end_inset

-formulas will be quantifier-free finitary first-order formulas,
 and will be denoted by lower-case Roman letters,
\end_layout

\begin_layout Itemize
All named 
\begin_inset Formula $\Lang'$
\end_inset

-formulas will be 
\begin_inset Formula $\llorc$
\end_inset

 and will be denoted by lower-case Greek letters,
 except for the formulas named 
\begin_inset Formula $\tau$
\end_inset

,
 which will be 
\begin_inset Formula $\llorc_{2}$
\end_inset

.
 Conversely,
 all 
\begin_inset Formula $\llorc$
\end_inset

 or 
\begin_inset Formula $\llorc_{2}$
\end_inset

 formulas in the sequence are assumed to be over the signature 
\begin_inset Formula $\Lang'$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
We now present the main definition of this section.
 It is a rather technical definition.
 We recall that we provided some motivation for this definition in the introduction;
 see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rmk:qetpmotivation"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
\begin_inset Argument 1
status open

\begin_layout Plain Layout
QETP
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "def:qetp"

\end_inset

Let 
\begin_inset Formula $\Lang\subseteq\Lang'$
\end_inset

 be computable signatures,
 and let 
\begin_inset Formula $D$
\end_inset

 be a structure over 
\begin_inset Formula $\Lang'$
\end_inset

.
 We say that 
\begin_inset Formula $D$
\end_inset

 satisfies the 
\emph on
Computable Positive Quantifier Elimination and Trash Existence Property
\emph default
,
 abbreviated to 
\emph on
QETP,

\emph default
 if the following properties hold:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

label=(
\backslash
alph*)
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "enu:qetp0"

\end_inset


\begin_inset Formula $\Lang$
\end_inset

 is finite,
 closed under negation,
 and includes the predicate 
\begin_inset Formula $\neq$
\end_inset

,
\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:qetp1"

\end_inset

For every quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

-formula 
\begin_inset Formula $q(\vec{x},\vec{y})$
\end_inset

,
 there is a 
\begin_inset Formula $\llorc$
\end_inset


\emph on
 
\emph default

\begin_inset Formula $\Lang'$
\end_inset

-formula 
\begin_inset Formula $\chi_{q}(\vec{x})$
\end_inset

,
 computable from 
\begin_inset Formula $q$
\end_inset

,
 such that
\begin_inset Formula 
\[
D\vDash\forall_{\vec{x}}\left[\chi_{q}(\vec{x})\leftrightarrow\exists_{\vec{y}}q(\vec{x},\vec{y})\right],
\]

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:qetp2"

\end_inset

There is a 
\begin_inset Formula $0'$
\end_inset

-computable 
\emph on
partial
\emph default
 function denoted 
\begin_inset Formula $\tau$
\end_inset

,
 which takes as input a pair 
\begin_inset Formula $(q(\vec{x},y,\vec{z}),\varphi(\vec{x}))$
\end_inset

,
 where 
\begin_inset Formula $q(\vec{x},y,\vec{z})$
\end_inset

 is a quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

-type
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Note the lack of 
\begin_inset Quotes eld
\end_inset

vector arrow
\begin_inset Quotes erd
\end_inset

 on the variable 
\begin_inset Formula $y$
\end_inset

.
 This denotes a 
\emph on
single
\emph default
 variable,
 not a tuple of them.
\end_layout

\end_inset

 and 
\begin_inset Formula $\varphi(\vec{x})$
\end_inset

 is a 
\emph on
finitary
\emph default
 
\begin_inset Formula $\Lang'$
\end_inset

-formula,
 whose output is a 
\begin_inset Formula $\llorc_{2}$
\end_inset

 
\begin_inset Formula $\Lang'$
\end_inset

-formula denoted 
\begin_inset Formula $\tau_{q\varphi}(\vec{x},y)$
\end_inset

 that satisfies the following two properties:
\end_layout

\begin_deeper
\begin_layout Itemize
For every tuple 
\begin_inset Formula $(\vec{x},y,\vec{z})$
\end_inset

 of elements in 
\begin_inset Formula $D$
\end_inset

,
 of 
\begin_inset Formula $\Lang$
\end_inset

-type 
\begin_inset Formula $q(\vec{x},y,\vec{z})$
\end_inset

,
 there is a formula 
\begin_inset Formula $\varphi(\vec{x})$
\end_inset

 satisfied by 
\begin_inset Formula $\vec{x}$
\end_inset

 such that 
\begin_inset Formula $(q,\varphi)$
\end_inset

 is in the domain of 
\begin_inset Formula $\tau$
\end_inset

.
 Equivalently,
 if 
\begin_inset Formula $\vec{b}$
\end_inset

 is a tuple of elements in 
\begin_inset Formula $D$
\end_inset

 such that 
\begin_inset Formula $D\vDash\chi_{q}(\vec{b})$
\end_inset

,
 there is 
\begin_inset Formula $\varphi(\vec{x})$
\end_inset

 such that 
\begin_inset Formula $(q,\varphi)$
\end_inset

 is in the domain of 
\begin_inset Formula $\tau$
\end_inset

 and 
\begin_inset Formula $D\vDash\varphi(\vec{b})$
\end_inset

.
 Moreover,
\end_layout

\begin_layout Itemize
The following formula holds in 
\begin_inset Formula $D$
\end_inset

:
\begin_inset Formula 
\[
D\vDash\forall_{\vec{x}}\left[\chi_{q}(\vec{x})\land\varphi(\vec{x})\rightarrow\exists_{y}\tau_{q\varphi}(\vec{x},y)\right].
\]

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
denis idea:
 assume that tau only hits the true tau i.o.
 instead of a.e.
 and try to get a 
\begin_inset Formula $0''$
\end_inset

 isomorphism
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:qetpetau"

\end_inset

Given a pair 
\begin_inset Formula $(q(\vec{x},y,\vec{z}),\varphi(\vec{x}))$
\end_inset

 in the domain of 
\begin_inset Formula $\tau$
\end_inset

 as above,
 together with a quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

-type 
\begin_inset Formula $Q(\vec{x},y,\vec{z},\vec{w})$
\end_inset

 extending 
\begin_inset Formula $q(\vec{x},y,\vec{z})$
\end_inset

,
 there is a 
\begin_inset Formula $\llorc$
\end_inset

 
\begin_inset Formula $\Lang'$
\end_inset

-formula 
\begin_inset Formula $\etau_{q\varphi Q}(\vec{x})$
\end_inset

,
 computable from the triple 
\begin_inset Formula $(q,\varphi,Q)$
\end_inset

,
 such that
\begin_inset Formula 
\[
D\vDash\forall_{\vec{x}}\left[\exists_{y}\left[\chi_{Q}(\vec{x},y)\land\tau_{q\varphi}(\vec{x},y)\right]\leftrightarrow\etau_{q\varphi Q}(\vec{x})\right].
\]

\end_inset

The function 
\begin_inset Formula $(q,\varphi,Q)\mapsto\etau_{q\varphi Q}$
\end_inset

 may be defined in some cases even if the pair 
\begin_inset Formula $(q,\varphi)$
\end_inset

 is not in the domain of 
\begin_inset Formula $\tau$
\end_inset

.
 In this scenario,
 we do not make any requirement of 
\begin_inset Formula $\etau_{q\varphi Q}$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
Note:
 As a corollary of 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:qetp2"

\end_inset

,
 we obtain 
\begin_inset Formula $D\vDash\forall_{\vec{x}}\left[\chi_{q}(\vec{x})\land\varphi(\vec{x})\rightarrow\etau_{q\varphi q}(\vec{x})\right]$
\end_inset

 for 
\begin_inset Formula $(q,\varphi)$
\end_inset

 in the domain of 
\begin_inset Formula $\tau$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:qetp3"

\end_inset

Finally,
 for all 
\begin_inset Formula $q$
\end_inset

,
 
\begin_inset Formula $\varphi$
\end_inset

,
 
\begin_inset Formula $Q$
\end_inset

,
 we require 
\begin_inset Formula 
\[
D\vDash\forall_{\vec{x},y}\left[\etau_{q\varphi Q}(\vec{x})\land\tau_{q\varphi}(\vec{x},y)\rightarrow\chi_{Q}(\vec{x},y)\right].
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\end_deeper
\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rmk:tauwork"

\end_inset

We will work with Item 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:qetp2"

\end_inset

 of the QETP in the following manner:
 We envision a computable process that enumerates triplets 
\begin_inset Formula $(q,\varphi,\tau)$
\end_inset

,
 and sometimes deletes them,
 in such a manner that,
 if 
\begin_inset Formula $\tau_{q\varphi}$
\end_inset

 is well-defined,
 the triple 
\begin_inset Formula $(q,\varphi,\tau_{q\varphi})$
\end_inset

 will eventually be enumerated and never removed,
 and every triplet that is not of the form 
\begin_inset Formula $(q,\varphi,\tau_{q\varphi})$
\end_inset

 for 
\begin_inset Formula $(q,\varphi)$
\end_inset

 in the domain of 
\begin_inset Formula $\tau$
\end_inset

 will eventually be removed.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
As a consequence of Item 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:qetp1"

\end_inset

 of Definition 
\begin_inset CommandInset ref
LatexCommand ref
reference "def:qetp"

\end_inset

,
 if 
\begin_inset Formula $D$
\end_inset

 is a 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed structure satisfying the QETP,
 we can enumerate the quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

-types that are realized in 
\begin_inset Formula $D$
\end_inset

.
 This is because,
 to tell if a type 
\begin_inset Formula $q(\vec{y})$
\end_inset

 is realized in 
\begin_inset Formula $D$
\end_inset

,
 we inspect the truth value of the zero-ary positive sentence 
\begin_inset Formula $\chi_{q}$
\end_inset

,
 which will consist of a positive combination of zero-ary predicates of 
\begin_inset Formula $D$
\end_inset

.
 By inspecting the type of the zero-ary tuple of elements of 
\begin_inset Formula $D$
\end_inset

 we can therefore enumerate the types 
\begin_inset Formula $q(\vec{y})$
\end_inset

 that are realized.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\end_deeper
\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rmk:weakerchi"

\end_inset

We make an additional technical assumption on the formulas 
\begin_inset Formula $\chi_{q}$
\end_inset

,
 albeit with no loss of generality.
 Let 
\begin_inset Formula $q(\vec{x},\vec{y},\vec{z})$
\end_inset

 be a quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

 formula.
 We can assign a 
\begin_inset Formula $\chi$
\end_inset

-formula to 
\begin_inset Formula $q$
\end_inset

 in (at least) two different ways:
 By grouping the variables as 
\begin_inset Formula $(\vec{x},[\vec{y},\vec{z}])$
\end_inset

,
 or by grouping them as 
\begin_inset Formula $([\vec{x},\vec{y}],\vec{z})$
\end_inset

.
 This leads to two different formulas,
 which,
 when necessary to distinguish,
 we notate respectively as 
\begin_inset Formula $\chi_{q(\vec{x},\cdot,\cdot)}(\vec{x})$
\end_inset

 and 
\begin_inset Formula $\chi_{q(\vec{x},\vec{y},\cdot)}(\vec{x},\vec{y})$
\end_inset

.
 Now,
 
\series bold
we assume without loss of generality
\series default
 that,
 in such a scenario,
 
\begin_inset Formula $\chi_{q(\vec{x},\vec{y},\cdot)}(\vec{x},\vec{y})$
\end_inset

 contains 
\begin_inset Formula $\chi_{q(\vec{x},\cdot,\cdot)}(\vec{x})$
\end_inset

 as a subformula.
\end_layout

\begin_layout Remark
The reason why we can make such an assumption is that,
 given a quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

-formula 
\begin_inset Formula $q(\vec{x},\vec{y})$
\end_inset

,
 we may redefine 
\begin_inset Formula $\bar{\chi}_{q}(\vec{x})$
\end_inset

 as
\begin_inset Formula 
\[
\bar{\chi}_{q}(\vec{x})=\bigwedge_{\vec{x}=(\vec{x}_{1},\vec{x}_{2})}\chi_{q(\vec{x}_{1},\cdot,\cdot)}(\vec{x}_{1}),
\]

\end_inset

where the conjunction ranges over all decompositions of the tuple 
\begin_inset Formula $\vec{x}$
\end_inset

 into two tuples of variables (not necessarily in order).
 Implicitly,
 we use the fact that finite conjunctions of 
\begin_inset Formula $\llorc$
\end_inset

 formulas are themselves 
\begin_inset Formula $\llorc$
\end_inset

.
 This new definition of 
\begin_inset Formula $\bar{\chi}$
\end_inset

 still serves as a witness to the QETP,
 if the previous 
\begin_inset Formula $\chi$
\end_inset

 did,
 but has this additional technical benefit that will be necessary in our proof.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rmk:assumeq"

\end_inset

When verifying the QETP for a specific structure,
 we must construct a formula 
\begin_inset Formula $\chi_{q}(\vec{x})$
\end_inset

 for any quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

-formula 
\begin_inset Formula $q(\vec{x},\vec{y})$
\end_inset

.
 This can be quite burdensome.
 Thus,
 we present a simplification step,
 common in quantifier-elimination proofs,
 which we will henceforth use without comment:
 When constructing 
\begin_inset Formula $\chi_{q}$
\end_inset

 we may assume,
 without loss of generality,
 that 
\begin_inset Formula $q(\vec{x},\vec{y})$
\end_inset

 is a quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

-type all of whose elements are distinct.
 This is because any formula 
\begin_inset Formula $q(\vec{x},\vec{y})$
\end_inset

 can be written as a disjunction 
\begin_inset Formula $\lor_{i}\left(q(\vec{x},\vec{y})\land t_{i}(\vec{x},\vec{y})\right)$
\end_inset

,
 where 
\begin_inset Formula $t_{i}$
\end_inset

 varies over the quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

-types,
 each 
\begin_inset Formula $q(\vec{x},\vec{y})\land t_{i}(\vec{x},\vec{y})$
\end_inset

 is logically equivalent to either 
\begin_inset Formula $\bot$
\end_inset

 or to 
\begin_inset Formula $t_{i}(\vec{x},\vec{y})$
\end_inset

 (call the result 
\begin_inset Formula $q_{i}(\vec{x},\vec{y})$
\end_inset

),
 and moreover 
\begin_inset Formula $\exists_{\vec{y}}\lor_{i}q_{i}(\vec{x},\vec{y})$
\end_inset

 is logically equivalent to 
\begin_inset Formula $\lor_{i}\exists_{\vec{y}}q_{i}(\vec{x},\vec{y})$
\end_inset

,
 so it suffices to define 
\begin_inset Formula $\chi$
\end_inset

 on each 
\begin_inset Formula $q_{i}$
\end_inset

.
 Moreover,
 we may assume that all variables are distinct,
 because if 
\begin_inset Formula $q_{i}$
\end_inset

 contains 
\begin_inset Formula $y_{a}=y_{b}$
\end_inset

 or 
\begin_inset Formula $y_{a}=x_{b}$
\end_inset

 we can simply perform the substitution and erase the quantification in 
\begin_inset Formula $y_{a}$
\end_inset

,
 and if 
\begin_inset Formula $q_{i}$
\end_inset

 contains 
\begin_inset Formula $x_{a}=x_{b}$
\end_inset

,
 we can get rid of one of these two variables by using the fact that 
\begin_inset Formula $\exists_{\vec{y}}q_{i}(\vec{x},\vec{y})$
\end_inset

 is logically equivalent (in this case) to 
\begin_inset Formula $x_{a}=x_{b}\land\exists_{\vec{y}}\hat{q}_{i}(\vec{x}_{\hat{a}},\vec{y})$
\end_inset

,
 where 
\begin_inset Formula $\hat{q}_{i}$
\end_inset

 consists of the reduct of 
\begin_inset Formula $q_{i}$
\end_inset

 to the tuple of variables from which we removed 
\begin_inset Formula $x_{a}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
In truth,
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rmk:assumeq"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 is actually completely unnecessary:
 By inspection of the proof of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 one will find that indeed 
\begin_inset Formula $\chi_{q}$
\end_inset

 is only ever calculated when 
\begin_inset Formula $q$
\end_inset

 is a quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

-type of distinct elements.
 Nevertheless,
 we preferred to phrase the QETP as it is,
 even if it is stronger than necessary in appearance (though not in fact),
 to emphasize the fact that the 
\begin_inset Formula $\chi$
\end_inset

 part of the definition is no more than an effective quantifier-elimination result.
\end_layout

\begin_layout Subsection
Main Result
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:main_final"

\end_inset

If 
\begin_inset Formula $D$
\end_inset

 is a 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed structure over the signature 
\begin_inset Formula $\Lang'\supseteq\Lang$
\end_inset

 satisfying the QETP,
 then the reduct 
\begin_inset Formula $D\upto\Lang$
\end_inset

 admits a computable copy 
\begin_inset Formula $M$
\end_inset

.
 There is a 
\begin_inset Formula $0'$
\end_inset

-computable isomorphism between 
\begin_inset Formula $D\upto\Lang$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

.
 This result is uniform in the index for 
\begin_inset Formula $D$
\end_inset

 and an index for witnesses that 
\begin_inset Formula $D$
\end_inset

 satisfies the QETP,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
This includes:
 An index for which predicates in 
\begin_inset Formula $\Lang$
\end_inset

 are the negation of each other,
 an index for the computable functions 
\begin_inset Formula $\chi$
\end_inset

 and 
\begin_inset Formula $\etau$
\end_inset

,
 and an index for the 
\begin_inset Formula $0'$
\end_inset

-computable function 
\begin_inset Formula $\tau$
\end_inset

.
\end_layout

\end_inset

 and relativizes uniformly.
\end_layout

\begin_layout Proof
We shall build a computable copy of 
\begin_inset Formula $D\upto\Lang$
\end_inset

 via a finite injury argument.
 First,
 we lay down the foundation for the functioning of our algorithm:
\end_layout

\begin_deeper
\begin_layout Itemize
We visualize the structure 
\begin_inset Formula $D$
\end_inset

 as being given by a computable process,
 outputting elements and c.e.
\begin_inset space \space{}
\end_inset

indices for the atomic 
\begin_inset Formula $\Lang'$
\end_inset

-type of the elements output thus far,
 and sometimes erasing previously constructed elements.
 We shall be executing this construction in parallel in the background of ours.
\end_layout

\begin_layout Itemize
We shall build the 
\begin_inset Formula $\Lang$
\end_inset

-structure 
\begin_inset Formula $M\cong D\upto\Lang$
\end_inset

 via a computable process that outputs a sequence of elements,
 and with each element,
 the quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

-type of the elements output thus far.
\end_layout

\begin_layout Itemize
We well-order the elements of 
\begin_inset Formula $M$
\end_inset

 and the elements of 
\begin_inset Formula $D$
\end_inset

 by time of addition.
 This includes 
\begin_inset Quotes eld
\end_inset

fake
\begin_inset Quotes erd
\end_inset

 elements of 
\begin_inset Formula $D$
\end_inset

.
 When we refer to 
\begin_inset Quotes eld
\end_inset

the first element of 
\begin_inset Formula $M$
\end_inset

 (or 
\begin_inset Formula $D$
\end_inset

) that satisfies such-and-such property
\begin_inset Quotes erd
\end_inset

,
 we mean the one that was added earliest.
\end_layout

\begin_layout Itemize
We shall imagine an assortment of workers,
 referred to as 
\begin_inset Quotes eld
\end_inset

worker 
\begin_inset Formula $i$
\end_inset


\begin_inset Quotes erd
\end_inset

 for 
\begin_inset Formula $i=0,1,2,\dots$
\end_inset

,
 each of which will be responsible for one step in a back-and-forth construction of an isomorphism between 
\begin_inset Formula $D$
\end_inset

 and the structure 
\begin_inset Formula $M$
\end_inset

 that we are constructing.
\end_layout

\begin_layout Itemize
We assume that only one worker is active at each time.
 When worker 
\begin_inset Formula $i$
\end_inset

 is done with its task,
 it will activate worker 
\begin_inset Formula $i+1$
\end_inset

.
 When an injury occurs (the means by which this may be caused will be discussed later),
 we may divert execution back to a prior worker,
 say worker 
\begin_inset Formula $j$
\end_inset

,
 and delete the state of all workers past worker 
\begin_inset Formula $j$
\end_inset

.
\end_layout

\begin_layout Itemize
The internal state of this construction,
 that is,
 the information we shall be keeping track of,
 consists of the following data (plus whatever ancillary information is necessary to keep track of the worker mechanism):
\end_layout

\begin_deeper
\begin_layout Itemize
The current status of the structures 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $D$
\end_inset

,
\end_layout

\begin_layout Itemize
One-to-one matchings between some elements of 
\begin_inset Formula $M$
\end_inset

 and some elements of 
\begin_inset Formula $D$
\end_inset

,
 the latter of which may or may not be real,
\end_layout

\begin_layout Itemize
To some elements 
\begin_inset Formula $m$
\end_inset

 of 
\begin_inset Formula $M$
\end_inset

,
 we match a triplet of formulas 
\begin_inset Formula $(q(\vec{x},y,\vec{z}),\varphi(\vec{x}),\tau(\vec{x},y))$
\end_inset

 that have been output by the process from 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rmk:tauwork"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 together with a decomposition of the elements of 
\begin_inset Formula $M$
\end_inset

 at the time that this matching was created,
 into 
\begin_inset Formula $\vec{x}$
\end_inset

,
 
\begin_inset Formula $y=m$
\end_inset

,
 and 
\begin_inset Formula $\vec{z}$
\end_inset

.
\end_layout

\begin_layout Itemize
To each matching of the previous two kinds,
 we keep track of which worker created it and when.
\end_layout

\end_deeper
\begin_layout Itemize
The internal state of this construction may be modified via the following operations:
\end_layout

\begin_deeper
\begin_layout Itemize
We may add a new element to 
\begin_inset Formula $M$
\end_inset

,
 in which case we immediately match it to an element of 
\begin_inset Formula $D$
\end_inset

,
\end_layout

\begin_layout Itemize
We may create a matching between an element of 
\begin_inset Formula $M$
\end_inset

 and an element of 
\begin_inset Formula $D$
\end_inset

,
\end_layout

\begin_layout Itemize
We may match a triplet of formulas 
\begin_inset Formula $(q,\varphi,\tau)$
\end_inset

 to an element 
\begin_inset Formula $y\in M$
\end_inset

,
 together with the decomposition 
\begin_inset Formula $M_{\mathrm{current}}=(\vec{x},y,\vec{z})$
\end_inset

,
 where 
\begin_inset Formula $\vec{x}$
\end_inset

 denotes the elements of 
\begin_inset Formula $M$
\end_inset

 that have a match in 
\begin_inset Formula $D$
\end_inset

 at this moment (note that in particular we assume 
\begin_inset Formula $y$
\end_inset

 does not have a match at this moment),
\end_layout

\begin_layout Itemize
In the event of injury,
 we may remove matches of the two kinds above.
\end_layout

\end_deeper
\begin_layout Itemize
The construction will be injured if either of the following three events occur:
\end_layout

\begin_deeper
\begin_layout Itemize
An element of 
\begin_inset Formula $D$
\end_inset

 which admits a match to an element of 
\begin_inset Formula $M$
\end_inset

 is deleted,
\end_layout

\begin_layout Itemize
There is an element of 
\begin_inset Formula $M$
\end_inset

,
 with an assigned triplet of formulas 
\begin_inset Formula $(q,\varphi,\tau)$
\end_inset

,
 for which the triplet of formulas has been deleted from the enumeration of the process of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rmk:tauwork"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
\end_layout

\begin_layout Itemize
There is an element of 
\begin_inset Formula $M$
\end_inset

,
 with an assigned triplet 
\begin_inset Formula $(q,\varphi,\tau)$
\end_inset

 and a matched element 
\begin_inset Formula $d\in D$
\end_inset

,
 such that our guess about whether 
\begin_inset Formula $\tau$
\end_inset

 holds of this element has changed to 
\begin_inset Quotes els
\end_inset

no
\begin_inset Quotes ers
\end_inset

.
\end_layout

\begin_layout Standard
In either of these cases,
 all matches created after the 
\begin_inset Quotes eld
\end_inset

faulty match
\begin_inset Quotes erd
\end_inset

 will be deleted.
\end_layout

\end_deeper
\begin_layout Standard
Now,
 we establish some assumptions about the internal state of the construction,
 which we will be careful to uphold at every step.
 Together with each assumption,
 we point out the operations that we need to be careful in exercising – the remaining operations will always preserve the given assumption.
 Moreover,
 the assumptions will not be broken with the passage of time unless injury happens,
 in which case the injury-handling part of the algorithm will rectify any issues.
\end_layout

\begin_layout Enumerate
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

label={Assumption (
\backslash
Alph*)},
 leftmargin=*
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "enu:asmchi"

\end_inset

If 
\begin_inset Formula $M=(\vec{x},\vec{y})$
\end_inset

,
 where 
\begin_inset Formula $\vec{x}$
\end_inset

 denotes the elements of 
\begin_inset Formula $M$
\end_inset

 that currently admit matches in 
\begin_inset Formula $D$
\end_inset

,
 
\begin_inset Formula $\vec{b}$
\end_inset

 denotes these matches,
 and 
\begin_inset Formula $q(\vec{x},\vec{y})$
\end_inset

 is the type of the elements of 
\begin_inset Formula $M$
\end_inset

,
 we demand that 
\begin_inset Formula $D\vDash\chi_{q}(\vec{b})$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
We need to be careful to ensure that this is true when we add new elements to 
\begin_inset Formula $M$
\end_inset

,
 and when we create matches between elements of 
\begin_inset Formula $M$
\end_inset

 and elements of 
\begin_inset Formula $D$
\end_inset

.
 We would also need to be careful in the event that matches are deleted,
 but this is where 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rmk:weakerchi"

\end_inset

 becomes relevant,
 as it ensures that this is not a concern.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:asmphi"

\end_inset

If 
\begin_inset Formula $y\in M$
\end_inset

 is matched with a triplet of formulas 
\begin_inset Formula $(q,\varphi,\tau)$
\end_inset

 and decomposition 
\begin_inset Formula $(\vec{x},y,\vec{z})\subseteq M$
\end_inset

,
 we demand that 
\begin_inset Formula $M\vDash q(\vec{x},y,\vec{z})$
\end_inset

 and that all elements of 
\begin_inset Formula $\vec{x}$
\end_inset

 admit matches 
\begin_inset Formula $\vec{b}$
\end_inset

 in 
\begin_inset Formula $D$
\end_inset

,
 which satisfy 
\begin_inset Formula $D\vDash\varphi(\vec{b})$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
We need to be careful to ensure that this is true when we assign a triplet to an element.
 We don't need to be careful when removing matches or elements of 
\begin_inset Formula $D$
\end_inset

,
 because our injury process will,
 in that case,
 unmatch the formulas assigned to 
\begin_inset Formula $y$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:asmutau"

\end_inset

At most one unmatched element 
\begin_inset Formula $m$
\end_inset

 of 
\begin_inset Formula $M$
\end_inset

 will have an assigned triplet at any given time,
 and in this event,
 the variables 
\begin_inset Formula $\vec{x}$
\end_inset

 correspond to the elements of 
\begin_inset Formula $M$
\end_inset

 currently matched to elements of 
\begin_inset Formula $D$
\end_inset

,
 and the next action to be taken shall be to match 
\begin_inset Formula $m$
\end_inset

 to an element of 
\begin_inset Formula $D$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:asmtau"

\end_inset

If 
\begin_inset Formula $y$
\end_inset

 is an element of 
\begin_inset Formula $M$
\end_inset

 with assigned triplet 
\begin_inset Formula $(q(\vec{x},y,\vec{z}),\varphi(\vec{x}),\tau(\vec{x},y))$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 admits a match 
\begin_inset Formula $d$
\end_inset

 in 
\begin_inset Formula $D$
\end_inset

,
 if 
\begin_inset Formula $\vec{b}$
\end_inset

 is the tuple of elements matched with 
\begin_inset Formula $\vec{x}$
\end_inset

,
 it must be the case that 
\begin_inset Formula $D\vDash\tau(\vec{b},d)$
\end_inset

 
\emph on
at the current approximation
\emph default
 (in the sense of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rmk:llorc2"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

).
\end_layout

\begin_deeper
\begin_layout Standard
We need to be careful to ensure that this is true when we create a match between an element of 
\begin_inset Formula $M$
\end_inset

 with an assigned triplet 
\begin_inset Formula $(q,\varphi,\tau)$
\end_inset

 and an element of 
\begin_inset Formula $D$
\end_inset

.
 We will not need to be careful when we assign a triplet 
\begin_inset Formula $(q,\varphi,\tau)$
\end_inset

 to an element of 
\begin_inset Formula $M$
\end_inset

,
 because (it turns out) we will always match such triplets to unmatched elements.
 We also need to be careful if the current approximation (in the sense of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rmk:llorc2"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

) ever changes,
 which is why 
\begin_inset Quotes els
\end_inset

the approximation of the value of 
\begin_inset Formula $\tau(\vec{b},d)$
\end_inset

 changes
\begin_inset Quotes ers
\end_inset

 is a cause of injury.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:asmetau"

\end_inset

If 
\begin_inset Formula $m$
\end_inset

 is an element with assigned formulas 
\begin_inset Formula $(q(\vec{x},y,\vec{z}),\varphi(\vec{x}),\tau(\vec{x},y))$
\end_inset

,
 with 
\begin_inset Formula $\vec{b}$
\end_inset

 denoting the matches of the 
\begin_inset Formula $\vec{x}$
\end_inset

,
 and at this stage 
\begin_inset Formula $M$
\end_inset

 is decomposed as 
\begin_inset Formula $M=(\vec{x},y,\vec{z},\vec{w})$
\end_inset

 with quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

-type 
\begin_inset Formula $Q(\vec{x},y,\vec{z},\vec{w})$
\end_inset

,
 it must be the case that,
 if the 
\begin_inset Formula $\vec{b}$
\end_inset

 are real elements of 
\begin_inset Formula $D$
\end_inset

,
 we have 
\begin_inset Formula $D\vDash\etau_{q\varphi Q}(\vec{b})$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
We need to be careful to ensure that this is true when new elements are added to 
\begin_inset Formula $M$
\end_inset

,
 and when we assign triplets 
\begin_inset Formula $(q,\varphi,\tau)$
\end_inset

 to elements of 
\begin_inset Formula $M$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
The process starts with the initialization of worker 
\begin_inset Formula $0$
\end_inset

.
\end_layout

\begin_layout Standard
Now,
 let us describe the algorithm that will be followed by worker 
\begin_inset Formula $i$
\end_inset

.
 Upon initialization:
\end_layout

\begin_layout Itemize
To begin,
 find the first element of 
\begin_inset Formula $M$
\end_inset

,
 if any,
 that does not have a match in 
\begin_inset Formula $D$
\end_inset

.
 If there is none,
 skip to the end of this bullet point.
 If there is one,
 call it 
\begin_inset Formula $m$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
If 
\begin_inset Formula $m$
\end_inset

 does not have an assigned formula:
 Let 
\begin_inset Formula $(\vec{x},y,\vec{z})$
\end_inset

 be the current elements of 
\begin_inset Formula $M$
\end_inset

,
 with 
\begin_inset Formula $\vec{x}$
\end_inset

 corresponding to the elements that currently have a match in 
\begin_inset Formula $D$
\end_inset

 – call them 
\begin_inset Formula $\vec{b}$
\end_inset

 –,
 
\begin_inset Formula $y$
\end_inset

 corresponding to 
\begin_inset Formula $m$
\end_inset

,
 and 
\begin_inset Formula $\vec{z}$
\end_inset

 corresponding to the remaining elements.
 Look through the triplets 
\begin_inset Formula $(q,\varphi,\tau)$
\end_inset

 enumerated as per 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rmk:tauwork"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 until you find such a triplet that satisfies 
\begin_inset Formula $M\vDash q(\vec{x},y,\vec{z})$
\end_inset

 and 
\begin_inset Formula $D\vDash\varphi(\vec{b})$
\end_inset

.
 If all elements of 
\begin_inset Formula $\vec{b}$
\end_inset

 are real,
 such a triple will be found in finite time by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "enu:asmchi"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 in conjunction with Item 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:qetp2"

\end_inset

 of the QETP.
 If not all are real,
 injury will occur.
 Once such a triple is found,
 we assign to 
\begin_inset Formula $m$
\end_inset

 the triplet 
\begin_inset Formula $(q,\varphi,\tau)$
\end_inset

 with the decomposition 
\begin_inset Formula $(\vec{x},y,\vec{z})$
\end_inset

 above.
\end_layout

\begin_layout Standard
We need to make sure that 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:asmphi"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:asmetau"

\end_inset

 are preserved.
\end_layout

\begin_layout Itemize
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:asmphi"

\end_inset

 – By design.
\end_layout

\begin_layout Itemize
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:asmetau"

\end_inset

 – We need to guarantee that,
 if the 
\begin_inset Formula $\vec{b}$
\end_inset

 are all real,
 we have 
\begin_inset Formula $D\vDash\etau_{q\varphi q}(\vec{b})$
\end_inset

.
 This is a consequence of the note at the end of Item 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:qetpetau"

\end_inset

 of the QETP.
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $(q,\varphi,\tau)$
\end_inset

 be the formula assigned to 
\begin_inset Formula $m$
\end_inset

.
 The formula 
\begin_inset Formula $q(\vec{x},y,\vec{z})$
\end_inset

 will not,
 in general,
 be the quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

-type of the current elements of 
\begin_inset Formula $M$
\end_inset

,
 but it is definitely the quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

-type of some subset of elements of 
\begin_inset Formula $M$
\end_inset

.
 By 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:asmutau"

\end_inset

,
 the elements corresponding to 
\begin_inset Formula $\vec{x}$
\end_inset

 are exactly the ones that currently admit matches in 
\begin_inset Formula $D$
\end_inset

.
 Let 
\begin_inset Formula $\vec{b}$
\end_inset

 denote their matches.
\end_layout

\begin_layout Standard
We let 
\begin_inset Formula $Q(\vec{x},y,\vec{z},\vec{w})$
\end_inset

 denote the quantifier-free type of the current elements of 
\begin_inset Formula $M$
\end_inset

,
 where 
\begin_inset Formula $\vec{x}$
\end_inset

,
 
\begin_inset Formula $y$
\end_inset

,
 and 
\begin_inset Formula $\vec{z}$
\end_inset

 are the same as above.
\end_layout

\begin_layout Standard
Look through the elements of 
\begin_inset Formula $D$
\end_inset

 until you find an element 
\begin_inset Formula $d$
\end_inset

 satisfying 
\begin_inset Formula $D\vDash\tau(\vec{b},d)$
\end_inset

 to current approximation (in the sense of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rmk:llorc2"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

).
\end_layout

\begin_layout Standard

\size small
Technical note:
 This search must be done in some systematic way so that,
 if all 
\begin_inset Formula $\vec{b}$
\end_inset

 are real,
 we eventually find a 
\emph on
real
\emph default
 element 
\begin_inset Formula $d$
\end_inset

 satisfying this formula in such a way that the approximation nevermore changes.
 An example of such a systematic way:
 Let's say we give the 
\begin_inset Formula $n$
\end_inset

-th element added to 
\begin_inset Formula $D$
\end_inset

,
 say 
\begin_inset Formula $d_{n}$
\end_inset

,
 a penalty of 
\begin_inset Formula $n$
\end_inset

 stages in the time it takes to compute whether 
\begin_inset Formula $D\vDash\tau(\vec{b},d_{n})$
\end_inset

,
 and select the 
\begin_inset Formula $d$
\end_inset

 such that 
\begin_inset Formula $D\vDash\tau(\vec{b},d)$
\end_inset

 is verified (and not disproven until now) in the least amount of stages.
 This will be important when proving finite injury.
\end_layout

\begin_layout Standard
We claim that,
 unless an injury occurs,
 this search will eventually terminate.
 By this we mean:
 Assume that all 
\begin_inset Formula $\vec{b}$
\end_inset

 are real,
 and that the triple 
\begin_inset Formula $(q,\varphi,\tau)$
\end_inset

 will never be removed from the enumeration from 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rmk:tauwork"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
 Then,
 by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "enu:asmchi"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 it must be the case that 
\begin_inset Formula $D\vDash\chi_{Q}(\vec{b})$
\end_inset

 and by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "enu:asmetau"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 it must be the case that 
\begin_inset Formula $D\vDash\etau_{q\varphi Q}(\vec{b})$
\end_inset

.
 Thus,
 by definition of 
\begin_inset Formula $\etau$
\end_inset

,
 it must be the case that 
\begin_inset Formula $D\vDash\exists_{y}\tau_{q}(\vec{b},y)$
\end_inset

,
 and any witness to this statement will serve as the 
\begin_inset Formula $d$
\end_inset

 above.
\end_layout

\begin_layout Standard
Once such a 
\begin_inset Formula $d$
\end_inset

 is found,
 we match 
\begin_inset Formula $m$
\end_inset

 to 
\begin_inset Formula $d$
\end_inset

.
\end_layout

\begin_layout Standard
We need to make sure that 
\begin_inset CommandInset ref
LatexCommand formatted
reference "enu:asmchi"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "enu:asmtau"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 hold.
\end_layout

\begin_layout Itemize
\begin_inset CommandInset ref
LatexCommand formatted
reference "enu:asmchi"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 – If 
\begin_inset Formula $d$
\end_inset

 is real,
 this is direct by Item 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:qetp3"

\end_inset

 of the QETP.
\end_layout

\begin_layout Itemize
\begin_inset CommandInset ref
LatexCommand formatted
reference "enu:asmtau"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 – By construction
\end_layout

\end_deeper
\begin_layout Itemize
Next,
 find the first element of 
\begin_inset Formula $D$
\end_inset

 – call it 
\begin_inset Formula $d$
\end_inset

 – that does not have a match in 
\begin_inset Formula $M$
\end_inset

.
 If there is no such element as of right now,
 proceed to the next bullet point.
\end_layout

\begin_deeper
\begin_layout Standard
Let 
\begin_inset Formula $q(\vec{x},\vec{y})$
\end_inset

 be the quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

-type of the elements of 
\begin_inset Formula $M$
\end_inset

,
 and 
\begin_inset Formula $\vec{b}$
\end_inset

 the matches of the elements of 
\begin_inset Formula $M$
\end_inset

 that admit matches.
 Let 
\begin_inset Formula $r(\vec{x},z)$
\end_inset

 be the quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

-type of the tuple 
\begin_inset Formula $(\vec{b},d)$
\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Here,
 we use Item 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:qetp0"

\end_inset

 of the QETP to computably obtain (a strong index for) 
\begin_inset Formula $r(\vec{x},z)$
\end_inset

 from a c.e.
\begin_inset space \space{}
\end_inset

index for the atomic 
\begin_inset Formula $\Lang'$
\end_inset

-type of 
\begin_inset Formula $(\vec{b},d)$
\end_inset

.
 More generally,
 we use the fact that Item 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:qetp0"

\end_inset

 of the QETP allows us to computably obtain a strong index for the 
\begin_inset Formula $\Lang$
\end_inset

-type of a tuple from a c.e.
\begin_inset space \space{}
\end_inset

index for its 
\begin_inset Formula $\Lang'$
\end_inset

-type.
\end_layout

\end_inset

 In parallel,
 look through the realized quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

 existential types 
\begin_inset Formula $\exists_{\vec{x}}\exists_{\vec{y}}\exists_{z}Q(\vec{x},z,\vec{y})$
\end_inset

 until you find such a 
\begin_inset Formula $Q(\vec{x},z,\vec{y})$
\end_inset

 extending 
\begin_inset Formula $q(\vec{x},\vec{y})\land r(\vec{x},z)$
\end_inset

 such that:
\end_layout

\begin_layout Itemize
\begin_inset Formula $D\vDash\chi_{Q(\vec{x},z,\cdot)}(\vec{b},d)$
\end_inset

,
 and
\end_layout

\begin_layout Itemize
For every 
\begin_inset Formula $m$
\end_inset

 with an assigned triplet 
\begin_inset Formula $(q_{0}(\vec{x}_{0},y_{0},\vec{z}_{0}),\varphi(\vec{x}_{0}),\tau(\vec{x}_{0},y_{0}))$
\end_inset

,
 if 
\begin_inset Formula $\vec{b}_{0}$
\end_inset

 are the elements of 
\begin_inset Formula $M$
\end_inset

 corresponding to 
\begin_inset Formula $\vec{x}_{0}$
\end_inset

,
 
\begin_inset Formula $D\vDash\etau_{q_{0}\varphi Q}(\vec{b}_{0})$
\end_inset

.
\end_layout

\begin_layout Standard
We argue that either such a 
\begin_inset Formula $Q$
\end_inset

 is found in finite time or otherwise an injury will occur.
 Indeed,
 suppose that both 
\begin_inset Formula $d$
\end_inset

 and the elements of 
\begin_inset Formula $\vec{b}$
\end_inset

 are all real,
 and that every triplet 
\begin_inset Formula $(q_{0},\varphi,\tau)$
\end_inset

 will nevermore be injured.
 Now,
 since we assume 
\begin_inset Formula $D\vDash\chi_{q}(\vec{b})$
\end_inset

,
 there must be a tuple of real elements 
\begin_inset Formula $\vec{c}$
\end_inset

 in 
\begin_inset Formula $D$
\end_inset

 such that 
\begin_inset Formula $D\vDash q(\vec{b},\vec{c})$
\end_inset

.
 Now,
 we claim that the type 
\begin_inset Formula $Q$
\end_inset

 of the tuple 
\begin_inset Formula $(\vec{b},d,\vec{c})$
\end_inset

 satisfies the desired requisites:
\end_layout

\begin_layout Itemize
Since 
\begin_inset Formula $D\vDash Q(\vec{b},d,\vec{c})$
\end_inset

,
 we must have 
\begin_inset Formula $D\vDash\exists_{\vec{y}}Q(\vec{b},d,\vec{y})$
\end_inset

 and hence 
\begin_inset Formula $D\vDash\chi_{Q}(\vec{b},d)$
\end_inset

,
 and
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $m$
\end_inset

 has the triplet 
\begin_inset Formula $(q_{0},\varphi,\tau)$
\end_inset

 assigned,
 with decomposition 
\begin_inset Formula $(\vec{x}_{0},y_{0},\vec{z}_{0})\subseteq M$
\end_inset

,
 with 
\begin_inset Formula $\vec{b}_{0}$
\end_inset

 being the elements of 
\begin_inset Formula $D$
\end_inset

 corresponding to 
\begin_inset Formula $\vec{x}_{0}$
\end_inset

 and 
\begin_inset Formula $d_{0}$
\end_inset

 being the element corresponding to 
\begin_inset Formula $m$
\end_inset

,
 we have 
\begin_inset Formula $D\vDash\chi_{Q}(\vec{b}_{0},d_{0})$
\end_inset

 as a consequence of 
\begin_inset Formula $D\vDash\chi_{Q}(\vec{b},d)$
\end_inset

 as a consequence of 
\begin_inset Formula $D\vDash Q(\vec{b},d,\vec{c})$
\end_inset

,
 and moreover 
\begin_inset Formula $D\vDash\tau(\vec{b}_{0},d_{0})$
\end_inset

 by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "enu:asmtau"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 hence 
\begin_inset Formula $D\vDash\exists_{y}\left[\chi_{Q}(\vec{b}_{0},y)\land\tau_{q\varphi}(\vec{b}_{0},y)\right])$
\end_inset

,
 and thus 
\begin_inset Formula $D\vDash\etau_{q_{0}\varphi Q}(\vec{b}_{0})$
\end_inset

 by Item 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:qetpetau"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 of the QETP.
\end_layout

\begin_layout Standard
Once such a 
\begin_inset Formula $Q(\vec{x},z,\vec{y})$
\end_inset

 is found,
 one of two things occurs.
 Either it includes 
\begin_inset Formula $z=y_{j}$
\end_inset

 for some value of 
\begin_inset Formula $j$
\end_inset

,
 in which case we match 
\begin_inset Formula $d$
\end_inset

 to the element corresponding to 
\begin_inset Formula $y_{j}$
\end_inset

,
 or it includes the information that all its variables represent distinct elements,
 in which case we add a new element to 
\begin_inset Formula $M$
\end_inset

,
 whose relations to the previous elements are those dictated by 
\begin_inset Formula $Q$
\end_inset

,
 and match it to 
\begin_inset Formula $d$
\end_inset

.
\end_layout

\begin_layout Standard
We need to make sure that 
\begin_inset CommandInset ref
LatexCommand formatted
reference "enu:asmchi"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "enu:asmetau"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 hold.
\end_layout

\begin_layout Itemize
\begin_inset CommandInset ref
LatexCommand formatted
reference "enu:asmchi"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 – By construction,
 since we ensured 
\begin_inset Formula $D\vDash\chi_{Q}(\vec{b},d)$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset CommandInset ref
LatexCommand formatted
reference "enu:asmetau"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 – By construction.
\end_layout

\end_deeper
\begin_layout Itemize
Once both of the above steps are done,
 worker 
\begin_inset Formula $i$
\end_inset

 shall pause its execution,
 and initialize worker 
\begin_inset Formula $i+1$
\end_inset

.
\end_layout

\begin_layout Standard
We now describe the process of injury.
 There are three means of injury:
\end_layout

\begin_layout Itemize
Suppose that an element of 
\begin_inset Formula $D$
\end_inset

 is seen to be removed.
 If this element does not have a match in 
\begin_inset Formula $M$
\end_inset

,
 no action must be taken.
 On the other hand,
 suppose that this element 
\begin_inset Formula $d$
\end_inset

 is matched to an element 
\begin_inset Formula $m$
\end_inset

 in 
\begin_inset Formula $M$
\end_inset

.
 In that event,
 suppose that worker 
\begin_inset Formula $i$
\end_inset

 is the one that made this match,
 and halt the execution of all workers with index greater than 
\begin_inset Formula $i$
\end_inset

,
 erasing matches and assigned formulas created past the moment that 
\begin_inset Formula $m$
\end_inset

 and 
\begin_inset Formula $d$
\end_inset

 were matched.
 If the match between 
\begin_inset Formula $d$
\end_inset

 and 
\begin_inset Formula $m$
\end_inset

 was created by the first bullet point,
 restart the execution of worker 
\begin_inset Formula $i$
\end_inset

.
 If the match between 
\begin_inset Formula $d$
\end_inset

 and 
\begin_inset Formula $m$
\end_inset

 was created by the second bullet point,
 initialize worker 
\begin_inset Formula $i+1$
\end_inset

 (and do not restart worker 
\begin_inset Formula $i$
\end_inset

).
\end_layout

\begin_layout Itemize
Suppose that an element 
\begin_inset Formula $m\in M$
\end_inset

 has an assigned triplet 
\begin_inset Formula $(q,\varphi,\tau)$
\end_inset

,
 which is seen to be deleted from the enumeration described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rmk:tauwork"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 at a given stage.
 Suppose worker 
\begin_inset Formula $i$
\end_inset

 is the one who has assigned this formula.
 Then,
 we halt the execution of all workers with index greater than 
\begin_inset Formula $i$
\end_inset

,
 and erase all matches and assigned formulas created past the moment that this formula was assigned to 
\begin_inset Formula $m$
\end_inset

.
 Then,
 we run worker 
\begin_inset Formula $i$
\end_inset

.
\end_layout

\begin_layout Itemize
Suppose that an element 
\begin_inset Formula $m\in M$
\end_inset

 has an assigned triplet 
\begin_inset Formula $(q(\vec{x},y,\vec{z}),\varphi(\vec{x}),\tau(\vec{x},y))$
\end_inset

 and a matched element 
\begin_inset Formula $d$
\end_inset

.
 Suppose worker 
\begin_inset Formula $i$
\end_inset

 is the one who has created these matches.
 Suppose that the elements 
\begin_inset Formula $\vec{x}$
\end_inset

 are matched to the tuple 
\begin_inset Formula $\vec{b}$
\end_inset

,
 and suppose that the current approximation of 
\begin_inset Formula $D\vDash\tau(\vec{b},d)$
\end_inset

 (in the sense of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rmk:llorc2"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

) has changed to 
\begin_inset Quotes els
\end_inset

no
\begin_inset Quotes ers
\end_inset

.
 Then,
 we halt the execution of all workers with index greater than 
\begin_inset Formula $i$
\end_inset

,
 erase all matches and assigned formulas created past this point (including the match between 
\begin_inset Formula $m$
\end_inset

 and 
\begin_inset Formula $d$
\end_inset

,
 but we retain the assigned triplet 
\begin_inset Formula $(q,\varphi,\tau)$
\end_inset

),
 and run worker 
\begin_inset Formula $i$
\end_inset

.
\end_layout

\begin_layout Standard
This concludes the construction.
 It remains to show that the resulting structure 
\begin_inset Formula $M$
\end_inset

 is isomorphic to 
\begin_inset Formula $D\upto\Lang$
\end_inset

,
 and this is done via a finite injury argument.
 We show that each worker will be injured finitely many times.
 This will show that every element in 
\begin_inset Formula $D$
\end_inset

 is eventually matched to an element of 
\begin_inset Formula $M$
\end_inset

 (the 
\begin_inset Formula $i$
\end_inset

-th element of 
\begin_inset Formula $D$
\end_inset

 (counting both real and fake elements) will be matched by,
 at worst,
 the 
\begin_inset Formula $i$
\end_inset

-th worker past the moment when this element is added to 
\begin_inset Formula $D$
\end_inset

),
 and that every element of 
\begin_inset Formula $M$
\end_inset

 is eventually matched to an element of 
\begin_inset Formula $D$
\end_inset

 (given an orphan element of 
\begin_inset Formula $M$
\end_inset

,
 inductively consider the first worker activated after all previous elements of 
\begin_inset Formula $M$
\end_inset

 have been matched),
 and since these matches all preserve the predicates in 
\begin_inset Formula $\Lang$
\end_inset

,
 the resulting map will be an isomorphism.
\end_layout

\begin_layout Standard
Suppose,
 for the sake of induction,
 that all workers prior to worker 
\begin_inset Formula $i$
\end_inset

 are injured finitely many times.
 We show that worker 
\begin_inset Formula $i$
\end_inset

 itself also suffers finite injury.
 We do this individually for each of the bullet points:
\end_layout

\begin_layout Itemize
First,
 we show that the matching created by the first orphan element of 
\begin_inset Formula $m$
\end_inset

 at this moment,
 if there is any,
 is injured finitely many times.
 Indeed,
 per the notation of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rmk:tauwork"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 and using Item 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:qetp2"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 of the QETP,
 eventually a triplet 
\begin_inset Formula $(q,\varphi,\tau)$
\end_inset

 will be enumerated and never removed,
 such that the relevant elements of 
\begin_inset Formula $D$
\end_inset

 satisfy 
\begin_inset Formula $\chi_{q}\land\varphi$
\end_inset

.
 Past this point,
 after all previously-added false triplets have been removed,
 this triplet (or another) will be permanently assigned to 
\begin_inset Formula $m$
\end_inset

.
 Afterward,
 we know (see the technical note in the first bullet point of the description of the worker process) that after enough steps we match 
\begin_inset Formula $m$
\end_inset

 with a real element 
\begin_inset Formula $d$
\end_inset

 of 
\begin_inset Formula $D$
\end_inset

 that satisfies 
\begin_inset Formula $\tau(\vec{b},d)$
\end_inset

 at the current approximation,
 which will nevermore change.
 Thus,
 past this point,
 this match will never be injured.
\end_layout

\begin_layout Itemize
Now,
 assuming that we've reached a time where the matching created by the previous bullet point or previous workers will never suffer injury,
 suppose that there is an unmatched element in 
\begin_inset Formula $D$
\end_inset

 for worker 
\begin_inset Formula $i$
\end_inset

 to match with an element of 
\begin_inset Formula $M$
\end_inset

.
 If this element is real,
 no injury will be suffered.
 If it is not,
 eventually it shall be erased,
 and execution will move to worker 
\begin_inset Formula $i+1$
\end_inset

,
 with worker 
\begin_inset Formula $i$
\end_inset

 nevermore suffering injury from that point.
\end_layout

\begin_layout Standard
This concludes the proof.
\end_layout

\end_deeper
\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:prevs_applications"

\end_inset

Previously Known Applications
\end_layout

\begin_layout Standard
In this section,
 we present a list of some consequences of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
 We claim originality over none of the results themselves – our goal here is merely to show how they all follow from the same general principle,
 and we present prior references to where the results may be found in the literature.
\end_layout

\begin_layout Standard
All of the following results are bidirectional,
 but due to the direction of this paper,
 we will only be focusing on the most relevant of the two directions in each case,
 which will generally be arguably the most difficult one.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:eqvrelsinf"

\end_inset

Equivalence Relations of Infinite Rank
\end_layout

\begin_layout Proposition
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Folklore,
 
\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "cst_downey_melnikov"
posttextlist "cst_downey_melnikov Theorem 9.1.4"
literal "false"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "prop:eqvinf"

\end_inset

Let 
\begin_inset Formula $(E,\eqvrel)$
\end_inset

 be an equivalence relation with infinitely many equivalence classes,
 and assume that the structure 
\begin_inset Formula $(E,\eqvrel,\{P_{\geq n}\}_{n\in\N})$
\end_inset

 admits a 
\begin_inset Formula $0'$
\end_inset

-computable copy,
 where 
\begin_inset Formula $P_{\geq n}(x)$
\end_inset

 is the predicate 
\begin_inset Quotes eld
\end_inset

the equivalence class of 
\begin_inset Formula $x$
\end_inset

 has size at least 
\begin_inset Formula $n$
\end_inset


\begin_inset Quotes erd
\end_inset

.
\begin_inset Foot
status open

\begin_layout Plain Layout
This includes the case where the equivalence class of 
\begin_inset Formula $x$
\end_inset

 is infinite.
\end_layout

\end_inset

 Then,
 
\begin_inset Formula $(E,\eqvrel)$
\end_inset

 admits a computable copy.
\end_layout

\begin_layout Proof
First,
 we note that if 
\begin_inset Formula $(E,\eqvrel,\{P_{\geq n}\}_{n\in\N})$
\end_inset

 admits a 
\begin_inset Formula $0'$
\end_inset

-computable copy then 
\begin_inset Formula $(E,\eqvrel,\{P_{\geq n}\}_{n\in\N\cup\{\infty\}})$
\end_inset

 admits a 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed copy,
 where 
\begin_inset Formula $P_{\geq\infty}(x)$
\end_inset

 is the predicate 
\begin_inset Quotes eld
\end_inset

the equivalence class of 
\begin_inset Formula $x$
\end_inset

 is infinite
\begin_inset Quotes erd
\end_inset

.
 We construct this copy as follows:
 With an oracle for 
\begin_inset Formula $0'$
\end_inset

,
 run the construction of 
\begin_inset Formula $(E,\eqvrel,\{P_{\geq n}\}_{n\in\N})$
\end_inset

,
 and every time you see an element in a new finite equivalence class of size exactly 
\begin_inset Formula $n$
\end_inset

 (i.e.
\begin_inset space \space{}
\end_inset

satisfies 
\begin_inset Formula $P_{\geq n}$
\end_inset

 but not 
\begin_inset Formula $P_{\geq n+1}$
\end_inset

),
 output an equivalence class of size exactly 
\begin_inset Formula $n$
\end_inset

.
 In the limit,
 you will output a copy of the substructure of 
\begin_inset Formula $E$
\end_inset

 consisting of the elements in finite equivalence classes.
 In parallel,
 build countably many infinite equivalence classes.
 Since we know everything about the equivalence class of any given element when we are outputting it,
 it is trivial to provide a c.e.
\begin_inset space \space{}
\end_inset

(or even computable) index for the type of the tuple of elements output up to a given point.
\end_layout

\begin_layout Proof
Next,
 we show that 
\begin_inset Formula $E$
\end_inset

 satisfies the QETP relative to the languages:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\Lang$
\end_inset

 is the language containing 
\begin_inset Formula $\eqvrel$
\end_inset

,
 
\begin_inset Formula $\not\eqvrel$
\end_inset

,
 
\begin_inset Formula $=$
\end_inset

,
 and 
\begin_inset Formula $\neq$
\end_inset

,
\end_layout

\begin_layout Itemize
\begin_inset Formula $\Lang'$
\end_inset

 is the language containing 
\begin_inset Formula $\Lang$
\end_inset

,
 plus the countably many predicates 
\begin_inset Formula $P_{\geq n}$
\end_inset

.
\end_layout

\begin_layout Standard
It is obvious that 
\begin_inset Formula $\Lang$
\end_inset

 is finite and closed under negation,
 so it suffices to construct 
\begin_inset Formula $\chi$
\end_inset

,
 
\begin_inset Formula $\tau$
\end_inset

,
 and 
\begin_inset Formula $\etau$
\end_inset

.
\end_layout

\begin_layout Itemize
To construct 
\begin_inset Formula $\chi_{q}(\vec{x})$
\end_inset

 given 
\begin_inset Formula $q(\vec{x},\vec{y})$
\end_inset

:
 Without loss of generality (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rmk:assumeq"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

) we assume that 
\begin_inset Formula $q(\vec{x},\vec{y})$
\end_inset

 is a maximal conjunction of atomic formulas of the types:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $y_{i}\eqvrel x_{j}$
\end_inset

 or 
\begin_inset Formula $y_{i}\not\eqvrel x_{j}$
\end_inset

,
 and one of these is included for every 
\begin_inset Formula $i$
\end_inset

 and 
\begin_inset Formula $j$
\end_inset

,
\end_layout

\begin_layout Itemize
\begin_inset Formula $y_{i}\eqvrel y_{j}$
\end_inset

 or 
\begin_inset Formula $y_{i}\not\eqvrel y_{j}$
\end_inset

,
 and one of these is included for every 
\begin_inset Formula $i$
\end_inset

 and 
\begin_inset Formula $j$
\end_inset

,
\end_layout

\begin_layout Itemize
\begin_inset Formula $x_{i}\eqvrel x_{j}$
\end_inset

 or 
\begin_inset Formula $x_{i}\not\eqvrel x_{j}$
\end_inset

,
 and one of these is included for every 
\begin_inset Formula $i$
\end_inset

 and 
\begin_inset Formula $j$
\end_inset

,
\end_layout

\begin_layout Itemize
\begin_inset Formula $y_{i}\neq x_{j}$
\end_inset

,
 and all of these are included for every 
\begin_inset Formula $i$
\end_inset

 and 
\begin_inset Formula $j$
\end_inset

,
\end_layout

\begin_layout Itemize
\begin_inset Formula $y_{i}\neq y_{j}$
\end_inset

,
 and all of these are included for 
\begin_inset Formula $i\neq j$
\end_inset

,
\end_layout

\begin_layout Itemize
\begin_inset Formula $x_{i}\neq x_{j}$
\end_inset

,
 and all of these are included for 
\begin_inset Formula $i\neq j$
\end_inset

.
\end_layout

\begin_layout Standard
Thus,
 
\begin_inset Formula $q(\vec{x},\vec{y})$
\end_inset

 includes all the information about these elements in terms of what equivalence classes they inhabit.
 If the information is inconsistent,
 (namely,
 if it fails transitivity,
 reflexivity,
 or symmetry),
 simply set 
\begin_inset Formula $\chi_{q}(\vec{x})\equiv\bot$
\end_inset

.
 On the other hand,
 if the information is consistent,
 for such a tuple 
\begin_inset Formula $\vec{y}$
\end_inset

 to exist given the tuple 
\begin_inset Formula $\vec{x}$
\end_inset

 requires,
 and indeed is equivalent,
 to the demand that the equivalence class of each 
\begin_inset Formula $x_{i}$
\end_inset

 is large enough – namely,
 the equivalence class of 
\begin_inset Formula $x_{i}$
\end_inset

 must be of size 
\begin_inset Formula $n_{i}$
\end_inset

 or above,
 where 
\begin_inset Formula $n_{i}$
\end_inset

 is the number of distinct variables 
\begin_inset Formula $z$
\end_inset

 such that 
\begin_inset Formula $z\eqvrel x_{i}$
\end_inset

 is part of the information in 
\begin_inset Formula $q$
\end_inset

.
 As such,
 we set 
\begin_inset Formula $\chi_{q}(\vec{x})\equiv q_{0}(\vec{x})\land\bigwedge_{i}P_{\geq n_{i}}(x_{i})$
\end_inset

,
 where 
\begin_inset Formula $q_{0}(\vec{x})$
\end_inset

 is the information in 
\begin_inset Formula $q$
\end_inset

 that relates the elements of 
\begin_inset Formula $\vec{x}$
\end_inset

.
 It will satisfy the requirements about 
\begin_inset Formula $\chi$
\end_inset

 by construction.
\end_layout

\begin_layout Standard
Note that we are using the assumption that there exist infinitely many arbitrarily large equivalence classes to handle variables 
\begin_inset Formula $y_{i}$
\end_inset

 that are not equivalent to any 
\begin_inset Formula $x_{j}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
To construct 
\begin_inset Formula $\tau_{q\varphi}(\vec{x},y)$
\end_inset

:
 The domain of 
\begin_inset Formula $\tau$
\end_inset

 shall be the set of pairs 
\begin_inset Formula $(q,\top)$
\end_inset

.
 Given 
\begin_inset Formula $q(\vec{x},y,\vec{z})$
\end_inset

,
 set 
\begin_inset Formula $\tau_{q\top}(\vec{x},y)\equiv\chi_{q}(\vec{x},y)\land\left(P_{\geq\infty}(y)\lor\bigvee_{i}y\eqvrel x_{i}\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
To construct 
\begin_inset Formula $\etau_{q\varphi Q}(\vec{x})$
\end_inset

:
 Simply set 
\begin_inset Formula $\etau_{q\varphi Q}(\vec{x})\equiv\chi_{Q}(\vec{x})$
\end_inset

 in all circumstances.
\end_layout

\begin_layout Standard
It is a tedious but straight-forward exercise in model theory to verify that the above assignments serve as witnesses to the QETP.
 We use the fact that there are infinitely many infinite equivalence classes in an essential way when verifying Item 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:qetp2"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 of the QETP.
 By application of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 the proof is complete.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
There are a few properties of the above proof that will come up again,
 so we remark on them now.
\end_layout

\begin_layout Remark
We have used a very weak version of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
 For example:
 We used no infinitary formulas,
 our 
\begin_inset Formula $\tau$
\end_inset

 was computable with computable domain,
 instead of merely 
\begin_inset Formula $0'$
\end_inset

-computable with 
\begin_inset Formula $0'$
\end_inset

-c.e.
\begin_inset space \space{}
\end_inset

domain,
 etc.
 This reflects the fact that,
 as far as jump inversion theorems go,
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:eqvinf"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 is rather simple!
 We will see some other natural (though not necessarily much more complicated) examples that use more of the power of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
Even though 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 provides a 
\begin_inset Formula $0'$
\end_inset

-computable isomorphism between the reduct of the original structure and the resulting structure,
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:eqvinf"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 does not provide such a guarantee.
 Indeed,
 one can show that the best we can do in general is to find a 
\begin_inset Formula $0''$
\end_inset

-computable isomorphism between the original 
\begin_inset Formula $0'$
\end_inset

-computable equivalence relation – call it 
\begin_inset Formula $E_{0}$
\end_inset

 –,
 and the computable copy – call it 
\begin_inset Formula $E_{1}$
\end_inset

.
 This stems from the fact that we have built an intermediate auxiliary structure to apply 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 to – say 
\begin_inset Formula $E_{+}$
\end_inset

 – and even though 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 guarantees that there is a 
\begin_inset Formula $0'$
\end_inset

-computable isomorphism between 
\begin_inset Formula $E_{+}$
\end_inset

 and 
\begin_inset Formula $E_{1}$
\end_inset

,
 an isomorphism between 
\begin_inset Formula $E_{0}$
\end_inset

 and 
\begin_inset Formula $E_{+}$
\end_inset

 may be computably more complicated.
 The best that we can guarantee,
 and indeed the best that can be guaranteed,
 is that such an isomorphism is 
\begin_inset Formula $0''$
\end_inset

-computable,
 as 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:eqvcomplexiso"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 below shows.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:enueqv"

\end_inset

There is a computable enumeration of all computable equivalence relations,
 finite or infinite.
\end_layout

\begin_layout Proof
\begin_inset FormulaMacro
\newcommand{\braket}[1]{\langle#1\rangle}
\end_inset

Let 
\begin_inset Formula $\varphi_{n}(x)$
\end_inset

 denote the 
\begin_inset Formula $n$
\end_inset

-th 
\begin_inset Formula $\{0,1\}$
\end_inset

-valued partial computable function.
 Then,
 for each 
\begin_inset Formula $n$
\end_inset

,
 define the 
\begin_inset Formula $n$
\end_inset

-th computable equivalence relation on an initial segment of 
\begin_inset Formula $\N$
\end_inset

 as follows:
 If we've added all numbers below a given 
\begin_inset Formula $k$
\end_inset

 to the equivalence relation,
 then we attempt to calculate 
\begin_inset Formula $\varphi_{n}\braket{0,k}$
\end_inset

,
 
\begin_inset Formula $\varphi_{n}\braket{1,k}$
\end_inset

,
 
\begin_inset Formula $\dots$
\end_inset

,
 
\begin_inset Formula $\varphi_{n}\braket{k,k}$
\end_inset

 and 
\begin_inset Formula $\varphi_{n}\braket{k,0}$
\end_inset

,
 
\begin_inset Formula $\varphi_{n}\braket{k,1}$
\end_inset

,
 
\begin_inset Formula $\dots$
\end_inset

,
 
\begin_inset Formula $\varphi_{n}\braket{k,k}$
\end_inset

.
 If any of these computations do not halt,
 neither 
\begin_inset Formula $k$
\end_inset

 nor any number greater than 
\begin_inset Formula $k$
\end_inset

 is considered to be part of the 
\begin_inset Formula $n$
\end_inset

-th computable equivalence relation,
 which is therefore finite with exactly 
\begin_inset Formula $k$
\end_inset

 elements.
 Otherwise,
 we check if the resulting relation on the set 
\begin_inset Formula $\{0,\dots,k\}$
\end_inset

 is an equivalence relation.
 If it is not,
 we again consider the 
\begin_inset Formula $n$
\end_inset

-th equivalence relation to have exactly 
\begin_inset Formula $k$
\end_inset

 elements;
 if it is,
 we add 
\begin_inset Formula $k$
\end_inset

 to the equivalence relation and repeat with 
\begin_inset Formula $k+1$
\end_inset

.
 This construction guarantees that any computable equivalence relation has an isomorphic copy corresponding to some value of 
\begin_inset Formula $n$
\end_inset

.
\end_layout

\begin_layout Proposition
\begin_inset CommandInset label
LatexCommand label
name "prop:eqvcomplexiso"

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
is this anywhere in the literature?
\end_layout

\end_inset

There is a 
\begin_inset Formula $0'$
\end_inset

-computable equivalence relation 
\begin_inset Formula $(E_{0},\eqvrel,\{P_{\geq n}\}_{n\in\N})$
\end_inset

 with infinitely many infinite equivalence classes such that any isomorphism 
\begin_inset Formula $f$
\end_inset

 between 
\begin_inset Formula $E_{0}\upto\eqvrel$
\end_inset

 and a computable equivalence relation 
\begin_inset Formula $(E_{1},\eqvrel)$
\end_inset

 can be used to compute 
\begin_inset Formula $0''$
\end_inset

.
\end_layout

\begin_layout Proof
We shall build 
\begin_inset Formula $E_{0}=E_{00}\amalg E_{01}$
\end_inset

,
 where 
\begin_inset Formula $E_{00}$
\end_inset

 shall be used to encode 
\begin_inset Formula $0'$
\end_inset

 (into any isomorphism between 
\begin_inset Formula $E_{0}$
\end_inset

 and a computable equivalence relation),
 and 
\begin_inset Formula $E_{01}$
\end_inset

 shall be used to encode 
\begin_inset Formula $0''$
\end_inset

,
 via encoding the set of total Turing indices – though the decoding process will require the usage of 
\begin_inset Formula $0'$
\end_inset

,
 which is why 
\begin_inset Formula $E_{00}$
\end_inset

 is necessary.
\end_layout

\begin_layout Proof
To build 
\begin_inset Formula $E_{00}$
\end_inset

:
 Consider designated elements 
\begin_inset Formula $a_{0}$
\end_inset

,
 
\begin_inset Formula $a_{1}$
\end_inset

,
 
\begin_inset Formula $a_{2}$
\end_inset

,
 etc.
 where 
\begin_inset Formula $a_{2n}$
\end_inset

 is defined to be equivalent to 
\begin_inset Formula $a_{2n+1}$
\end_inset

 if,
 and only if,
 
\begin_inset Formula $n\in0'$
\end_inset

,
 and no other equivalences exist between any 
\begin_inset Formula $a_{i}$
\end_inset

 and any other element of 
\begin_inset Formula $E_{0}$
\end_inset

.
 If we have an isomorphism 
\begin_inset Formula $f$
\end_inset

 between 
\begin_inset Formula $E_{0}$
\end_inset

 and a computable equivalence relation,
 we can therefore tell if 
\begin_inset Formula $n\in0'$
\end_inset

 by checking whether 
\begin_inset Formula $f(a_{2n})$
\end_inset

 is equivalent to 
\begin_inset Formula $f(a_{2n+1})$
\end_inset

.
\end_layout

\begin_layout Proof
To build 
\begin_inset Formula $E_{01}$
\end_inset

:
 Consider designated elements 
\begin_inset Formula $\{b_{nx}\}_{(n,x)\in\N^{2}}$
\end_inset

.
 For each 
\begin_inset Formula $n\in\N$
\end_inset

,
 iterate through the values of 
\begin_inset Formula $x\in\N$
\end_inset

 until such an 
\begin_inset Formula $x$
\end_inset

 is found with 
\begin_inset Formula $\varphi_{n}(x)\isnotwd$
\end_inset

.
 If no such 
\begin_inset Formula $x$
\end_inset

 is found,
 make 
\begin_inset Formula $b_{ni}\eqvrel b_{nj}$
\end_inset

 for all 
\begin_inset Formula $i$
\end_inset

,
 
\begin_inset Formula $j$
\end_inset

.
 Otherwise,
 suppose that 
\begin_inset Formula $x$
\end_inset

 is the first value for which 
\begin_inset Formula $\varphi_{n}(x)\isnotwd$
\end_inset

.
 Then,
 spend 
\begin_inset Formula $x$
\end_inset

 steps enumerating elements of each of the first 
\begin_inset Formula $n$
\end_inset

 computable equivalence relations (as per 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:enueqv"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

),
 and using 
\begin_inset Formula $0'$
\end_inset

 find a number 
\begin_inset Formula $k\geq x$
\end_inset

 such that none of these at most 
\begin_inset Formula $xn$
\end_inset

 elements are in an equivalence class of size exactly 
\begin_inset Formula $k$
\end_inset

.
 Then,
 make 
\begin_inset Formula $b_{n0}\eqvrel\cdots\eqvrel b_{nk}$
\end_inset

,
 and no other 
\begin_inset Formula $b_{ni}$
\end_inset

 equivalent to any other.
 The essential part of this choice is that it ensures that no isomorphism between 
\begin_inset Formula $E_{0}$
\end_inset

 and one of these equivalence classes will take 
\begin_inset Formula $b_{n0}$
\end_inset

 to one of their first 
\begin_inset Formula $x$
\end_inset

 elements.
\end_layout

\begin_layout Proof
Now,
 let us show that any isomorphism 
\begin_inset Formula $f$
\end_inset

 between 
\begin_inset Formula $E_{0}$
\end_inset

 and a computable equivalence relation 
\begin_inset Formula $E_{1}$
\end_inset

 will compute 
\begin_inset Formula $0''$
\end_inset

.
 As argued before,
 
\begin_inset Formula $f$
\end_inset

 computes 
\begin_inset Formula $0'$
\end_inset

,
 so we use an oracle for 
\begin_inset Formula $0'$
\end_inset

 with impunity.
 Suppose we wish to know whether some 
\begin_inset Formula $n\in\N$
\end_inset

 is a total Turing index.
 Without loss of generality – because this happens for all but finitely many 
\begin_inset Formula $n$
\end_inset

 – assume that 
\begin_inset Formula $E_{1}$
\end_inset

 is one of the first 
\begin_inset Formula $n$
\end_inset

 computable equivalence classes.
 Then,
 find the index of 
\begin_inset Formula $f(b_{n0})$
\end_inset

 in the equivalence relation 
\begin_inset Formula $E_{1}$
\end_inset

 – say this index is 
\begin_inset Formula $t$
\end_inset

 – and check whether 
\begin_inset Formula $\varphi_{n}(0)$
\end_inset

 up to 
\begin_inset Formula $\varphi_{n}(t)$
\end_inset

 all terminate.
 If not,
 then clearly 
\begin_inset Formula $\varphi_{n}$
\end_inset

 is nontotal.
 On the other hand,
 if 
\begin_inset Formula $\varphi_{n}$
\end_inset

 is nontotal,
 with 
\begin_inset Formula $x$
\end_inset

 the first element with 
\begin_inset Formula $\varphi_{n}(x)\isnotwd$
\end_inset

,
 we know that 
\begin_inset Formula $f(b_{n0})$
\end_inset

 must have index 
\begin_inset Formula $t$
\end_inset

 greater than 
\begin_inset Formula $x$
\end_inset

,
 in which case one of the computations 
\begin_inset Formula $\varphi_{n}(0)$
\end_inset

 to 
\begin_inset Formula $\varphi_{n}(t)$
\end_inset

 will not have terminated.
 Thus,
 checking these first 
\begin_inset Formula $t$
\end_inset

 elements suffices to tell whether 
\begin_inset Formula $\varphi_{n}$
\end_inset

 is total.
\end_layout

\begin_layout Remark
Our choice of 
\begin_inset Formula $\tau_{q\varphi}$
\end_inset

 included 
\begin_inset Formula $\chi_{q}$
\end_inset

 in its definition,
 and our choice of 
\begin_inset Formula $\etau_{q\varphi Q}$
\end_inset

 included (and,
 in this case,
 was equal to) 
\begin_inset Formula $\chi_{Q}$
\end_inset

.
 Inspecting the definition of QETP,
 one finds that we can always do so – that is,
 if 
\begin_inset Formula $\chi_{q}$
\end_inset

,
 
\begin_inset Formula $\tau_{q\varphi}$
\end_inset

,
 and 
\begin_inset Formula $\etau_{q\varphi Q}$
\end_inset

 serve as witnesses to the QETP,
 so will 
\begin_inset Formula $\chi_{q}$
\end_inset

,
 
\begin_inset Formula $\tau_{q\varphi}\land\chi_{q}$
\end_inset

,
 and 
\begin_inset Formula $\etau_{q\varphi Q}\land\chi_{Q}$
\end_inset

,
 though the converse need not be true.
\end_layout

\begin_layout Remark
If we had wanted to,
 we could have modified the definition of QETP to make our formulas simpler in practice,
 by replacing e.g.
\begin_inset space \space{}
\end_inset

every instance of 
\begin_inset Formula $\tau$
\end_inset

 with 
\begin_inset Formula $\tau\land\chi$
\end_inset

,
 and likewise for 
\begin_inset Formula $\etau$
\end_inset

.
 For instance,
 Item 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:qetp3"

\end_inset

 currently requires
\begin_inset Formula 
\[
D\vDash\forall_{\vec{x},y}\left[\etau_{q\varphi Q}(\vec{x})\land\tau_{q\varphi}(\vec{x},y)\rightarrow\chi_{Q}(\vec{x},y)\right],
\]

\end_inset

and we might consider making the weaker requirement that
\begin_inset Formula 
\[
D\vDash\forall_{\vec{x},y}\left[\etau_{q\varphi Q}(\vec{x})\land\chi_{Q}(\vec{x})\land\tau_{q\varphi}(\vec{x},y)\land\chi_{q}(\vec{x},y)\rightarrow\chi_{Q}(\vec{x},y)\right].
\]

\end_inset


\end_layout

\begin_layout Remark
Such a change would not alter which structures satisfy the QETP,
 only what their witnessing formulas are,
 and if we were optimizing for the writing of applications,
 we could have used the weaker version instead.
 For example,
 in the case of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:eqvinf"

\end_inset

,
 we currently have
\begin_inset Formula 
\[
\tau_{q}(\vec{x},y)\equiv\chi_{q}(\vec{x},y)\land\left(P_{\geq\infty}(y)\lor\bigvee_{i}y\eqvrel x_{i}\right)\text{ and }\etau_{q\varphi Q}(\vec{x})\equiv\chi_{Q}(\vec{x}),
\]

\end_inset

and with the alternate version of the QETP this could be replaced by the simpler and arguably more elegant
\begin_inset Formula 
\[
\tau_{q}(\vec{x},y)\equiv P_{\geq\infty}(y)\lor\bigvee_{i}y\eqvrel x_{i}\text{ and }\etau_{q\varphi Q}(\vec{x})\equiv\top.
\]

\end_inset

We opted against using this sleeker version of the QETP because the definition was already technical and complicated enough as it is,
 and we gave priority to the understandability of the definition over a minor gain in characters in the proof of applications.
\end_layout

\begin_layout Subsection
Equivalence Relations of Finite Rank
\end_layout

\begin_layout Standard
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:eqvfin"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 below was one of the main motivators for the current form of the QETP.
 We need to state a couple of important definitions first.
\end_layout

\begin_layout Definition
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Khisamiev,
 
\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "cst_downey_melnikov"
posttextlist "cst_downey_melnikov Definition 9.1.3"
literal "false"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "def:limitwisemonotonic"

\end_inset

A set 
\begin_inset Formula $X\subseteq\N$
\end_inset

 is said to be 
\emph on
limitwise monotonic
\emph default
 if there is a total computable function 
\begin_inset Formula $f\colon\N\times\N\to\N$
\end_inset

 such that,
 for every 
\begin_inset Formula $x\in\N$
\end_inset

,
 the sequence 
\begin_inset Formula $\{f(x,y)\}_{y\in\N}$
\end_inset

 is weakly increasing (i.e.
\begin_inset space \space{}
\end_inset

nondecreasing) and bounded (and therefore convergent),
 and 
\begin_inset Formula $X$
\end_inset

 is the image of the pointwise limit function 
\begin_inset Formula $g(x)=\lim_{y}f(x,y)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "cst_downey_melnikov"
posttextlist "cst_downey_melnikov Definition 9.1.1"
literal "false"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset

Let 
\begin_inset Formula $(E,\eqvrel)$
\end_inset

 be an equivalence relation.
 The 
\emph on
characteristic set of 
\begin_inset Formula $E$
\end_inset


\emph default
 is the set
\begin_inset Formula 
\[
\#E=\{\,n\in\N\mid\text{\ensuremath{E} admits at least one equivalence class of size \ensuremath{n}}\,\}.
\]

\end_inset


\end_layout

\begin_layout Proposition
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Folklore,
 
\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "cst_downey_melnikov"
posttextlist "cst_downey_melnikov Theorem 9.1.4"
literal "false"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "prop:eqvfin"

\end_inset

Let 
\begin_inset Formula $(E,\eqvrel)$
\end_inset

 be an equivalence relation with finitely many infinite equivalence classes,
 and assume that the structure 
\begin_inset Formula $(E,\eqvrel,\{P_{\geq n}\}_{n\in\N})$
\end_inset

 admits a 
\begin_inset Formula $0'$
\end_inset

-computable copy,
 where 
\begin_inset Formula $P_{\geq n}(x)$
\end_inset

 is the predicate 
\begin_inset Quotes eld
\end_inset

the equivalence class of 
\begin_inset Formula $x$
\end_inset

 has size at least 
\begin_inset Formula $n$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 Assume moreover that the characteristic set of 
\begin_inset Formula $E$
\end_inset

 is limitwise monotonic.
 Then,
 
\begin_inset Formula $(E,\eqvrel)$
\end_inset

 admits a computable copy.
\end_layout

\begin_layout Proof
Similarly but not exactly like in proof of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:eqvinf"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 our first step is to construct a 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed copy of 
\begin_inset Formula $(E,\eqvrel,\{P_{\geq n}\}_{n\in\N\cup\{\infty\}},\{P_{=n}\}_{n\in\N\cup\{\infty\}})$
\end_inset

,
 where 
\begin_inset Formula $P_{=n}(x)$
\end_inset

 denotes 
\begin_inset Quotes eld
\end_inset

the equivalence class of 
\begin_inset Formula $x$
\end_inset

 has size exactly 
\begin_inset Formula $n$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 The same construction as in the proof of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:eqvinf"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 can be used with very minor modifications.
 The added predicates are no issue,
 because when we add an element we already know its equivalence class size exactly,
 and instead of manually adding infinitely many equivalence classes,
 we add as many as 
\begin_inset Formula $E$
\end_inset

 has (a finite number which has to be obtained non-uniformly).
 It then remains to show that 
\begin_inset Formula $(E,\eqvrel,\{P_{\geq n}\}_{n\leq\infty},\{P_{=n}\}_{n\leq\infty})$
\end_inset

 has the QETP over the language containing only 
\begin_inset Formula $\eqvrel$
\end_inset

 (and its negation,
 and equality and its negation),
 though there are some added technicalities.
\end_layout

\begin_layout Proof
Throughout,
 we shall assume that 
\begin_inset Formula $E$
\end_inset

 admits arbitrarily large finite equivalence classes,
 or in other words that 
\begin_inset Formula $\#E$
\end_inset

 is an infinite set.
 The case where 
\begin_inset Formula $\#E$
\end_inset

 is finite is relatively trivial and is handled separately:
 If 
\begin_inset Formula $\#E$
\end_inset

 is finite,
 then it takes finitely much space to encode how many equivalence classes 
\begin_inset Formula $E$
\end_inset

 admits in each size,
 and we simply make a computable equivalence relation with this specification.
 We will see in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rmk:cardefinitehard"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 that this is necessary,
 and in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rmk:cardefinitewhy"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 the root cause and how to get around it.
\end_layout

\begin_layout Proof
In the following,
 we let 
\begin_inset Formula $f$
\end_inset

 be a computable function witnessing that 
\begin_inset Formula $\#E$
\end_inset

 is limitwise monotonic,
 as in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "def:limitwisemonotonic"

\end_inset

.
\end_layout

\begin_deeper
\begin_layout Itemize
To construct 
\begin_inset Formula $\chi_{q}(\vec{x})$
\end_inset

 given 
\begin_inset Formula $q(\vec{x},\vec{y})$
\end_inset

:
 The same construction as in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:eqvinf"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 holds,
 so long as,
 as therein observed,
 
\begin_inset Formula $E$
\end_inset

 is assumed to have arbitrarily large finite equivalence classes.
\end_layout

\begin_layout Itemize
To construct 
\begin_inset Formula $\tau$
\end_inset

:
 Let 
\begin_inset Formula $q(\vec{x},y,\vec{z})$
\end_inset

 range over the quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

-types realized in 
\begin_inset Formula $E$
\end_inset

,
 and let 
\begin_inset Formula $\varphi(\vec{x})$
\end_inset

 range over the possible assignments of equivalence class sizes for the elements of the tuple 
\begin_inset Formula $\vec{x}$
\end_inset

.
 For such a pair 
\begin_inset Formula $(q,\varphi)$
\end_inset

,
 set 
\begin_inset Formula $N_{0}$
\end_inset

 to be the largest finite size of equivalence class imposed by 
\begin_inset Formula $\varphi(\vec{x})$
\end_inset

,
 set 
\begin_inset Formula $N_{1}$
\end_inset

 to be the smallest size of the equivalence class of a 
\begin_inset Formula $y$
\end_inset

 that satisfies 
\begin_inset Formula $\chi_{q}(\vec{x},y)$
\end_inset

,
 and find the smallest pair 
\begin_inset Formula $(i,j)$
\end_inset

 in some fixed well-ordering of 
\begin_inset Formula $\N^{2}$
\end_inset

 that satisfies 
\begin_inset Formula $f(i,j)>\max\{N_{0},N_{1}\}$
\end_inset

.
 Then,
 set 
\begin_inset Formula $M(i)=\lim_{k}f(i,k)$
\end_inset

.
 Finally,
 we set 
\begin_inset Formula 
\[
\tau_{q\varphi}(\vec{x},y)\equiv\chi_{q}(\vec{x},y)\land\left(P_{=M(i)}(y)\lor\bigvee_{i}y\eqvrel x_{i}\right).
\]

\end_inset

.
\end_layout

\begin_layout Itemize
To construct 
\begin_inset Formula $\etau_{q\varphi Q}(\vec{x})$
\end_inset

,
 let 
\begin_inset Formula $N$
\end_inset

 be the least equivalence class size that 
\begin_inset Formula $y$
\end_inset

 would need to have in order to satisfy 
\begin_inset Formula $\chi_{Q}(y)$
\end_inset

,
 and 
\begin_inset Formula $i$
\end_inset

 the value obtained from the previous bullet point,
 and set
\begin_inset Formula 
\[
\etau_{q\varphi Q}(\vec{x})\equiv\llor_{k\in\N}\chi_{Q}(\vec{x})\land\left(\left\llbracket f(i,k)\geq N\right\rrbracket \lor\bigvee_{i}y\eqvrel x_{i}\right),
\]

\end_inset

where 
\begin_inset Formula $\llbracket f(i,k)\geq N\rrbracket$
\end_inset

 denotes
\begin_inset Formula 
\[
\llbracket f(i,k)\geq N\rrbracket\equiv\begin{cases}
\top & \text{if \ensuremath{f(i,k)\geq N},}\\
\bot & \text{otherwise.}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
As in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:eqvinf"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 checking the QETP is a straight-forward,
 if tedious,
 affair.
 The most interesting part of the proof consists of noticing that 
\begin_inset Formula $\etau_{q\varphi Q}(\vec{x})$
\end_inset

 is logically equivalent to 
\begin_inset Formula $\chi_{Q}(\vec{x})\land\left(\llbracket M(i)\geq N\rrbracket\lor\bigvee_{i}y\eqvrel x_{i}\right)$
\end_inset

,
 which uses the fact that 
\begin_inset Formula $f(i,k)$
\end_inset

 is monotonic in 
\begin_inset Formula $k$
\end_inset

.
 By application of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 the proof is complete in the case where 
\begin_inset Formula $\#E$
\end_inset

 is infinite.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Remark
Unlike in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:eqvinf"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 for 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:eqvfin"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 we can,
 in fact,
 guarantee the existence of a 
\begin_inset Formula $0'$
\end_inset

-computable isomorphism,
 albeit non-uniformly so.
 To do this,
 one picks one element of each infinite equivalence class of the original equivalence relation,
 say 
\begin_inset Formula $E_{0}$
\end_inset

,
 and hard-codes this collection of representatives into our algorithm (which is fine,
 because there are finitely many of them).
 Then,
 in the case where 
\begin_inset Formula $\#E$
\end_inset

 is infinite (the case where 
\begin_inset Formula $\#E$
\end_inset

 is finite is straightforward and left to the reader),
 one defines 
\begin_inset Formula $E_{+}$
\end_inset

 as outlined in the proof,
 and defines an isomorphism between 
\begin_inset Formula $E_{0}$
\end_inset

 and 
\begin_inset Formula $E_{+}$
\end_inset

 as follows:
 The elements of 
\begin_inset Formula $E_{0}$
\end_inset

 that belong to a finite equivalence class are mapped in an obvious way to the equivalence class they're responsible for creating,
 and the elements of 
\begin_inset Formula $E_{0}$
\end_inset

 that belong to an infinite class are detected (by checking against equivalence with one of the finitely many representatives),
 and to each infinite class of 
\begin_inset Formula $E_{0}$
\end_inset

 one remembers an infinite class of 
\begin_inset Formula $E_{+}$
\end_inset

 to biject it to,
 and does so.
 This isomorphism is 
\begin_inset Formula $0'$
\end_inset

-computable,
 and since there is also a 
\begin_inset Formula $0'$
\end_inset

-computable isomorphism between 
\begin_inset Formula $E_{+}$
\end_inset

 and the final computable equivalence relation 
\begin_inset Formula $E_{1}$
\end_inset

,
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:eqvfin"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 can in fact be made to guarantee the existence of a 
\begin_inset Formula $0'$
\end_inset

-computable isomorphism.
\end_layout

\begin_layout Remark
To show that this cannot be done uniformly,
 not even for the case where the equivalence relation 
\begin_inset Formula $E_{0}$
\end_inset

 is guaranteed to have equivalence classes of every finite size (which immediately makes 
\begin_inset Formula $\#E$
\end_inset

 uniformly limitwise monotonic) and have at most – or even exactly – one infinite equivalence class,
 one can piggyback on the proof of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:eqvcomplexiso"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 by noticing that the equivalence relation therein defined is a computable disjoint union 
\begin_inset Formula $\amalg_{i}E_{(i)}$
\end_inset

 of infinite equivalence relations with either zero or one infinite classes.
 These equivalence relations also do not have equivalence classes of every finite size,
 but since the factor that makes the isomorphism computably complicated is the designated elements of each 
\begin_inset Formula $E_{(i)}$
\end_inset

,
 we can simply append one equivalence class of each size to every 
\begin_inset Formula $E_{(i)}$
\end_inset

.
 We can also ensure that each 
\begin_inset Formula $E_{(i)}$
\end_inset

 has exactly one infinite class by,
 in the case of (in the language of the proof of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:eqvcomplexiso"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

) 
\begin_inset Formula $E_{00}$
\end_inset

,
 simply appending one infinite class,
 and in the case of each component of 
\begin_inset Formula $E_{01}$
\end_inset

,
 making all the 
\begin_inset Formula $\{b_{ni}\}_{i}$
\end_inset

 equivalent for large values of 
\begin_inset Formula $i$
\end_inset

 (instead of making them all singleton classes).
 This shows that 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:eqvfin"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 cannot be made to uniformly produce a 
\begin_inset Formula $0'$
\end_inset

-computable isomorphism,
 even restricted to the case where the equivalence relation has exactly one equivalence class of every size in 
\begin_inset Formula $\N\cup\{\infty\}$
\end_inset

.
\end_layout

\begin_layout Remark
On the flip side,
 if 
\begin_inset Formula $E_{0}$
\end_inset

 is guaranteed to have 
\emph on
no
\emph default
 infinite classes whilst still having 
\begin_inset Formula $\#E$
\end_inset

 infinite limitwise monotonic,
 we do in fact obtain uniformity
\emph on
 in 
\begin_inset Formula $E_{0}$
\end_inset

 together with a witness to the fact that 
\begin_inset Formula $\#E$
\end_inset

 is limitwise monotonic
\emph default
,
 and this is direct from the proof of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:eqvfin"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

:
 If 
\begin_inset Formula $E_{0}$
\end_inset

 has no equivalence classes,
 the isomorphism between 
\begin_inset Formula $E_{0}$
\end_inset

 and 
\begin_inset Formula $E_{+}$
\end_inset

 is easily and uniformly constructed,
 and we need the witness that 
\begin_inset Formula $\#E$
\end_inset

 is limitwise monotonic to construct 
\begin_inset Formula $\etau$
\end_inset

.
\end_layout

\begin_layout Remark
Finally,
 here is a sketch of proof that you really do need a witness to 
\begin_inset Formula $\#E$
\end_inset

 being limitwise monotonic as part of the input,
 to guarantee uniformity.
 Suppose there were a computable process 
\begin_inset Formula $F$
\end_inset

 that took as input a 
\begin_inset Formula $0'$
\end_inset

-index for an equivalence relation 
\begin_inset Formula $(E,\eqvrel,\{P_{\geq n}\}_{n\in\N})$
\end_inset

 with no infinite classes and with 
\begin_inset Formula $\#E$
\end_inset

 limitwise monotonic,
 and produced as output a computable index for 
\begin_inset Formula $(E,\eqvrel)$
\end_inset

.
 Then,
 using the Recursion Theorem relativized to 
\begin_inset Formula $0'$
\end_inset

,
 we may build an equivalence relation 
\begin_inset Formula $E$
\end_inset

 as follows:
 First,
 look at 
\begin_inset Formula $F(E)$
\end_inset

.
 We may assume WLOG that 
\begin_inset Formula $F(E)$
\end_inset

 is a well-defined index for a relational structure by appealing to 
\begin_inset Formula $0'$
\end_inset

,
 and we may assume that it represents a valid equivalence relation because there is a computable process that takes an index for a relational structure 
\begin_inset Formula $R$
\end_inset

 and outputs an index for an equivalence relation 
\begin_inset Formula $E(R)$
\end_inset

 such that,
 if 
\begin_inset Formula $R$
\end_inset

 was already an equivalence relation then 
\begin_inset Formula $E(R)\cong R$
\end_inset

.
 Now,
 using 
\begin_inset Formula $0'$
\end_inset

,
 ask whether 
\begin_inset Formula $F(E)$
\end_inset

 contains any elements.
 If not,
 set 
\begin_inset Formula $E$
\end_inset

 to consist of one equivalence class of every size.
 If yes,
 pick an element and repeatedly ask:
 Does the equivalence class of this element have size at least 
\begin_inset Formula $n+1$
\end_inset

?
 Whenever the answer is 
\begin_inset Quotes els
\end_inset

yes
\begin_inset Quotes ers
\end_inset

,
 add an equivalence class of size 
\begin_inset Formula $n$
\end_inset

 to 
\begin_inset Formula $E$
\end_inset

.
 If the answer is ever seen to be 
\begin_inset Quotes els
\end_inset

no
\begin_inset Quotes ers
\end_inset

,
 this implies that the equivalence class of this element has size exactly 
\begin_inset Formula $n$
\end_inset

,
 and so we 
\emph on
do not
\emph default
 add an equivalence class of this size,
 but add an equivalence class of every other size.
 It should be clear that this ensures that 
\begin_inset Formula $E$
\end_inset

 is not isomorphic to 
\begin_inset Formula $F(E)$
\end_inset

 despite the fact that 
\begin_inset Formula $E$
\end_inset

 admits no infinite equivalence classes and 
\begin_inset Formula $\#E$
\end_inset

 is either 
\begin_inset Formula $\N$
\end_inset

 or 
\begin_inset Formula $\N$
\end_inset

 minus a point,
 and hence limitwise monotonic.
 This is a contradiction,
 which shows that such a computable 
\begin_inset Formula $F$
\end_inset

 cannot exist.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rmk:cardefinitehard"

\end_inset

The fact that we have handled the 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\#E$
\end_inset

 is finite
\begin_inset Quotes erd
\end_inset

 case separately (and non-uniformly) is unavoidable,
 and here is why.
 We claim that there is no uniform way to turn an index for a 
\begin_inset Formula $0'$
\end_inset

-computable equivalence relation 
\begin_inset Formula $(E,\eqvrel,\{P_{\geq n}\}_{n\in\N})$
\end_inset

,
 even one with no infinite equivalence classes,
 into a computable index for 
\begin_inset Formula $(E,\eqvrel)$
\end_inset

.
 In fact,
 we prove the even stronger fact:
 Any oracle 
\begin_inset Formula $X$
\end_inset

 that is capable of uniformly turning a 
\begin_inset Formula $0'$
\end_inset

-computable equivalence relation 
\begin_inset Formula $(E,\eqvrel,\{P_{\geq n}\}_{n\in\N})$
\end_inset

 with infinitely many singleton classes,
 and either one or two size-two equivalence classes
\begin_inset Foot
status open

\begin_layout Plain Layout
Note that this means 
\begin_inset Formula $\#E=\{1,2\}$
\end_inset

,
 and in particular is uniformly limitwise monotonic.
\end_layout

\end_inset

,
 and no classes of any other size,
 into a computable index for 
\begin_inset Formula $(E,\eqvrel)$
\end_inset

,
 may be used to compute 
\begin_inset Formula $0''$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
Suppose we wish to determine if a computable function 
\begin_inset Formula $f(x)$
\end_inset

 is total.
 First,
 note that we can uniformly (and computably) create an index for a 
\begin_inset Formula $0'$
\end_inset

-computable equivalence relation 
\begin_inset Formula $(E,\eqvrel,\{P_{\geq n}\}_{n\in\N})$
\end_inset

 that is composed entirely of infinitely many singletons and one size-two class,
 unless a value of 
\begin_inset Formula $x$
\end_inset

 is exists for which 
\begin_inset Formula $f(x)\isnotwd$
\end_inset

,
 in which case we add a second equivalence class with two elements.
 Then,
 using the oracle 
\begin_inset Formula $X$
\end_inset

,
 we create a computable index for 
\begin_inset Formula $(E,\eqvrel)$
\end_inset

.
 Computably,
 we can search in 
\begin_inset Formula $E$
\end_inset

 for two distinct pairs of distinct but equivalent elements.
 We will find two if,
 and only if,
 
\begin_inset Formula $f$
\end_inset

 is nontotal.
 This shows that 
\begin_inset Formula $X$
\end_inset

 enumerates the set of nontotal indices,
 which straightforwardly implies 
\begin_inset Formula $X\geq0'$
\end_inset

.
 Thus,
 instead of computably searching in 
\begin_inset Formula $E$
\end_inset

 for two pairs of distinct elements,
 
\begin_inset Formula $X$
\end_inset

 can check in finite time if such a elements exist,
 and thus determine whether 
\begin_inset Formula $f$
\end_inset

 is total.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rmk:cardefinitewhy"

\end_inset

A way to understand what makes equivalence classes with finite characteristic set so computationally hard to handle is the following intuition:
 A computable copy of 
\begin_inset Formula $(E,\eqvrel)$
\end_inset

 contains more descriptive power,
 from the perspective of 
\begin_inset Formula $0'$
\end_inset

,
 than a 
\begin_inset Formula $0'$
\end_inset

-computable copy of 
\begin_inset Formula $(E,\eqvrel,\{P_{\geq n}\}_{n\in\N})$
\end_inset

.
 In other words,
 there is computational content that 
\begin_inset Formula $0'$
\end_inset

 can read off from a computable copy of 
\begin_inset Formula $(E,\eqvrel)$
\end_inset

 that it could not read off from a 
\begin_inset Formula $0'$
\end_inset

-computable copy of 
\begin_inset Formula $(E,\eqvrel,\{P_{\geq n}\}_{n})$
\end_inset

,
 and an example of such content is the answer to the questions:
 
\begin_inset Quotes eld
\end_inset

Is there an equivalence relation in 
\begin_inset Formula $E$
\end_inset

 of size greater than or equal to 
\begin_inset Formula $n$
\end_inset

?
\begin_inset Quotes erd
\end_inset

 or,
 more generally,
 
\begin_inset Quotes eld
\end_inset

Are there at least 
\begin_inset Formula $k$
\end_inset

 equivalence relations in 
\begin_inset Formula $E$
\end_inset

 of size 
\begin_inset Formula $\geq n$
\end_inset

?
\begin_inset Quotes erd
\end_inset

 As such,
 knowledge of the answer to these questions is a necessary condition to be able to turn a 
\begin_inset Formula $0'$
\end_inset

-computable copy of 
\begin_inset Formula $E$
\end_inset

 into a computable copy thereof,
 because the answer to these questions 
\emph on
can
\emph default
 be computed using 
\begin_inset Formula $0'$
\end_inset

 from the computable copy.
 This explains what makes the case with infinitely many equivalence relations,
 or with arbitrarily large finite equivalence classes,
 computationally easy to handle:
 The answer to these questions is always 
\begin_inset Quotes els
\end_inset

yes
\begin_inset Quotes ers
\end_inset

.
 Moreover,
 the answer to these questions is always simple enough that it can be encoded in finitely many bits of information,
 and hence could be non-uniformly hardcoded into an algorithm to obtain a computable copy of 
\begin_inset Formula $(E,\eqvrel)$
\end_inset

,
 but the fact that this cannot be done uniformly explains why 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:eqvfin"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 cannot be made uniform as it is.
\end_layout

\begin_layout Subsection
Khisamiev's Theorem
\end_layout

\begin_layout Standard
The following theorem is in the literature,
 see e.g.
 Chapter 5 of 
\begin_inset CommandInset citation
LatexCommand cite
key "cst_downey_melnikov"
literal "false"

\end_inset

.
 We obtain it as a corollary of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
 It was the main motivator for the definition of 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed structure.
\end_layout

\begin_layout Standard
In the following,
 we interpret a c.e.
\begin_inset space \space{}
\end_inset

presentation of a group as being a description of the group as a list of generators and relations,
 such that there is a computer program that enumerates the list of generators and relations.
 In the present case,
 this is equivalent to the more general notion of c.e.
\begin_inset space \space{}
\end_inset

presentation of a structure in computability theory.
\end_layout

\begin_layout Theorem
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Khisamiev
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "thm:khisamiev"

\end_inset

Every c.e.
\begin_inset space \space{}
\end_inset

presented torsion-free abelian group is isomorphic to a computable group.
 Furthermore,
 if the group is non-trivial,
 then this computable copy can be built uniformly in the index of the c.e.
\begin_inset space \space{}
\end_inset

presentation.
\end_layout

\begin_layout Proof
Given a c.e.
\begin_inset space \space{}
\end_inset

presentation of a group 
\begin_inset Formula $G$
\end_inset

,
 we first build a 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed copy of 
\begin_inset Formula $G$
\end_inset

 over an appropriate signature 
\begin_inset Formula $\Lang'$
\end_inset

,
 and we will then show that any nontrivial torsion-free abelian group has the QETP (uniformly) over 
\begin_inset Formula $\Lang\subseteq\Lang'$
\end_inset

,
 where 
\begin_inset Formula $\Lang$
\end_inset

 is the signature containing only the ternary predicate 
\begin_inset Formula $S(x,y,z)\equiv\text{``\ensuremath{x+y=z}''}$
\end_inset

(and its negation,
 and equality and its negation).
\end_layout

\begin_layout Proof
The signature 
\begin_inset Formula $\Lang'$
\end_inset

 shall contain 
\begin_inset Formula $\Lang$
\end_inset

,
 plus:
\end_layout

\begin_deeper
\begin_layout Itemize
The countably many predicates 
\begin_inset Formula $Q_{n,\vec{c}}(\vec{x})$
\end_inset

,
 parametrized over 
\begin_inset Formula $n\in\N$
\end_inset

 and finite tuples 
\begin_inset Formula $c_{1},\dots,c_{k}\in\Z$
\end_inset

:
\begin_inset Formula 
\[
Q_{n,\vec{c}}(\vec{x})\equiv\text{``\ensuremath{n\mid c_{1}x_{1}+\dots+c_{k}x_{k}}''}.
\]

\end_inset

Note that we allow 
\begin_inset Formula $n$
\end_inset

 to equal zero,
 in which case (since 
\begin_inset Formula $0\mid y$
\end_inset

 iff 
\begin_inset Formula $y=0$
\end_inset

) 
\begin_inset Formula $Q_{0,\vec{c}}(\vec{x})$
\end_inset

 corresponds to the predicate 
\begin_inset Formula $\vec{c}\cdot\vec{x}=0$
\end_inset

.
\end_layout

\begin_layout Itemize
The countably many predicates 
\begin_inset Formula $\neg Q_{0,\vec{c}}(\vec{x})$
\end_inset

,
 parametrized over finite tuples 
\begin_inset Formula $c_{1},\dots,c_{k}\in\Z$
\end_inset

:
\begin_inset Formula 
\[
\neg Q_{0,\vec{c}}(\vec{x})\equiv\text{``\ensuremath{c_{1}x_{1}+\dots+c_{k}x_{k}\neq0}''}.
\]

\end_inset


\end_layout

\begin_layout Itemize
Countably many predicates 
\begin_inset Formula $\{n\Delta(x)\}_{n\in\Z}$
\end_inset

,
 whose meaning is as follows:
 We will carefully pick a single designated nonzero element of 
\begin_inset Formula $G$
\end_inset

,
 which we refer to as 
\begin_inset Formula $\delta$
\end_inset

,
 and 
\begin_inset Formula $n\Delta(x)$
\end_inset

 should be interpreted as 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $x=n\delta$
\end_inset


\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_deeper
\begin_layout Proof
We shall require some linear algebra of 
\begin_inset Formula $\Z$
\end_inset

-modules to show that,
 from a c.e.
\begin_inset space \space{}
\end_inset

presentation of 
\begin_inset Formula $G$
\end_inset

,
 we can uniformly obtain a 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed copy of 
\begin_inset Formula $G$
\end_inset

.
 Then,
 we will explain how we choose the element of 
\begin_inset Formula $G$
\end_inset

 that will be tagged with 
\begin_inset Formula $\Delta$
\end_inset

.
 To obtain the 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed copy of 
\begin_inset Formula $G$
\end_inset

,
 here is the basic idea:
 Consider the computable process that outputs all possible linear combinations of generators.
 We want to,
 with each new linear combination of generators,
 say 
\begin_inset Formula $d$
\end_inset

,
 first check whether it is equal to any of the combinations previously produced (this is an easy check with 
\begin_inset Formula $0'$
\end_inset

),
 and if it is not,
 we want to output a c.e.
\begin_inset space \space{}
\end_inset

index for its type relative to the elements previously output.
 This is easy for the positive predicates – to check if,
 for example,
 
\begin_inset Formula $5\mid4d+6c$
\end_inset

 (where 
\begin_inset Formula $c$
\end_inset

 is a previously output combination of generators),
 it suffices to check if there is a further combination of generators 
\begin_inset Formula $u$
\end_inset

 that satisfies the relation 
\begin_inset Formula $5u-4d-6c=0$
\end_inset

.
 This is a c.e.
\begin_inset space \space{}
\end_inset

check.
 The difficulty lies in the negative predicates,
 of which 
\begin_inset Formula $\neg Q_{0,\vec{c}}(\vec{x})$
\end_inset

 is the general case.
 In other words,
 we need to encode 
\emph on
into a single c.e.
\begin_inset space \space{}
\end_inset

index
\emph default
 the full information about what linear combinations of elements-output-thus-far equal zero.
\end_layout

\begin_layout Proof
Here is a fact from commutative algebra,
 whose proof can be found in any standard book that covers modules over principal ideal domains (e.g.
\begin_inset space \space{}
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "dummit_foote"
literal "false"

\end_inset

):
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

label={Fact 
\backslash
Alph*}
\end_layout

\end_inset


\end_layout

\end_inset

Any submodule 
\begin_inset Formula $M$
\end_inset

 of 
\begin_inset Formula $\Z^{k}$
\end_inset

 admits a finite basis.
\end_layout

\begin_layout Standard
We will need an effective version of this fact.
 A stepping stone,
 which we will not directly use but displays the main idea,
 is the following:
\end_layout

\begin_layout Enumerate-Resume
\begin_inset CommandInset label
LatexCommand label
name "enu:gauss"

\end_inset

Given a finite set 
\begin_inset Formula $X\subseteq\Z^{k}$
\end_inset

,
 we can effectively find a basis for the submodule of 
\begin_inset Formula $\Z^{k}$
\end_inset

 generated by 
\begin_inset Formula $X$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
Proof idea:
 A slight modification of the usual Gaussian elimination algorithm,
 applied to the matrix whose rows are the elements of 
\begin_inset Formula $X$
\end_inset

.
 To zero out entries below a pivot,
 instead of dividing to turn the pivot element into 
\begin_inset Formula $1$
\end_inset

,
 use the Euclidean algorithm to turn the pivot into the GCD of itself with all elements beneath it,
 whereupon all elements beneath it may be zeroed out.
\end_layout

\end_deeper
\begin_layout Standard
Now we are ready to state and prove the version we will use:
\end_layout

\begin_layout Enumerate-Resume
\begin_inset CommandInset label
LatexCommand label
name "enu:cemodulebasis"

\end_inset

Given a c.e.
\begin_inset space \space{}
\end_inset

index for a submodule 
\begin_inset Formula $M$
\end_inset

 of 
\begin_inset Formula $\Z^{k}$
\end_inset

,
 we may 
\begin_inset Formula $0'$
\end_inset

-effectively find a basis of 
\begin_inset Formula $M$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
Proof idea:
 Consider the 
\begin_inset Formula $k$
\end_inset

-width and possibly-infinite-height matrix whose rows are the elements of 
\begin_inset Formula $M$
\end_inset

.
 Use 
\begin_inset Formula $0'$
\end_inset

 to find the GCD of the elements of the first column,
 call it 
\begin_inset Formula $d$
\end_inset

.
 If 
\begin_inset Formula $d=0$
\end_inset

 (i.e.
\begin_inset space \space{}
\end_inset

all elements of the first column are zero),
 skip to the next step.
 If 
\begin_inset Formula $d\neq0$
\end_inset

,
 find a combination of rows of 
\begin_inset Formula $M$
\end_inset

 that has 
\begin_inset Formula $d$
\end_inset

 in its first coordinate,
 and add this combination to the basis.
 Then,
 if 
\begin_inset Formula $k\geq1$
\end_inset

,
 recursively apply this algorithm to the 
\begin_inset Formula $(k-1)$
\end_inset

-width and possibly-infinite-height matrix whose elements consist of the rows of the previous matrix that have a 
\begin_inset Formula $0$
\end_inset

 as a first entry.
 Upon finding a combination of rows that has the new GCD as its first coordinates,
 add the corresponding combination of the rows of the original matrix to the basis.
 After 
\begin_inset Formula $k$
\end_inset

 steps,
 one shall have a basis of 
\begin_inset Formula $M$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
Returning to our original problem:
 We have a collection of combinations of generators,
 say 
\begin_inset Formula $d_{0}$
\end_inset

,
 
\begin_inset Formula $d_{1}$
\end_inset

,
 
\begin_inset Formula $\dots$
\end_inset

,
 
\begin_inset Formula $d_{k}$
\end_inset

,
 and we wish to encode all possible linear combinations of these elements that yield zero.
 We do this by applying 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:cemodulebasis"

\end_inset

 to the c.e.
\begin_inset space \space{}
\end_inset

submodule of 
\begin_inset Formula $\Z^{k+1}$
\end_inset

 given by
\begin_inset Formula 
\[
M=\{\,\vec{c}\in\Z^{k+1}\mid\vec{c}\cdot\vec{d}=0\,\}.
\]

\end_inset

With access to a basis of 
\begin_inset Formula $M$
\end_inset

,
 say 
\begin_inset Formula $b_{1},\dots,b_{\ell}$
\end_inset

 (encoded into the columns of a matrix 
\begin_inset Formula $B$
\end_inset

),
 we can tell whether any set of coefficients 
\begin_inset Formula $\vec{c}$
\end_inset

 is in 
\begin_inset Formula $M$
\end_inset

 (and hence,
 whether we should say yes or no to 
\begin_inset Formula $Q_{0,\vec{c}}(\vec{d})$
\end_inset

) by using standard algorithms to solve the linear equation 
\begin_inset Formula $B\vec{x}=\vec{c}$
\end_inset

 over 
\begin_inset Formula $\Q$
\end_inset

,
 and conclude 
\begin_inset Formula $\vec{c}\in M$
\end_inset

 if and only if a solution exists and its coefficients are all integers.
 By hardcoding this basis into a c.e.
\begin_inset space \space{}
\end_inset

index,
 we can therefore obtain a c.e.
\begin_inset space \space{}
\end_inset

index for the atomic 
\begin_inset Formula $\Lang'$
\end_inset

-type of a tuple 
\begin_inset Formula $\vec{d}$
\end_inset

 of linear combinations of generators.
\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
Now,
 let us explain how to choose the element 
\begin_inset Formula $\delta$
\end_inset

,
 which we shall use to decide the predicates 
\begin_inset Formula $n\Delta$
\end_inset

.
 Of course,
 this has to have been done in advance,
 so that we can hardcode the combination of generators corresponding to 
\begin_inset Formula $\delta$
\end_inset

 into the c.e.
\begin_inset space \space{}
\end_inset

indices of the types of the elements of 
\begin_inset Formula $G$
\end_inset

 in advance.
\end_layout

\begin_layout Standard
There is an easy way and a hard way to choose 
\begin_inset Formula $\delta$
\end_inset

.
 The easy way is simply to pick an arbitrary nonzero element of 
\begin_inset Formula $G$
\end_inset

.
 The issue is that to make this choice requires the usage of an oracle for 
\begin_inset Formula $0'$
\end_inset

,
 which will lead to a non-uniform presentation.
 Nevertheless,
 if one is not interested in uniformity,
 one may move on and ignore the difficult but uniform way to choose the element that we will now propose.
\end_layout

\begin_layout Standard
Consider the following schema:
 Let 
\begin_inset Formula $\{C_{i}\}_{i\in\N}$
\end_inset

 enumerate all possible combinations of generators.
 To start,
 we will guess 
\begin_inset Formula $\delta=C_{0}$
\end_inset

,
 and look through the relations until (if ever) we see enough relations to conclude 
\begin_inset Formula $C_{0}=0$
\end_inset

.
 When this happens,
 we will guess 
\begin_inset Formula $\delta=N_{1}C_{1}$
\end_inset

,
 where 
\begin_inset Formula $N_{1}$
\end_inset

 is a nonzero number divisible by enough integers.
 This choice is made so that,
 for every number 
\begin_inset Formula $k$
\end_inset

 for which we'd been able to conclude 
\begin_inset Formula $k\mid C_{0}$
\end_inset

 before we found that 
\begin_inset Formula $C_{0}=0$
\end_inset

,
 we have 
\begin_inset Formula $k\mid N_{1}$
\end_inset

 and so 
\begin_inset Formula $k\mid N_{1}C_{1}$
\end_inset

.
 We proceed in this manner,
 enumerating relations until we are able to conclude that 
\begin_inset Formula $N_{1}C_{1}=0$
\end_inset

,
 or equivalently that 
\begin_inset Formula $C_{1}=0$
\end_inset

.
 If this happens,
 we change our mind to guess 
\begin_inset Formula $\delta=N_{2}C_{2}$
\end_inset

,
 where 
\begin_inset Formula $N_{2}$
\end_inset

 has enough divisibilities that,
 again,
 every divisibility we'd already concluded about 
\begin_inset Formula $N_{1}C_{1}$
\end_inset

 also holds for 
\begin_inset Formula $N_{2}$
\end_inset

 and hence 
\begin_inset Formula $N_{2}C_{2}$
\end_inset

.
 Since,
 by assumption,
 
\begin_inset Formula $G$
\end_inset

 is a nontrivial group,
 eventually this procedure will run into a nonzero combination of generators,
 and 
\begin_inset Formula $0'$
\end_inset

 is able to figure out which element is 
\begin_inset Formula $\delta$
\end_inset

 in advance.
\end_layout

\begin_layout Standard
The reader may be wondering in what respect this procedure is more uniform.
 After all,
 the limiting combination of generators 
\begin_inset Formula $N_{M}C_{M}$
\end_inset

 cannot be computed uniformly,
 only 
\begin_inset Formula $0'$
\end_inset

-uniformly.
 However,
 and crucially,
 we can uniformly compute a c.e.
\begin_inset space \space{}
\end_inset

index for the type of the limiting combination of generators 
\begin_inset Formula $\delta$
\end_inset

 as follows:
 follow along the procedure used to find 
\begin_inset Formula $\delta$
\end_inset

,
 and every time we conclude a new divisibility for (the current guess for) 
\begin_inset Formula $\delta$
\end_inset

,
 we add this divisibility to its type.
 We took care so that any divisibility we add never needs to be removed.
 The predicates 
\begin_inset Formula $\neg Q_{0,c}(x)$
\end_inset

 are all true except for 
\begin_inset Formula $\neg Q_{0,0}(x)$
\end_inset

 because the group is torsion-free,
 and thus,
 adding those to the type,
 we obtain an enumeration of the type of 
\begin_inset Formula $\delta$
\end_inset

.
\end_layout

\begin_layout Standard
Below,
 we shall be using the type of 
\begin_inset Formula $\delta$
\end_inset

 in an essential way (namely,
 to compute 
\begin_inset Formula $\etau$
\end_inset

),
 which is why having a uniform way to compute this type is essential.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset

Now that we have a 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed copy of our group over the signature 
\begin_inset Formula $\Lang'$
\end_inset

,
 we shall show that every nontrivial torsion-free abelian group with a designated nonzero element with c.e.
\begin_inset space \space{}
\end_inset

atomic type satisfies the QETP.
\end_layout

\begin_layout Itemize
First,
 we construct 
\begin_inset Formula $\chi_{q}$
\end_inset

.
 This is an adaptation of the standard proof that the theory of torsion-free abelian groups with divisibility-by-integer predicates admits quantifier elimination,
 which can be found e.g.
\begin_inset space \space{}
\end_inset

in 
\begin_inset CommandInset citation
LatexCommand cite
key "hodges_model_theory"
posttextlist "hodges_model_theory Appendix A.2"
literal "false"

\end_inset

.
 Very briefly:
\end_layout

\begin_deeper
\begin_layout Itemize
Assume without loss of generality that 
\begin_inset Formula $q(\vec{x},\vec{y})$
\end_inset

 is a disjunction of atomic formulas (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rmk:assumeq"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

),
 and hence can be expressed as a system of integer coefficient equations and inequations
\begin_inset Formula 
\[
q(\vec{x},\vec{y})\equiv\left\{ \begin{array}{l}
M\vec{x}=N\vec{y},\\
K\vec{x}\neq L\vec{y}.
\end{array}\right.
\]

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Important:

\series default
 The notation 
\begin_inset Formula $K\vec{x}\neq L\vec{y}$
\end_inset

 is 
\emph on
not
\emph default
 being used two mean 
\begin_inset Quotes eld
\end_inset

the vectors 
\begin_inset Formula $K\vec{x}$
\end_inset

 and 
\begin_inset Formula $L\vec{y}$
\end_inset


\begin_inset Quotes erd
\end_inset

 are distinct,
 but rather the stronger fact:
 
\begin_inset Quotes eld
\end_inset

every entry of the vector 
\begin_inset Formula $K\vec{x}$
\end_inset

 is distinct from the corresponding entry in 
\begin_inset Formula $L\vec{y}$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 This means that one must not be careless in handling these inequalities – one cannot,
 for example,
 apply any kind of Gaussian elimination thereto.
\end_layout

\end_deeper
\begin_layout Itemize
Now,
 write 
\begin_inset Formula $N=ADB$
\end_inset

,
 where 
\begin_inset Formula $D$
\end_inset

 is a diagonal matrix padded with zeros (i.e.
\begin_inset space \space{}
\end_inset

of the form 
\begin_inset Formula $\left[\begin{smallmatrix}D_{0} & 0\\
0 & 0
\end{smallmatrix}\right]$
\end_inset

 with 
\begin_inset Formula $D_{0}$
\end_inset

 diagonal) and 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 are invertible,
 all over the integers – this can always be done using a strategy like the one from 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:gauss"

\end_inset

,
 see e.g.
\begin_inset space \space{}
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "bapat_graphs_matrices"
posttextlist "bapat_graphs_matrices Theorem 2.12"
literal "false"

\end_inset

.
 Then,
 
\begin_inset Formula $q(\vec{x},\vec{y})$
\end_inset

 is logically equivalent to a new system of equations and inequations
\begin_inset Formula 
\[
q(\vec{x},\vec{y})\Leftrightarrow\left\{ \begin{array}{l}
M'\vec{x}=DB\vec{y},\\
K'\vec{x}\neq LB^{-1}B\vec{y}.
\end{array}\right.
\]

\end_inset


\end_layout

\begin_layout Itemize
The existence of a solution to this system is,
 since 
\begin_inset Formula $B$
\end_inset

 is invertible,
 equivalent to the existence of a solution to the following other system
\begin_inset Formula 
\[
\exists_{\vec{y}}q(\vec{x},\vec{y})\Leftrightarrow\exists_{\vec{z}}\left\{ \begin{array}{l}
M'\vec{x}=D\vec{z},\\
K'\vec{x}\neq L'\vec{z}.
\end{array}\right.
\]

\end_inset


\end_layout

\begin_layout Itemize
The rows of the equation 
\begin_inset Formula $M'\vec{x}=D\vec{z}$
\end_inset

 that have nonzero entries of 
\begin_inset Formula $D$
\end_inset

 yield equations of the type 
\begin_inset Formula $nz_{i}=\vec{a}\cdot\vec{x}$
\end_inset

.
 This allows us to remove (whilst preserving logical equivalence) every instance of 
\begin_inset Formula $z_{i}$
\end_inset

 from every other (in)equation:
 Any other (in)equation can be multiplied by 
\begin_inset Formula $n$
\end_inset

 preserving logical equivalence (this uses 
\begin_inset Formula $n\neq0$
\end_inset

 and the fact that we're working with torsion-free groups),
 resulting in an instance of 
\begin_inset Formula $\text{(coefficient)\ensuremath{\times}}nz_{i}$
\end_inset

,
 which can be substituted for 
\begin_inset Formula $\text{(coefficient)}\times(\sum a_{i}x_{i})$
\end_inset

.
 Thus,
 we may eliminate all 
\begin_inset Formula $z$
\end_inset

 variables corresponding to nonzero rows of 
\begin_inset Formula $D$
\end_inset

,
 and our system now becomes
\begin_inset Formula 
\[
\exists_{\vec{y}}q(\vec{x},\vec{y})\Leftrightarrow\exists_{\vec{z}}\exists_{\vec{w}}\left\{ \begin{array}{l}
M_{0}\vec{x}=0,\\
n_{1}z_{1}=\vec{c}_{1}\cdot\vec{x},\\
\vdots\\
n_{\ell}z_{\ell}=\vec{c}_{\ell}\cdot\vec{x},\\
K'\vec{x}\neq L'\vec{w}.
\end{array}\right.
\]

\end_inset


\end_layout

\begin_layout Itemize
The equations including the 
\begin_inset Formula $z$
\end_inset

 variables become divisibility statements,
 i.e.
\begin_inset space \space{}
\end_inset


\begin_inset Formula $\exists_{z_{i}}nz_{i}=\vec{c}\cdot\vec{x}\Leftrightarrow n\mid\vec{c}\cdot\vec{x}\equiv Q_{n,\vec{c}}(\vec{x})$
\end_inset

,
 so we now need only deal with the inequations 
\begin_inset Formula $K'\vec{x}\neq L'\vec{w}$
\end_inset

.
\end_layout

\begin_layout Itemize
Now,
 let us stratify the equations 
\begin_inset Formula $K'\vec{x}\neq L'\vec{w}$
\end_inset

 as follows:
 First,
 consider the equations that use no 
\begin_inset Formula $w$
\end_inset

-variable.
 Then,
 consider the ones that use 
\begin_inset Formula $w_{1}$
\end_inset

 and no other.
 Then,
 consider the ones that use only 
\begin_inset Formula $w_{1}$
\end_inset

 and 
\begin_inset Formula $w_{2}$
\end_inset

,
 and so on.
 The equations that use no 
\begin_inset Formula $w$
\end_inset

-variable are important – keep them.
 These are a requirement on 
\begin_inset Formula $\vec{x}$
\end_inset

 that we cannot get rid of.
 Let us refer to these equations as 
\begin_inset Formula $K_{0}\vec{x}\neq0$
\end_inset

.
 On the other hand,
 at every new stage of the strata,
 the resulting equations will doubtlessly be satisfied by some 
\begin_inset Formula $w_{i}$
\end_inset

.
 For example,
 if the first stratum has 
\begin_inset Formula $e$
\end_inset

 equations,
 this is forbidding at most 
\begin_inset Formula $e$
\end_inset

 possible values of 
\begin_inset Formula $w_{1}$
\end_inset

.
 But the group is nontrivial and hence infinite,
 whereby there is at least one valid choice for 
\begin_inset Formula $w_{1}$
\end_inset

.
 Then,
 in the next stratum,
 contingent on this choice of 
\begin_inset Formula $w_{1}$
\end_inset

,
 there are once again at most (number of equations) forbidden values for 
\begin_inset Formula $w_{2}$
\end_inset

.
 Simply choose 
\begin_inset Formula $w_{2}$
\end_inset

 to not be one of those.
 Continuing in this manner,
 we see that we can ensure that all equations that include a 
\begin_inset Formula $w$
\end_inset

 variable can be automatically satisfied and are therefore adding no information.
\end_layout

\begin_layout Itemize
In conclusion,
 we've shown that any existential statement is equivalent to a system of the type
\begin_inset Formula 
\begin{equation}
\exists_{\vec{y}}q(\vec{x},\vec{y})\Leftrightarrow\left\{ \begin{array}{l}
M_{0}\vec{x}=0,\\
n_{1}\mid\vec{c}_{1}\cdot\vec{x},\\
\vdots\\
n_{\ell}\mid\vec{c}_{\ell}\cdot\vec{x},\\
K_{0}\vec{x}\neq0,
\end{array}\right.\label{eq:syseqchi}
\end{equation}

\end_inset

with the system found effectively,
 and thus it is in this manner that we define 
\begin_inset Formula $\chi_{q}(\vec{x})$
\end_inset

.
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $q$
\end_inset

 were not a disjunction of atomic formulas,
 as initially assumed,
 write it in conjunctive normal form as 
\begin_inset Formula $q\equiv q_{1}\lor\dots\lor q_{k}$
\end_inset

 and set 
\begin_inset Formula $\chi_{q}\equiv\chi_{q_{1}}\lor\dots\lor\chi_{q_{k}}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
Next,
 we construct 
\begin_inset Formula $\tau$
\end_inset

.
 Intuitively,
 given 
\begin_inset Formula $q(\vec{x},y,\vec{z})$
\end_inset

,
 we consider all possible assignments of 
\begin_inset Formula $y$
\end_inset

 of the form 
\begin_inset Formula $y=\frac{1}{a}\vec{c}\cdot\vec{x}$
\end_inset

 (if such an element exists).
 We will prove below,
 when establishing the QETP,
 that assuming not every element of 
\begin_inset Formula $\vec{x}$
\end_inset

 is null there is such a combination that satisfies 
\begin_inset Formula $\chi_{q}(\vec{x},\frac{1}{a}\vec{c}\cdot\vec{x})$
\end_inset

.
 We will choose one such combination,
 and set 
\begin_inset Formula $\tau_{q\varphi}(\vec{x},y)\equiv(ay=\vec{c}\cdot\vec{x}$
\end_inset

).
 We also need to handle the case where every element of the tuple 
\begin_inset Formula $\vec{x}$
\end_inset

 is zero (which will generally happen if the tuple is empty,
 or if it contains a single element that happens to be zero),
 which is why we have the designated element 
\begin_inset Formula $\delta$
\end_inset

 – if every element of 
\begin_inset Formula $\vec{x}$
\end_inset

 is null,
 we set 
\begin_inset Formula $\tau(\vec{x},y)\equiv N\Delta(y)$
\end_inset

 where 
\begin_inset Formula $N$
\end_inset

 is large enough to encompass all divisibilities demanded by the tuple of elements 
\begin_inset Formula $\vec{z}$
\end_inset

 (e.g.
\begin_inset space \space{}
\end_inset

if 
\begin_inset Formula $q(y,z)\equiv(z+z=y)$
\end_inset

,
 we would set 
\begin_inset Formula $y=2\delta$
\end_inset

).
\end_layout

\begin_deeper
\begin_layout Standard
Let's discuss this process more formally.
 Given 
\begin_inset Formula $q(\vec{x},y,\vec{z})$
\end_inset

:
\end_layout

\begin_layout Itemize
Set 
\begin_inset Formula $\varphi_{0}(\vec{x})\equiv\land_{i}(x_{i}=0)$
\end_inset

 (or,
 if we are being unnecessarily precise,
 
\begin_inset Formula $\varphi_{0}(\vec{x})\equiv\land_{i}Q_{0,1}(x_{i})$
\end_inset

),
 and set 
\begin_inset Formula $\tau_{q\varphi_{0}}(\vec{x},y)\equiv\varphi_{0}(\vec{x})\land N\Delta(y)$
\end_inset

,
 where 
\begin_inset Formula $N$
\end_inset

 is large enough to ensure 
\begin_inset Formula $\forall_{d}\chi_{q}(\vec{0},Nd)$
\end_inset

.
\end_layout

\begin_layout Itemize
For every nonzero integer 
\begin_inset Formula $a$
\end_inset

 and tuple of integers 
\begin_inset Formula $\vec{c}$
\end_inset

,
 set 
\begin_inset Formula $\varphi_{a\vec{c}}(\vec{x})\equiv\text{``\ensuremath{\chi_{q}(\vec{x},\frac{1}{a}\vec{c}\cdot\vec{x})}''}$
\end_inset

 and 
\begin_inset Formula $\tau_{q\varphi_{a\vec{c}}}(\vec{x},y)\equiv(ay=\vec{c}\cdot\vec{x})$
\end_inset

.
 It remains to explain what we mean by 
\begin_inset Formula $\chi_{q}(\vec{x},\frac{1}{a}\vec{c}\cdot\vec{x})$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
Since 
\begin_inset Formula $q$
\end_inset

 is assumed to be a type,
 we have by definition that 
\begin_inset Formula $\chi_{q}(\vec{x},y)$
\end_inset

 is a system of equations as in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:syseqchi"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
 By multiplying all equations by 
\begin_inset Formula $a$
\end_inset

,
 we obtain an equivalent system of equations where every instance of 
\begin_inset Formula $y$
\end_inset

 is being multiplied by 
\begin_inset Formula $a$
\end_inset

.
 In other words,
 we can rewrite 
\begin_inset Formula $\chi_{q}(\vec{x},y)\Leftrightarrow\psi(\vec{x},ay)$
\end_inset

,
 and thus the formula 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\chi_{q}(\vec{x},\frac{1}{a}\vec{c}\cdot\vec{x})$
\end_inset


\begin_inset Quotes erd
\end_inset

 may be taken to mean
\begin_inset Formula 
\[
\text{``\ensuremath{\chi_{q}(\vec{x},\frac{1}{a}\vec{c}\cdot\vec{x})}''}\equiv(a\mid\vec{c}\cdot\vec{x})\land\psi(\vec{x},\vec{c}\cdot\vec{x}).
\]

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Finally,
 we construct 
\begin_inset Formula $\etau$
\end_inset

.
 Given 
\begin_inset Formula $q(\vec{x},y,\vec{z})$
\end_inset

 and 
\begin_inset Formula $\varphi(\vec{x})$
\end_inset

 as one of the above cases,
 as well as 
\begin_inset Formula $Q(\vec{x},y,\vec{z},\vec{w})$
\end_inset

 extending 
\begin_inset Formula $q$
\end_inset

,
 we wish to find a quantifier-free expression that is equivalent to 
\begin_inset Formula $\exists_{y}\left[\chi_{Q}(\vec{x},y)\land\tau_{q\varphi}(\vec{x},y)\right]$
\end_inset

.
 Intuitively,
 the idea is that in either case our formula 
\begin_inset Formula $\tau$
\end_inset

 determines 
\begin_inset Formula $y$
\end_inset

 exactly (as a function of 
\begin_inset Formula $\vec{x}$
\end_inset

),
 so we can just 
\begin_inset Quotes eld
\end_inset

plug that 
\begin_inset Formula $y$
\end_inset

 into 
\begin_inset Formula $\chi_{Q}(\vec{x},y)$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 To do this more precisely,
 we split into cases:
\end_layout

\begin_deeper
\begin_layout Itemize
If 
\begin_inset Formula $\tau_{q\varphi}(\vec{x},y)\equiv(ay=\vec{c}\cdot\vec{x})$
\end_inset

,
 we apply the same 
\begin_inset Quotes eld
\end_inset

multiply every equation by 
\begin_inset Formula $a$
\end_inset


\begin_inset Quotes erd
\end_inset

 trick to write a formula that corresponds to 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\left(a\mid\vec{c}\cdot\vec{x}\right)\land\chi_{Q}(\vec{x},\frac{1}{a}\vec{c}\cdot\vec{x})$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 The resulting formula is the desired 
\begin_inset Formula $\etau$
\end_inset

.
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $\tau_{q\varphi}(\vec{x},y)\equiv\varphi_{0}(\vec{x})\land N\Delta(y)$
\end_inset

,
 then,
 intuitively,
 we know for a tuple satisfying 
\begin_inset Formula $\tau$
\end_inset

 we have that all 
\begin_inset Formula $x_{i}$
\end_inset

 are zero,
 and that 
\begin_inset Formula $y=N\delta$
\end_inset

.
 Thus,
 the existential quantifier may be eliminated,
 and we wish to determine whether 
\begin_inset Formula $\chi_{Q}(\vec{0},N\delta)$
\end_inset

.
 This is where it is important that we have a c.e.
\begin_inset space \space{}
\end_inset

index for the type of 
\begin_inset Formula $\delta$
\end_inset

 – and,
 if we desire a uniform result,
 that we have this index without recourse to any oracle.
 Knowing the c.e.
\begin_inset space \space{}
\end_inset

index for the type of 
\begin_inset Formula $\delta$
\end_inset

,
 we can just consult whether 
\begin_inset Formula $\chi_{Q}(\vec{0},N\delta)$
\end_inset

 holds – more precisely,
 there is a computable sequence 
\begin_inset Formula $\{B_{n}\}_{n\in\N}$
\end_inset

 such that
\begin_inset Formula 
\[
\left\{ \begin{aligned} & G\nvDash\chi_{Q}(\vec{0},N\delta) & \Rightarrow & B_{n}=\bot\text{ for all \ensuremath{n},}\\
 & G\vDash\chi_{Q}(\vec{0},N\delta) & \Rightarrow & B_{n}=\top\text{ for all but finitely many \ensuremath{n}.}
\end{aligned}
\right.
\]

\end_inset

Thus,
 in this scenario,
 we set 
\begin_inset Formula 
\[
\etau_{q\varphi Q}(\vec{x})\equiv\llor_{n}B_{n}.
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Now we verify that the above definitions are witnesses to the QETP.
\end_layout

\begin_layout Enumerate
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

label=(
\backslash
alph*)
\end_layout

\end_inset


\end_layout

\end_inset

(
\begin_inset Formula $\Lang$
\end_inset

 is finite and closed under negation) Obvious.
\end_layout

\begin_layout Enumerate
(
\begin_inset Formula $G\vDash\chi_{q}(\vec{x})\leftrightarrow\exists_{\vec{y}}q(\vec{x},\vec{y})$
\end_inset

) By construction.
\end_layout

\begin_layout Enumerate
There are two bullet points here.
 In reverse order:
\end_layout

\begin_deeper
\begin_layout Itemize
(
\begin_inset Formula $G\vDash\chi_{q}(\vec{x})\land\varphi(\vec{x})\rightarrow\exists_{y}\tau_{q\varphi}(\vec{x},y)$
\end_inset

) Direct from construction.
\end_layout

\begin_layout Itemize
(Every tuple 
\begin_inset Formula $\vec{b}$
\end_inset

 of elements of 
\begin_inset Formula $G$
\end_inset

 that satisfies 
\begin_inset Formula $\chi_{q}(\vec{b})$
\end_inset

 satisfies some 
\begin_inset Formula $\varphi(\vec{b})$
\end_inset

 with 
\begin_inset Formula $(q,\varphi)$
\end_inset

 in domain of 
\begin_inset Formula $\tau$
\end_inset

)
\end_layout

\begin_deeper
\begin_layout Itemize
If 
\begin_inset Formula $\vec{b}=\vec{0}$
\end_inset

 this is obvious.
\end_layout

\begin_layout Itemize
If some 
\series bold

\begin_inset Formula $b_{i}\neq0$
\end_inset


\series default
:
 We wish to show that there are 
\begin_inset Formula $a\in\Z_{\neq0}$
\end_inset

 and 
\begin_inset Formula $\vec{c}\subseteq\Z$
\end_inset

 such that 
\begin_inset Formula $a\mid\vec{c}\cdot\vec{b}$
\end_inset

 and 
\begin_inset Formula $\chi_{q}(\vec{b},\frac{1}{a}\vec{c}\cdot\vec{b})$
\end_inset

.
 To this effect,
 we prove the following related lemma,
 which obviously implies the desired claim:
\end_layout

\begin_deeper
\begin_layout Lemma
If 
\begin_inset Formula $q(\vec{x},\vec{y})$
\end_inset

 is a quantifier-free type in the smaller language 
\begin_inset Formula $\Lang$
\end_inset

,
 and 
\begin_inset Formula $\vec{b}$
\end_inset

 is a tuple in 
\begin_inset Formula $G$
\end_inset

 such that 
\begin_inset Formula $G\vDash\exists_{\vec{y}}q(\vec{b},\vec{y})$
\end_inset

,
 and some element of 
\begin_inset Formula $\vec{b}$
\end_inset

 is nonzero,
 then there exist integer vectors 
\begin_inset Formula $\vec{c}_{1},\dots,\vec{c}_{\ell}$
\end_inset

 and nonzero integers 
\begin_inset Formula $a_{1},\dots,a_{\ell}$
\end_inset

 such that,
 for every 
\begin_inset Formula $i$
\end_inset

,
 
\begin_inset Formula $a_{i}\mid\vec{c}_{i}\cdot\vec{b}$
\end_inset

,
 and 
\begin_inset Formula $G\vDash q(\vec{b},\frac{1}{a_{1}}\vec{c}_{1}\cdot\vec{b},\dots,\frac{1}{a_{\ell}}\vec{c}_{\ell}\cdot\vec{b})$
\end_inset

.
\end_layout

\begin_layout Standard

\shape italic
Proof of lemma:

\shape default
 We start by writing 
\begin_inset Formula $q(\vec{b},\vec{y})$
\end_inset

 as a linear system of equations
\begin_inset Formula 
\[
q(\vec{x},\vec{y})\equiv\left\{ \begin{aligned}M\vec{b} & =N\vec{y},\\
K\vec{b} & \neq L\vec{y}.
\end{aligned}
\right.
\]

\end_inset

Then,
 as in the construction of 
\begin_inset Formula $\chi_{q}$
\end_inset

,
 we rewrite this system in terms of alternate variables 
\begin_inset Formula $\vec{z}$
\end_inset

,
 which are related to the variables 
\begin_inset Formula $\vec{y}$
\end_inset

 by the relation 
\begin_inset Formula $\vec{z}=B\vec{y}$
\end_inset

 for an invertible matrix 
\begin_inset Formula $B$
\end_inset

:
\begin_inset Formula 
\[
\left\{ \begin{aligned} & M'\vec{b}=D\vec{z},\\
 & K'\vec{b}\neq L'\vec{z},
\end{aligned}
\right.
\]

\end_inset

with 
\begin_inset Formula $D$
\end_inset

 a diagonal matrix padded with zeros.
 Now,
 let us look at the rows of the equation 
\begin_inset Formula $M'\vec{b}=D\vec{z}$
\end_inset

.
 Some rows correspond to a zero element in the diagonal of 
\begin_inset Formula $D$
\end_inset

,
 i.e.
\begin_inset space \space{}
\end_inset

are of the form 
\begin_inset Formula $\vec{m}\cdot\vec{b}=0$
\end_inset

.
 These can be ignored – since it is known that 
\begin_inset Formula $\exists_{y}q(\vec{b},\vec{y})$
\end_inset

,
 these rows simply consist of true linear relations between the 
\begin_inset Formula $\vec{b}$
\end_inset

,
 and the corresponding 
\begin_inset Formula $z$
\end_inset

-variables are free.
 Let us call them 
\begin_inset Formula $\vec{z}_{\mathrm{free}}$
\end_inset

.
 The remaining 
\begin_inset Formula $z$
\end_inset

-variables are determined,
 corresponding to equations of the form 
\begin_inset Formula $\vec{c}_{i}\cdot\vec{b}=a_{i}z_{i}$
\end_inset

.
 As in the construction of 
\begin_inset Formula $\chi_{q}$
\end_inset

,
 this means that the corresponding 
\begin_inset Formula $z$
\end_inset

 variables are determined as 
\begin_inset Formula $z_{i}=\frac{1}{a_{i}}\vec{c}_{i}\cdot\vec{b}$
\end_inset

 (which in particular precludes the fact that 
\begin_inset Formula $a_{i}\mid\vec{c}_{i}\cdot\vec{b}$
\end_inset

).
 Without loss of generality,
 we substitute the determined variables by their corresponding expansion in terms of 
\begin_inset Formula $\vec{b}$
\end_inset

 (which may require clearing denominators),
 leaving us only to satisfy the relation 
\begin_inset Formula $K''\vec{b}\neq L''\vec{z}_{\mathrm{free}}$
\end_inset

.
 Here,
 one again applies a similar reasoning to the one used in the construction of 
\begin_inset Formula $\chi_{q}$
\end_inset

,
 with a minor twist.
 Stratifying the equations so that we first determine 
\begin_inset Formula $z_{1}$
\end_inset

,
 then 
\begin_inset Formula $z_{2}$
\end_inset

,
 and so on,
 we see that at each step 
\begin_inset Formula $z_{i}$
\end_inset

 is only forbidden to take a finite number of values.
 Then,
 we take some 
\emph on
nonzero
\emph default
 
\begin_inset Formula $b_{j}$
\end_inset

,
 and set 
\begin_inset Formula $z_{i}=kb_{j}$
\end_inset

 for some large enough coefficient 
\begin_inset Formula $k$
\end_inset

.
\end_layout

\begin_layout Standard
In the end,
 one concludes that there is a solution to the system of equations 
\begin_inset Formula $q(\vec{b},B\vec{z})$
\end_inset

 whereby every entry of 
\begin_inset Formula $\vec{z}$
\end_inset

 is a valid rational combination of the entries of 
\begin_inset Formula $\vec{b}$
\end_inset

.
 Multiplying this by the integer matrix 
\begin_inset Formula $B$
\end_inset

 yields the desired vector 
\begin_inset Formula $\vec{y}$
\end_inset

,
 also consisting solely of valid rational combinations,
 which serves as a solution to 
\begin_inset Formula $q(\vec{b},\vec{y})$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset space \hfill{}
\end_inset


\shape italic
(End proof of lemma.)
\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset

This completes the proof of Item 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:qetp2"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Enumerate
(
\begin_inset Formula $G\vDash\exists_{y}\left[\chi_{Q}(\vec{x},y)\land\tau_{q\varphi}(\vec{x},y)\right]\leftrightarrow\etau_{q\varphi Q}(\vec{x})$
\end_inset

) True by construction.
\end_layout

\begin_layout Enumerate
(
\begin_inset Formula $G\vDash\etau_{q\varphi Q}(\vec{x})\land\tau_{q\varphi}(\vec{x},y)\rightarrow\chi_{Q}(\vec{x},y)$
\end_inset

) Essentially,
 this is true because 
\begin_inset Formula $\tau_{q\varphi}(\vec{x},y)$
\end_inset

 
\emph on
always
\emph default
 determines 
\begin_inset Formula $y$
\end_inset

 uniquely in terms of 
\begin_inset Formula $\vec{x}$
\end_inset

.
 As such,
 if it is the case that there is some 
\begin_inset Formula $y_{0}$
\end_inset

 that satisfies 
\begin_inset Formula $\chi_{Q}(\vec{x},y_{0})\land\tau_{q\varphi}(\vec{x},y_{0})$
\end_inset

 (that is,
 
\begin_inset Formula $\etau_{q\varphi Q}(\vec{x})$
\end_inset

 holds),
 and it is the case that some specific 
\begin_inset Formula $y$
\end_inset

 satisfies 
\begin_inset Formula $\tau_{q\varphi}(\vec{x},y)$
\end_inset

,
 then it must be the case that 
\begin_inset Formula $y=y_{0}$
\end_inset

 and therefore 
\begin_inset Formula $\chi_{Q}(\vec{x},y)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Thus,
 we are in condition to apply 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 to the 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed copy of 
\begin_inset Formula $G$
\end_inset

 (plus designated element).
 Since this copy was obtained uniformly from the original presentation,
 the result is uniform.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Remark
A useful trick came up in the course of the prior proof:
 If,
 perchance,
 
\begin_inset Formula $\tau_{q\varphi}(\vec{x},y)$
\end_inset

 has the property that 
\begin_inset Formula $y$
\end_inset

 is determined uniquely in terms of 
\begin_inset Formula $\vec{x}$
\end_inset

,
 then Item 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:qetp3"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 of the QETP comes for free.
 This will not apply to any of the other examples present in this article,
 but it does point at something noteworthy:
 It is the job of 
\begin_inset Formula $\tau$
\end_inset

 to determine 
\begin_inset Formula $y$
\end_inset

 as uniquely as possible,
 so that 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 
\begin_inset Quotes eld
\end_inset

knows
\begin_inset Quotes erd
\end_inset

 what is OK to match 
\begin_inset Formula $y$
\end_inset

 with and what is not.
 The case where there is a single well-determined element it can be matched with is optimal,
 but even in other cases,
 we want 
\begin_inset Formula $\tau$
\end_inset

 to pin down the 
\begin_inset Formula $\Lang'$
\end_inset

-type of 
\begin_inset Formula $y$
\end_inset

 as much as possible (and,
 indeed,
 this is in some sense the essence of Item 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:qetp3"

\end_inset

 of the QETP).
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:linord"

\end_inset

Linear Orders with Successors and Predecessors
\end_layout

\begin_layout Theorem
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "montalban_cst"
posttextlist "montalban_cst VII.26"
literal "false"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "thm:JIlinear-1"

\end_inset

Suppose that 
\begin_inset Formula $L$
\end_inset

 is a linear order for which every element admits a successor and predecessor,
 and suppose that the structure 
\begin_inset Formula $(L,<,S)$
\end_inset

 admits a 
\begin_inset Formula $0'$
\end_inset

-computable copy,
 where 
\begin_inset Formula $S(x,y)$
\end_inset

 is the successor relation.
 Then,
 the structure 
\begin_inset Formula $(L,<)$
\end_inset

 admits a computable copy.
\end_layout

\begin_layout Proof
The most important step is to make a 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed copy of 
\begin_inset Formula $(L,<,\not<,=,\neq,\{D_{\geq i}\}_{i\in\N})$
\end_inset

,
 where 
\begin_inset Formula $D_{\geq i}(x,y)$
\end_inset

 is the relation 
\begin_inset Quotes eld
\end_inset

there exist 
\begin_inset Formula $x=x_{0}<x_{1}<\dots<x_{i}=y$
\end_inset


\begin_inset Quotes erd
\end_inset

,
 as this is the bare minimum language necessary for quantifier elimination.
 The main difficulty in doing so is that 
\begin_inset Formula $0'$
\end_inset

 does not know enough about two arbitrary elements to create,
 in finite time,
 a c.e.
\begin_inset space \space{}
\end_inset

index for which distance relations hold true of them.
 Thus,
 we shall need to create an intermediary structure in which some sort of distance relations are uniformly c.e.
\end_layout

\begin_layout Proof
We know that 
\begin_inset Formula $(L,<,S)$
\end_inset

 is 
\begin_inset Formula $0'$
\end_inset

-computable,
 and hence there is a computable process that produces a 
\begin_inset Formula $(<,S)$
\end_inset

-structure,
 and is allowed to delete previously added elements,
 such that the set of elements that are never deleted make up an isomorphic copy of 
\begin_inset Formula $(L,<,S)$
\end_inset

.
 We create an auxiliary computable linear order which shall act as a computable shadow of 
\begin_inset Formula $(L,<,S)$
\end_inset

,
 from which we will create a 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed copy of 
\begin_inset Formula $L$
\end_inset

.
\end_layout

\begin_layout Proof
Assume without loss of generality that,
 whenever a real element (i.e.
\begin_inset space \space{}
\end_inset

one that will never be deleted) is added to 
\begin_inset Formula $L$
\end_inset

,
 all elements of 
\begin_inset Formula $L$
\end_inset

 at that moment are themselves real (because when an element is deleted,
 you can just delete all elements added since its addition,
 and re-add them afterward).
 We create a new computable linear order,
 
\begin_inset Formula $(L_{+},<)$
\end_inset

,
 whose elements consist of,
 for some (but not all) elements 
\begin_inset Formula $x$
\end_inset

 that were ever added to 
\begin_inset Formula $L$
\end_inset

 (even if later removed),
 a corresponding element 
\begin_inset Formula $x_{+}$
\end_inset

 in 
\begin_inset Formula $L_{+}$
\end_inset

,
 in such a way that if 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 both coexist in 
\begin_inset Formula $L$
\end_inset

 at the same time,
 
\begin_inset Formula $x<y$
\end_inset

 iff 
\begin_inset Formula $x_{+}<y_{+}$
\end_inset

.
 Here is the process for the creation of 
\begin_inset Formula $L_{+}$
\end_inset

:
 Each time an element 
\begin_inset Formula $x$
\end_inset

 is added to 
\begin_inset Formula $L$
\end_inset

,
 we imagine an element 
\begin_inset Formula $x_{+}$
\end_inset

in 
\begin_inset Formula $L_{+}$
\end_inset

 such that,
 for every 
\begin_inset Formula $y$
\end_inset

 in 
\begin_inset Formula $L$
\end_inset

 at this moment,
 
\begin_inset Formula $x_{+}$
\end_inset

 compares to 
\begin_inset Formula $y_{+}$
\end_inset

 as 
\begin_inset Formula $x$
\end_inset

 compares to 
\begin_inset Formula $y$
\end_inset

.
 Then,
 we need to determine how 
\begin_inset Formula $x_{+}$
\end_inset

 compares to the current elements of 
\begin_inset Formula $L_{+}$
\end_inset

 that are not of this form.
 Transitivity will force some comparisons.
 The ones that are not forced can be decided arbitrarily,
 e.g.
\begin_inset space \space{}
\end_inset

say that 
\begin_inset Formula $x_{+}<z$
\end_inset

 for every element with which the comparison is not forced.
 Finally,
 check whether adding this element will break the requirement that 
\begin_inset Formula $(L_{+},<)$
\end_inset

 is a linear order (e.g.
\begin_inset space \space{}
\end_inset

because 
\begin_inset Formula $x$
\end_inset

 is actually a fake element of 
\begin_inset Formula $L$
\end_inset

 that compares to the remaining elements of 
\begin_inset Formula $L$
\end_inset

 in an obviously stupid way),
 and importantly,
 whether it stands between the image of two elements of 
\begin_inset Formula $L$
\end_inset

 that are currently thought to be successors.
 If it does not break these requirement,
 we add 
\begin_inset Formula $x_{+}$
\end_inset

 to 
\begin_inset Formula $L_{+}$
\end_inset

.
 Otherwise,
 proceed with the next element added to 
\begin_inset Formula $L$
\end_inset

.
\end_layout

\begin_layout Proof
We make a few observations:
\end_layout

\begin_deeper
\begin_layout Itemize
Note that 
\begin_inset Formula $L$
\end_inset

 embeds into 
\begin_inset Formula $L_{+}$
\end_inset

 via the map 
\begin_inset Formula $x\mapsto x_{+}$
\end_inset

.
 The main content of this statement is that for every real 
\begin_inset Formula $x$
\end_inset

 we do add 
\begin_inset Formula $x_{+}$
\end_inset

 to 
\begin_inset Formula $L_{+}$
\end_inset

.
 This requires our assumption that,
 every time a real element 
\begin_inset Formula $x$
\end_inset

 is added to 
\begin_inset Formula $L$
\end_inset

,
 all elements currently in 
\begin_inset Formula $L$
\end_inset

 are also real:
 This ensures that 
\begin_inset Formula $x_{+}$
\end_inset

 compares to all other elements of the form 
\begin_inset Formula $y_{+}$
\end_inset

 in a coherent way,
 and it is a standard fact about linear orders (amalgamation property) that we can then add 
\begin_inset Formula $x_{+}$
\end_inset

 to 
\begin_inset Formula $L_{+}$
\end_inset

 in such a way that the resulting order is a linear order,
 and indeed the rule 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $x_{+}$
\end_inset

 is added as the leftmost element of the interval it's forced to be in
\begin_inset Quotes erd
\end_inset

 is a uniform way to do so.
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $xSy$
\end_inset

 are elements of 
\begin_inset Formula $L$
\end_inset

,
 there are finitely many elements of 
\begin_inset Formula $L_{+}$
\end_inset

 between 
\begin_inset Formula $x_{+}$
\end_inset

 and 
\begin_inset Formula $y_{+}$
\end_inset

.
 This is because no element is added to 
\begin_inset Formula $L_{+}$
\end_inset

 after these two are.
\end_layout

\begin_layout Itemize
In any computable linear order (such as 
\begin_inset Formula $L_{+}$
\end_inset

),
 the distance relations 
\begin_inset Formula $\{D_{\geq i}\}_{i\in\N}$
\end_inset

 are uniformly c.e.
 as they are 
\begin_inset Formula $\Sigma_{1}$
\end_inset

-defined.
 As such,
 there is a procedure that takes as input a finite tuple of elements from the order 
\begin_inset Formula $L_{+}$
\end_inset

 and outputs a c.e.
\begin_inset space \space{}
\end_inset

index for their atomic type in the signature 
\begin_inset Formula $(<,\not<,=,\neq,\{D_{\geq i}\}_{i\in\N})$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Proof
We are now ready to create the 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed copy of 
\begin_inset Formula $L$
\end_inset

.
 First,
 we define the 
\begin_inset Formula $0'$
\end_inset

-c.e.
 subset 
\begin_inset Formula $L_{+-}\subseteq L_{+}$
\end_inset

 as
\begin_inset Formula 
\[
L_{+-}=\{\,z\in L_{+}\mid\text{there exist real elements \ensuremath{xSy\in L} such that \ensuremath{x_{+}\leq z\leq y_{+}}}\,\}.
\]

\end_inset

Then,
 we 
\begin_inset Formula $0'$
\end_inset

-enumerate the elements of 
\begin_inset Formula $L_{+-}$
\end_inset

,
 and with each new element we also produce a c.e.
\begin_inset space \space{}
\end_inset

index for the tuple of elements enumerated up to now,
 
\emph on
from the order 
\begin_inset Formula $(L_{+},<)$
\end_inset

.

\emph default
 We claim that the resulting order is isomorphic (as a linear order) to 
\begin_inset Formula $L$
\end_inset

 and that the predicates 
\begin_inset Formula $D_{\geq i}$
\end_inset

 are interpreted in the correct way.
\end_layout

\begin_deeper
\begin_layout Itemize
(The resulting order is isomorphic to 
\begin_inset Formula $L$
\end_inset

):
 Consider the embedding 
\begin_inset Formula $f\colon L\to L_{+-}$
\end_inset

 given by 
\begin_inset Formula $x\mapsto x_{+}$
\end_inset

.
 (We've already seen that this map is well-defined and embeds 
\begin_inset Formula $L$
\end_inset

 into 
\begin_inset Formula $L_{+}$
\end_inset

,
 and from the definition of 
\begin_inset Formula $L_{+-}$
\end_inset

 and the fact that every element of 
\begin_inset Formula $L$
\end_inset

 admits a successor (or a predecessor) it is clear that for every 
\begin_inset Formula $x\in L$
\end_inset

 we have 
\begin_inset Formula $x_{+}\in L_{+-}$
\end_inset

.) This is an order-preserving map with the properties:
\end_layout

\begin_deeper
\begin_layout Itemize
If 
\begin_inset Formula $xSy$
\end_inset

 then there are finitely many elements between 
\begin_inset Formula $f(x)$
\end_inset

 and 
\begin_inset Formula $f(y)$
\end_inset

,
\end_layout

\begin_layout Itemize
Every element of 
\begin_inset Formula $L_{+-}$
\end_inset

 is a finite distance away from an element in the image of 
\begin_inset Formula $f$
\end_inset

.
\end_layout

\begin_layout Standard
One can argue (and indeed,
 the standard proof of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:JIlinear-1"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 also goes through this fact) that in this case 
\begin_inset Formula $(L,<)$
\end_inset

 and 
\begin_inset Formula $(L_{+-},<)$
\end_inset

 are isomorphic:
 Pick one representative 
\begin_inset Formula $x$
\end_inset

 from every finite-distance block from 
\begin_inset Formula $L$
\end_inset

,
 and map 
\begin_inset Formula $S^{i}x$
\end_inset

 (
\begin_inset Formula $i\in\Z)$
\end_inset

 to 
\begin_inset Formula $S^{i}(f(x))$
\end_inset

.
 The fact that this map – call it 
\begin_inset Formula $g$
\end_inset

 – is well-defined requires some details
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
One must verify that every element of 
\begin_inset Formula $L_{+-}$
\end_inset

 has a successor and a predecessor.
 This is because every element 
\begin_inset Formula $z$
\end_inset

 of 
\begin_inset Formula $L_{+-}$
\end_inset

 satisfies 
\begin_inset Formula $\exists_{x}x_{+}<z<(S^{3}x)_{+}$
\end_inset

,
 and there are finitely many elements between 
\begin_inset Formula $x_{+}$
\end_inset

 and 
\begin_inset Formula $(S^{3}x)_{+}$
\end_inset

,
 whereby there must be a smallest element greater (resp.
 smaller) than 
\begin_inset Formula $z$
\end_inset

 as it suffices to take the least (resp.
 greatest) element in the finite interval 
\begin_inset Formula $\left]z,(S^{3}x)_{+}\right]$
\end_inset

 (resp.
 
\begin_inset Formula $\left[x_{+},z\right[$
\end_inset

).
\end_layout

\end_inset

,
 the fact that 
\begin_inset Formula $g$
\end_inset

 is an embedding is obvious,
 and the fact that 
\begin_inset Formula $g$
\end_inset

 is surjective consists of:
 Every element 
\begin_inset Formula $z$
\end_inset

 of 
\begin_inset Formula $L_{+-}$
\end_inset

 is a finite distance away from some 
\begin_inset Formula $y_{+}$
\end_inset

,
 and if 
\begin_inset Formula $x$
\end_inset

 is the representative of the block of 
\begin_inset Formula $y$
\end_inset

 in 
\begin_inset Formula $L$
\end_inset

,
 we must have that 
\begin_inset Formula $z$
\end_inset

 is a finite distance away from 
\begin_inset Formula $x_{+}$
\end_inset

.
 If 
\begin_inset Formula $i$
\end_inset

 is the signed distance between 
\begin_inset Formula $z$
\end_inset

 and 
\begin_inset Formula $x_{+}$
\end_inset

,
 we have 
\begin_inset Formula $z=g(S^{i}x)$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
(The predicates 
\begin_inset Formula $D_{\geq i}$
\end_inset

 are correctly interpreted):
 For the sake of this argument,
 let us denote the predicates induced from 
\begin_inset Formula $L_{+}$
\end_inset

 (and thus the ones we have a c.e.
\begin_inset space \space{}
\end_inset

index for) by 
\begin_inset Formula $\{D_{\geq i}^{\mathrm{ind}}\}_{i\in\N}$
\end_inset

 and the 
\begin_inset Quotes eld
\end_inset

true
\begin_inset Quotes erd
\end_inset

 predicates by 
\begin_inset Formula $\{D_{\geq i}\}_{i\in\N}.$
\end_inset

We would like to show that 
\begin_inset Formula $L_{+-}\vDash D_{\geq i}^{\mathrm{ind}}(x,y)\leftrightarrow D_{\geq i}(x,y)$
\end_inset

.
 The implication 
\begin_inset Formula $\leftarrow$
\end_inset

 is obvious,
 so we focus on the implication 
\begin_inset Formula $\rightarrow$
\end_inset

,
 which we prove by contrapositive.
 Suppose that 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 are elements of 
\begin_inset Formula $L_{+-}$
\end_inset

 such that 
\begin_inset Formula $\neg D_{\geq i}(x,y)$
\end_inset

.
 Let 
\begin_inset Formula $x^{\leftarrow}$
\end_inset

 be an element of 
\begin_inset Formula $L$
\end_inset

 such that 
\begin_inset Formula $(x^{\leftarrow})_{+}\leq x\leq(Sx^{\leftarrow})_{+}$
\end_inset

,
 and likewise define 
\begin_inset Formula $y^{\rightarrow}$
\end_inset

 such that 
\begin_inset Formula $(S^{-1}y^{\rightarrow})_{+}\leq y\leq(y^{\rightarrow})_{+}$
\end_inset

.
 Then,
 all of the elements in the open interval 
\begin_inset Formula $\left]x^{\leftarrow},y^{\rightarrow}\right[$
\end_inset

 are taken to (distinct) real elements between 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

,
 whence there must be finitely (and indeed,
 less than 
\begin_inset Formula $i$
\end_inset

 many) of them.
 Thus,
 the entirety of the interval 
\begin_inset Formula $\left](x^{\leftarrow})_{+},(y^{\rightarrow})_{+}\right[\subseteq L_{+}$
\end_inset

 actually lies in 
\begin_inset Formula $L_{+-}$
\end_inset

,
 and thus distances are preserved between any two elements thereof when considering only elements of 
\begin_inset Formula $L_{+-}$
\end_inset

.
 Since the distance between 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 is less than 
\begin_inset Formula $i$
\end_inset

 in 
\begin_inset Formula $L_{+-}$
\end_inset

,
 it must also be so in 
\begin_inset Formula $L_{+}$
\end_inset

,
 i.e.
\begin_inset space \space{}
\end_inset


\begin_inset Formula $\neg D_{\geq i}^{\mathrm{ind}}(x,y)$
\end_inset

.
\end_layout

\begin_layout Standard
Now that we have a 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed copy of 
\begin_inset Formula $(L,<,\not<,=,\neq,\{D_{\geq i}\}_{i\in\N})$
\end_inset

,
 it suffices to establish that it has the QETP,
 whereby 
\begin_inset Formula $(L,<)$
\end_inset

 has a computable copy by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

:
\end_layout

\begin_layout Itemize
To construct 
\begin_inset Formula $\chi_{q}$
\end_inset

:
 Given a type 
\begin_inset Formula $q(\vec{x},\vec{y})$
\end_inset

 (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rmk:assumeq"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

),
 the demand that 
\begin_inset Formula $\exists_{\vec{y}}q(\vec{x},\vec{y})$
\end_inset

 corresponds to requiring that (the ordering on variables induced by 
\begin_inset Formula $q$
\end_inset

 is coherent,
 and that) the 
\begin_inset Formula $x_{i}$
\end_inset

 are in a specific order,
 and that the adjacent (in this order) 
\begin_inset Formula $x_{i}$
\end_inset

 admit enough space between them to add the necessary 
\begin_inset Formula $y_{j}$
\end_inset

.
 This can obviously be (computably) written as a positive combination of 
\begin_inset Formula $D_{\geq n_{i}}(x_{i},x_{j})$
\end_inset

.
\end_layout

\begin_layout Itemize
To construct 
\begin_inset Formula $\tau$
\end_inset

:
 Given a type 
\begin_inset Formula $q(\vec{x},y,\vec{z})$
\end_inset

,
 we define 
\begin_inset Formula $\tau_{q\top}(\vec{x},y)$
\end_inset

 as follows.
 Consider the linear order induced on the variables 
\begin_inset Formula $\vec{x}$
\end_inset

,
 
\begin_inset Formula $y$
\end_inset

,
 and 
\begin_inset Formula $\vec{z}$
\end_inset

 by 
\begin_inset Formula $q$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Itemize
If,
 in this order,
 there is 
\begin_inset Formula $i$
\end_inset

 such that 
\begin_inset Formula $x_{i}<y$
\end_inset

,
 let 
\begin_inset Formula $i$
\end_inset

 be the largest such WLOG,
 and let 
\begin_inset Formula $k$
\end_inset

 be the number of variables 
\begin_inset Formula $z_{j}$
\end_inset

 such that 
\begin_inset Formula $x_{i}<z_{j}<y$
\end_inset

.
 Then,
 set
\begin_inset Formula 
\[
\tau_{q\top}(\vec{x},y)\equiv D_{\geq k}(x_{i},y)\land\neg D_{\geq(k+1)}(x_{i},y)\text{ (which is to say \ensuremath{S^{k}(x_{i},y)})}.
\]

\end_inset


\end_layout

\begin_layout Itemize
If there is no such 
\begin_inset Formula $i$
\end_inset

,
 but there is at least one 
\begin_inset Formula $x$
\end_inset

-variable,
 let 
\begin_inset Formula $x_{i}$
\end_inset

 be the least 
\begin_inset Formula $x$
\end_inset

-variable,
 let 
\begin_inset Formula $k$
\end_inset

 be the number of 
\begin_inset Formula $z_{j}$
\end_inset

 such that 
\begin_inset Formula $y<z_{j}<x_{i}$
\end_inset

,
 and set
\begin_inset Formula 
\[
\tau_{q\top}(\vec{x},y)\equiv D_{\geq k}(y,x_{i})\land\neg D_{\geq(k+1)}(y,x_{i})\text{ (which is to say \ensuremath{S^{k}(y,x_{i})})}.
\]

\end_inset


\end_layout

\begin_layout Itemize
If there are no 
\begin_inset Formula $x$
\end_inset

-variables,
 set 
\begin_inset Formula $\tau_{q\top}(y)\equiv\top$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
To construct 
\begin_inset Formula $\etau_{q\top Q}$
\end_inset

:
 Depending on the case of the definition of 
\begin_inset Formula $\tau_{q\top}$
\end_inset

,
 respectively,
 and using the notation therein,
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\etau_{q\top Q}(\vec{x})$
\end_inset

 says 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\chi_{Q}(\vec{x})$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 didn't add any new variable between 
\begin_inset Formula $y$
\end_inset

 and 
\begin_inset Formula $x_{i}$
\end_inset


\begin_inset Quotes erd
\end_inset

,
\end_layout

\begin_layout Itemize
Likewise,
\end_layout

\begin_layout Itemize
\begin_inset Formula $\etau_{q\top Q}\equiv\chi_{Q}$
\end_inset

 (applied to the empty tuple).
\end_layout

\end_deeper
\begin_layout Standard
The verification of all the relevant properties is straight-forward and left to the reader.
\begin_inset Separator plain
\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:trees"

\end_inset

A Simple Class of Trees
\end_layout

\begin_layout Standard
We now present a more complete version of a proof previously sketched in the introduction.
 As a reminder:
 If 
\begin_inset Formula $T$
\end_inset

 is a tree and 
\begin_inset Formula $\sigma$
\end_inset

 is a node,
 we use the term 
\begin_inset Quotes eld
\end_inset

parent of 
\begin_inset Formula $\sigma$
\end_inset


\begin_inset Quotes erd
\end_inset

 to mean the unique,
 if it exists,
 node that has 
\begin_inset Formula $\sigma$
\end_inset

 as a child.
 We use the term 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $a$
\end_inset

-th parent of 
\begin_inset Formula $\sigma$
\end_inset


\begin_inset Quotes erd
\end_inset

 to mean,
 if it exists,
 the parent of the parent of ...
 (repeated 
\begin_inset Formula $a$
\end_inset

 times) of the parent of 
\begin_inset Formula $\sigma$
\end_inset

.
 In particular,
 the 
\begin_inset Formula $0$
\end_inset

-th parent of 
\begin_inset Formula $\sigma$
\end_inset

 is 
\begin_inset Formula $\sigma$
\end_inset

 itself.
\end_layout

\begin_layout Proposition
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "strong_jump_inversion"
posttextlist "strong_jump_inversion Proposition 3.8"
literal "false"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "prop:trees"

\end_inset

Let 
\begin_inset Formula $T$
\end_inset

 be an infinite tree in 
\begin_inset Formula $\omega^{<\omega}$
\end_inset

 (i.e.
\begin_inset space \space{}
\end_inset

a nonempty subset of 
\begin_inset Formula $\omega^{<\omega}$
\end_inset

 closed under prefixes) such that every node of 
\begin_inset Formula $T$
\end_inset

 is either a leaf or admits infinitely many children,
 of which finitely many are leaves.
 Define on 
\begin_inset Formula $T$
\end_inset

 the predicates:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\leaf(x)$
\end_inset

,
 meaning 
\begin_inset Formula $x$
\end_inset

 has no children,
\end_layout

\begin_layout Itemize
\begin_inset Formula $\Shat ab(x,y)$
\end_inset

,
 meaning that 
\begin_inset Formula $x$
\end_inset

 admits an 
\begin_inset Formula $a$
\end_inset

-th parent,
 and 
\begin_inset Formula $y$
\end_inset

 admits a 
\begin_inset Formula $b$
\end_inset

-th parent,
 and that these two are the same,
\end_layout

\begin_layout Itemize
\begin_inset Formula $R_{a}(x)$
\end_inset

,
 meaning that 
\begin_inset Formula $x$
\end_inset

 admits the root of the tree as an 
\begin_inset Formula $a$
\end_inset

-th parent,
\end_layout

\begin_layout Standard
which have as particular cases the predicates 
\begin_inset Formula $S(x,y)\equiv\Shat 01(x,y)$
\end_inset

,
 meaning that 
\begin_inset Formula $y$
\end_inset

 is a child of 
\begin_inset Formula $x$
\end_inset

,
 and 
\begin_inset Formula $R_{0}(x)$
\end_inset

,
 meaning that 
\begin_inset Formula $x$
\end_inset

 is the root.
\end_layout

\begin_layout Standard
Then,
 if the structure 
\begin_inset Formula $(T,\leaf,S,R_{0})$
\end_inset

 admits a 
\begin_inset Formula $0'$
\end_inset

-computable copy,
 the structure 
\begin_inset Formula $(T,S,R_{0})$
\end_inset

 admits a computable copy.
\end_layout

\end_deeper
\begin_layout Proof
First,
 we note that from a 
\begin_inset Formula $0'$
\end_inset

-computable copy of 
\begin_inset Formula $(T,\leaf,S,R_{0})$
\end_inset

 we can uniformly compute a 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed copy of 
\begin_inset Formula $(T,\neg\leaf,\{\Shat ab,\neg\Shat ab\}_{a,b\in\N},\{R_{a},\neg R_{a}\}_{a\in\N})$
\end_inset

,
 by enumerating the elements of the copy of 
\begin_inset Formula $T$
\end_inset

 and,
 for every new element,
 finding all its predecessors up to the root and comparing them to the predecessors of all the elements enumerated up to now,
 which allows us to compute (and,
 crucially,
 encode as a finite amount of information) which 
\begin_inset Formula $\Shat ab$
\end_inset

 relations hold between this new element and the others already enumerated thus far,
 and the distance of this new element from the root (to compute 
\begin_inset Formula $R_{a}$
\end_inset

).
 Thus,
 it suffices to show that the structure 
\begin_inset Formula $T$
\end_inset

 satisfies the QETP,
 over the signatures
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\Lang=(S,\neg S,R_{0},\neg R_{0},=,\neq)$
\end_inset

,
 and
\end_layout

\begin_layout Itemize
\begin_inset Formula $\Lang'$
\end_inset

 equals 
\begin_inset Formula $\Lang$
\end_inset

,
 plus 
\begin_inset Formula $\neg\leaf$
\end_inset

 and all predicates 
\begin_inset Formula $\Shat ab$
\end_inset

,
 
\begin_inset Formula $\neg\Shat ab$
\end_inset

,
 
\begin_inset Formula $R_{a}$
\end_inset

,
 and 
\begin_inset Formula $\neg R_{a}$
\end_inset

.
\end_layout

\begin_layout Standard
To this effect,
 we first need to establish a (uniform) quantifier-elimination result.
 Thus,
 suppose that 
\begin_inset Formula $q(\vec{x},\vec{y})$
\end_inset

 is a quantifier-free formula in the signature 
\begin_inset Formula $\Lang$
\end_inset

,
 and let us calculate a formula 
\begin_inset Formula $\chi_{q}(\vec{x})$
\end_inset

 in the signature 
\begin_inset Formula $\Lang'$
\end_inset

 such that 
\begin_inset Formula $T\vDash\forall_{\vec{x}}(\chi_{q}(\vec{x})\leftrightarrow\exists_{\vec{y}}q(\vec{x},\vec{y}))$
\end_inset

.
\end_layout

\begin_layout Standard
Suppose that 
\begin_inset Formula $q(\vec{x},\vec{y})$
\end_inset

 is a quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

-type all of whose elements are distinct (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rmk:assumeq"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

).
 We wish to rewrite 
\begin_inset Formula $\exists_{\vec{y}}q(\vec{x},\vec{y})$
\end_inset

 in a quantifier-free manner.
 Let us momentarily consider the language augmented with a partial function symbol 
\begin_inset Formula $P(x)$
\end_inset

,
 which returns the unique predecessor of 
\begin_inset Formula $x$
\end_inset

 if it exists.
 Then,
 every variable 
\begin_inset Formula $y_{a}$
\end_inset

 such that there is an instance of 
\begin_inset Formula $S(y_{a},*)$
\end_inset

 in 
\begin_inset Formula $q$
\end_inset

 may be replaced by 
\begin_inset Formula $P(*)$
\end_inset

,
 with the added requirement 
\begin_inset Formula $\neg R_{0}(*)$
\end_inset

.
 If any instance of 
\begin_inset Formula $S(y_{a},P^{n}(y_{a}))$
\end_inset

 is found,
 abort and set 
\begin_inset Formula $\chi_{q}\equiv\bot$
\end_inset

.
 Otherwise,
 we thus replace 
\begin_inset Formula $\exists_{\vec{y}}q(\vec{x},\vec{y})$
\end_inset

 by a logically equivalent formula,
 using the partial function symbol 
\begin_inset Formula $P$
\end_inset

,
 where the only variables 
\begin_inset Formula $y_{a}$
\end_inset

 that remain are those that are not demanded to be the predecessor of any other variable.
 For each such 
\begin_inset Formula $y_{a}$
\end_inset

,
 one of two cases occurs:
\end_layout

\begin_layout Enumerate
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

label={Case 
\backslash
arabic*.}
\end_layout

\end_inset


\end_layout

\end_inset

 There is some 
\begin_inset Formula $x_{b}$
\end_inset

 such that we now have 
\begin_inset Formula $x_{b}=P^{m}(y_{a})$
\end_inset

,
 for some integer 
\begin_inset Formula $m\geq1$
\end_inset

.
 In this case,
 we can get rid of the variable 
\begin_inset Formula $y_{a}$
\end_inset

 while retaining logical equivalence,
 as long as we add the demand 
\begin_inset Formula $\neg\leaf(x_{b})$
\end_inset

,
 as if 
\begin_inset Formula $x_{b}$
\end_inset

 is not a leaf it will have infinitely many infinite children,
 which will have infinitely many infinite children,
 and so on,
 so such a 
\begin_inset Formula $y_{a}$
\end_inset

 always exists.
\end_layout

\begin_layout Enumerate
The type 
\begin_inset Formula $q$
\end_inset

 does not demand that any predecessor of 
\begin_inset Formula $y_{a}$
\end_inset

 is any 
\begin_inset Formula $x_{b}$
\end_inset

.
 In this case,
 we can get rid of the variable 
\begin_inset Formula $y_{a}$
\end_inset

,
 because any (self-consistent) demand we make of 
\begin_inset Formula $y_{a}$
\end_inset

 will always be satisfied by some deep enough child of the root.
\end_layout

\begin_layout Standard
Once this process terminates,
 we've replaced 
\begin_inset Formula $\exists_{\vec{y}}q(\vec{x},\vec{y})$
\end_inset

 by a logically equivalent positive Boolean combination of:
 
\begin_inset Formula $\neg\leaf(x_{i})$
\end_inset

,
 
\begin_inset Formula $P^{a}(x_{i})=P^{b}(x_{j})$
\end_inset

,
 
\begin_inset Formula $P^{a}(x_{i})\neq P^{b}(x_{j})$
\end_inset

 (incl.
 the case where one of the sides is not well-defined),
 
\begin_inset Formula $R_{0}(P^{a}(x_{i}))$
\end_inset

,
 and 
\begin_inset Formula $\neg R_{0}(P^{a}(x_{i}))$
\end_inset

.
 These are,
 respectively,
 equivalent to:
 
\begin_inset Formula $\neg\leaf(x_{i})$
\end_inset

,
 
\begin_inset Formula $\Shat ab(x_{i},x_{j})$
\end_inset

,
 
\begin_inset Formula $\neg\Shat ab(x_{i},x_{j})$
\end_inset

,
 
\begin_inset Formula $R_{a}(x_{i})$
\end_inset

,
 and 
\begin_inset Formula $\neg R_{a}(x_{i})$
\end_inset

,
 which yields the desired formula 
\begin_inset Formula $\chi_{q}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Now,
 let us construct 
\begin_inset Formula $\tau$
\end_inset

.
 Suppose that a quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

-type 
\begin_inset Formula $q(\vec{x},y,\vec{z})$
\end_inset

 is given.
 Consider,
 as in the construction of 
\begin_inset Formula $\chi$
\end_inset

,
 eliminating all variables 
\begin_inset Formula $\vec{z}$
\end_inset

 that appear as the predecessor of another variable.
 Now,
 there are two cases:
\end_layout

\begin_layout Enumerate
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

label={Case 
\backslash
arabic*.}
\end_layout

\end_inset


\end_layout

\end_inset

There are 
\begin_inset Formula $x_{a}$
\end_inset

,
 
\begin_inset Formula $m$
\end_inset

,
 and 
\begin_inset Formula $n$
\end_inset

 such that 
\begin_inset Formula $P^{m}(x_{a})=P^{n}(y)$
\end_inset

 is part of the data of 
\begin_inset Formula $q$
\end_inset

.
 In this case,
 set 
\begin_inset Formula $\tau_{q\top}(\vec{x},y)\equiv\chi_{q}(\vec{x},y)\land\neg\leaf(y)$
\end_inset

.
\end_layout

\begin_layout Enumerate
The data of 
\begin_inset Formula $q$
\end_inset

 does not imply that any particular predecessor of 
\begin_inset Formula $y$
\end_inset

 is equal to any particular predecessor of any 
\begin_inset Formula $x_{a}$
\end_inset

.
 There are two sub-cases:
 Either the data of 
\begin_inset Formula $q$
\end_inset

 allows us to determine the depth of 
\begin_inset Formula $y$
\end_inset

 precisely,
 or it only gives us a lower bound for the depth (because none of the predecessors of 
\begin_inset Formula $y$
\end_inset

 is prescribed to be the root).
 Let 
\begin_inset Formula $N$
\end_inset

 be the depth of 
\begin_inset Formula $y$
\end_inset

 or its lower bound,
 as the case may be,
 and set 
\begin_inset Formula $\tau_{q\top}(\vec{x},y)$
\end_inset

 to mean 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\chi_{q}(\vec{x},y)$
\end_inset

 and 
\begin_inset Formula $\varphi_{n}(\vec{x})$
\end_inset

 and 
\begin_inset Formula $\neg\leaf(y)$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 is at depth 
\begin_inset Formula $N$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 has no common predecessor with any 
\begin_inset Formula $x_{a}$
\end_inset

 other than the root
\begin_inset Quotes erd
\end_inset

.
 (As explained in the introduction,
 this can be expressed as a 
\begin_inset Formula $\llorc$
\end_inset

 formula.).
\end_layout

\begin_layout Standard
Finally,
 we construct 
\begin_inset Formula $\etau$
\end_inset

.
 Given quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

-types 
\begin_inset Formula $q(\vec{x},y,\vec{z})$
\end_inset

 and 
\begin_inset Formula $Q(\vec{x},y,\vec{z},\vec{w})$
\end_inset

,
 we define 
\begin_inset Formula $\etau_{q\varphi Q}(\vec{x})$
\end_inset

 depending on which case the definition of 
\begin_inset Formula $\tau_{q\varphi}$
\end_inset

 falls into:
\end_layout

\begin_layout Enumerate
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

label={Case 
\backslash
arabic*.}
\end_layout

\end_inset


\end_layout

\end_inset

If 
\begin_inset Formula $\tau_{q\top}(\vec{x},y)\equiv\chi_{q}(\vec{x},y)\land\neg\leaf(y)$
\end_inset

,
 set 
\begin_inset Formula $\etau_{q\top Q}(\vec{x})\equiv\chi_{Q}(\vec{x})$
\end_inset

.
\end_layout

\begin_layout Enumerate
If 
\begin_inset Formula $\tau_{q\top}(\vec{x},y)$
\end_inset

 is set to mean 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\chi_{q}(\vec{x},y)$
\end_inset

 and 
\begin_inset Formula $\neg\leaf(y)$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 is at depth 
\begin_inset Formula $N$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 has no common predecessor with any 
\begin_inset Formula $x_{a}$
\end_inset

 other than the root
\begin_inset Quotes erd
\end_inset

,
 check whether 
\begin_inset Formula $Q$
\end_inset

 demands that 
\begin_inset Formula $y$
\end_inset

 has more than 
\begin_inset Formula $N$
\end_inset

 predecessors.
 If so,
 set 
\begin_inset Formula $\etau_{q\top Q}(\vec{x})\equiv\bot$
\end_inset

.
 If it includes coherent data about exactly 
\begin_inset Formula $N$
\end_inset

 distinct predecessors of 
\begin_inset Formula $y$
\end_inset

,
 check if it demands that the 
\begin_inset Formula $N$
\end_inset

th predecessor is the root,
 and that none of the other predecessors are related to any 
\begin_inset Formula $x_{a}$
\end_inset

 other than via the root.
 If this is the case,
 set 
\begin_inset Formula $\etau_{q\top Q}(\vec{x})\equiv\chi_{Q}(\vec{x})$
\end_inset

,
 and if not,
 set 
\begin_inset Formula $\etau_{q\top Q}(\vec{x})\equiv\bot$
\end_inset

.
 Finally,
 if it includes data about less than 
\begin_inset Formula $N$
\end_inset

 predecessors of 
\begin_inset Formula $y$
\end_inset

,
 check that none of them are the root and that none of them are related to any 
\begin_inset Formula $x_{a}$
\end_inset

 other than via the root,
 and set 
\begin_inset Formula $\etau_{q\top Q}(\vec{x})\equiv\chi_{Q}(\vec{x})$
\end_inset

 (or 
\begin_inset Formula $\bot$
\end_inset

 if the check fails).
\end_layout

\begin_layout Standard
This concludes the construction.
 A tedious model-theoretic argument will show that these formulas satisfy all the conditions of the QETP,
 and thus 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"

\end_inset

 applies,
 whence we obtain a computable copy of the structure 
\begin_inset Formula $(T,S,R_{0})$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Section
Escaping Tennenbaum's Theorem with More Truths
\end_layout

\begin_layout Standard
In this section,
 we answer the question posed by Pakhomov in 
\begin_inset CommandInset citation
LatexCommand cite
key "pakhomov"
literal "false"

\end_inset

 that was outlined in the introduction:
 Do there exist theories definitionally equivalent to 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\mathsf{PA}$
\end_inset

 + all 
\begin_inset Formula $\Pi_{n}$
\end_inset

 truths
\begin_inset Quotes erd
\end_inset

 that admit computable nonstandard models?
 The answer is yes,
 but in order to motivate our construction,
 we will first briefly sketch Pakhomov's original construction,
 so as to highlight the ways in which our construction builds upon it.
\end_layout

\begin_layout Standard
As described in the introduction,
 we will henceforth be working primarily with the theory 
\begin_inset Formula $\ZFniptc$
\end_inset

,
 which consists of the axioms of 
\begin_inset Formula $\mathsf{ZF}$
\end_inset

,
 with the removal of the axiom of infinity,
 and with the addition of the axiom of transitive closure,
 which (modulo the remaining axioms) is equivalent to the axiom stating that every set is in some level 
\begin_inset Formula $V_{\alpha}$
\end_inset

 of the von
\begin_inset space ~
\end_inset

Neumann hierarchy.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:pakhomov_original"

\end_inset

Pakhomov's Original Construction
\end_layout

\begin_layout Standard
As explained in the introduction,
 Pakhomov defined in 
\begin_inset Formula $\ZFniptc$
\end_inset

 a ternary predicate 
\begin_inset Formula $S(x,y,z)$
\end_inset

 by transfinite recursion on the von
\begin_inset space ~
\end_inset

Neumann hierarchy,
 which provably satisfies the rule 
\begin_inset Formula $x\in y\leftrightarrow\forall_{z}S(x,y,z)$
\end_inset

,
 whence the theory of 
\begin_inset Formula $S$
\end_inset

 is definitionally equivalent to 
\begin_inset Formula $\ZFniptc$
\end_inset

,
 and which satisfies certain properties that make the theory of 
\begin_inset Formula $(\in,S)$
\end_inset

 amenable to a jump-inversion-type result,
 whereby a computable nonstandard model of the theory of 
\begin_inset Formula $S$
\end_inset

 follows.
 Let us briefly sketch Pakhomov's definition of 
\begin_inset Formula $S$
\end_inset

 within 
\begin_inset Formula $\ZFniptc$
\end_inset

.
 Our definition is not exactly the same as Pakhomov's,
 but differs only in inessential ways.
\end_layout

\begin_layout Standard
We define an ascending sequence of relations 
\begin_inset Formula $S_{\alpha}$
\end_inset

 on 
\begin_inset Formula $V_{q\alpha}$
\end_inset

,
\begin_inset Foot
status open

\begin_layout Plain Layout
Using the convention on ordinal multiplication that satisfies 
\begin_inset Formula $\beta\sup\alpha_{i}=\sup(\beta\alpha_{i})$
\end_inset

.
\end_layout

\end_inset

 where 
\begin_inset Formula $q$
\end_inset

 is a large enough finite ordinal to be determined shortly (Pakhomov's construction sets 
\begin_inset Formula $q=6$
\end_inset

,
 while our choice of construction,
 which is slightly more inefficient in an attempt to make it easier to parse,
 shall set 
\begin_inset Formula $q=10$
\end_inset

),
 in such a way that each 
\begin_inset Formula $S_{\alpha}$
\end_inset

 agrees with every other 
\begin_inset Formula $S_{\beta}$
\end_inset

 where mutually defined.
 This relation is uniquely determined on limit ordinals,
 as 
\begin_inset Formula $V_{q\sup\alpha_{i}}=\cup V_{q\alpha_{i}}$
\end_inset

,
 so it suffices to describe the successor step.
 As such,
 let us define 
\begin_inset Formula $S_{\alpha+1}$
\end_inset

 in terms of 
\begin_inset Formula $S_{\alpha}$
\end_inset

.
\end_layout

\begin_layout Standard
Given 
\begin_inset Formula $\alpha$
\end_inset

,
 a set 
\begin_inset Formula $A\subseteq V_{q\alpha}$
\end_inset

,
 and 
\begin_inset Formula $SA\subseteq(A\cup\{q\alpha\})^{3}$
\end_inset

,
 define an element 
\begin_inset Formula $w(\alpha,A,SA)$
\end_inset

 satisfying the following conditions:
\end_layout

\begin_layout Itemize
\begin_inset Formula $w(\alpha,A,SA)\in V_{q(\alpha+1)}\setminus V_{q\alpha}$
\end_inset

,
\end_layout

\begin_layout Itemize
The operation 
\begin_inset Formula $(\alpha,A,SA)\mapsto w(\alpha,A,SA)$
\end_inset

 is injective as a class function 
\begin_inset Formula $V\times V\times V\to V$
\end_inset

,
 and
\end_layout

\begin_layout Itemize
\begin_inset Formula $w(\alpha,A,SA)$
\end_inset

 is not 
\begin_inset Formula $\in$
\end_inset

-related to any element of 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Standard
An example of such a function is 
\begin_inset Formula $w(\alpha,A,SA):=(q\alpha,(A,SA))$
\end_inset

,
 assuming the usage of Kuratowski pairs 
\begin_inset Formula $(x,y):=\{\{x\},\{x,y\}\}$
\end_inset

,
 which will immediately satisfy the second and third bullet points.
 To ensure the first bullet point is where we are compelled to choose 
\begin_inset Formula $q=10$
\end_inset

,
 as follows:
\end_layout

\begin_layout Itemize
Suppose 
\begin_inset Formula $A\subseteq V_{q\alpha}$
\end_inset

.
 Then,
 
\begin_inset Formula $A\in V_{q\alpha+1}$
\end_inset

.
\end_layout

\begin_layout Itemize
Thus,
 
\begin_inset Formula $A\cup\{q\alpha\}\subseteq V_{q\alpha+1}$
\end_inset

,
 and any pair of its elements is thereby in 
\begin_inset Formula $V_{q\alpha+3}$
\end_inset

,
 whence any triplet is in 
\begin_inset Formula $V_{q\alpha+5}$
\end_inset

.
\end_layout

\begin_layout Itemize
As a consequence,
 we have 
\begin_inset Formula $SA\subseteq V_{q\alpha+5}$
\end_inset

,
 and so 
\begin_inset Formula $SA\in V_{q\alpha+6}$
\end_inset

.
 Thus,
 we conclude 
\begin_inset Formula $w(\alpha,A,SA)\in V_{q\alpha+10}$
\end_inset

,
 and so we set 
\begin_inset Formula $q=10$
\end_inset

 as to obtain 
\begin_inset Formula $w(\alpha,A,SA)\in V_{q(\alpha+1)}$
\end_inset

.
\end_layout

\begin_layout Itemize
We also have that 
\begin_inset Formula $w=w(\alpha,A,SA)$
\end_inset

 is not in 
\begin_inset Formula $V_{q\alpha}$
\end_inset

 because 
\begin_inset Formula $V_{q\alpha}$
\end_inset

 is transitive and does not contain 
\begin_inset Formula $q\alpha$
\end_inset

,
 while 
\begin_inset Formula $w$
\end_inset

 does.
\end_layout

\begin_layout Standard
The motivation for defining 
\begin_inset Formula $w(\alpha,A,SA)$
\end_inset

 is as follows:
 In the course of constructing a computable nonstandard model of the theory of 
\begin_inset Formula $S$
\end_inset

,
 one could consider starting with a 
\begin_inset Formula $0'$
\end_inset

-computable nonstandard model 
\begin_inset Formula $D$
\end_inset

 of 
\begin_inset Formula $(\in,S)$
\end_inset

,
 and,
 when made to remove an element that was added by mistake,
 we instead change our mind about which element of 
\begin_inset Formula $D$
\end_inset

 it represents.
 This requires that any commitments we've already made about 
\begin_inset Formula $S$
\end_inset

 be preserved,
 and since we have no 
\shape italic
a priori
\shape default
 control about what those wrong commitments look like,
 we need to ensure:
 Given a few elements 
\begin_inset Formula $a_{1},\dots,a_{n}$
\end_inset

 of 
\begin_inset Formula $D$
\end_inset

,
 and given a hypothetical element which is 
\begin_inset Formula $S$
\end_inset

-related to those elements in some hard-to-control manner,
 there exists a true element within 
\begin_inset Formula $D$
\end_inset

 that has those relations.
 This element is precisely the one obtained from the 
\begin_inset Formula $w$
\end_inset

 function,
 where 
\begin_inset Formula $A$
\end_inset

 is the set 
\begin_inset Formula $\{a_{1,}\dots,a_{n}\}$
\end_inset

,
 and 
\begin_inset Formula $SA$
\end_inset

 encodes the 
\begin_inset Formula $S$
\end_inset

-relations between our hypothetical element and the elements of 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Standard
Now,
 we could not simply allow any and all possible 
\begin_inset Formula $S$
\end_inset

-relations to hold,
 or otherwise the theory of 
\begin_inset Formula $S$
\end_inset

 would simply be the theory of the random 
\begin_inset Formula $3$
\end_inset

-hypergraph,
 which is far too homogeneous to be definitionally equivalent to set theory.
 This is where the following definition (which takes place inside 
\begin_inset Formula $\ZFniptc$
\end_inset

) comes in.
\end_layout

\begin_layout Standard
We say that a pair 
\begin_inset Formula $(A,SA)$
\end_inset

 is 
\emph on
good
\emph default
 (for the ordinal 
\begin_inset Formula $\alpha$
\end_inset

) if 
\begin_inset Formula $SA$
\end_inset

 is a set of triples of elements from 
\begin_inset Formula $A\cup\{q\alpha\}$
\end_inset

 and the following two conditions hold:
\end_layout

\begin_layout Itemize
\begin_inset Formula $SA$
\end_inset

 agrees with 
\begin_inset Formula $S_{\alpha}$
\end_inset

 on 
\begin_inset Formula $A$
\end_inset

,
 in the sense that 
\begin_inset Formula $SA\cap A^{3}=\{(a,b,c)\in A^{3}\mid S_{\alpha}(a,b,c)\}$
\end_inset

,
 and
\end_layout

\begin_layout Itemize
For every 
\begin_inset Formula $a,b\in A$
\end_inset

 with 
\begin_inset Formula $a\in b$
\end_inset

,
 we have 
\begin_inset Formula $(a,b,q\alpha)\in SA$
\end_inset

.
 By induction on 
\begin_inset Formula $\alpha$
\end_inset

,
 this turns out to be equivalent to the stronger demand that 
\begin_inset Formula $\forall_{a,b\in A}a\in b\rightarrow\forall_{z\in A\cup\{q\alpha\}}(a,b,z)\in SA$
\end_inset

.
\end_layout

\begin_layout Standard
We are now ready to define 
\begin_inset Formula $S_{\alpha+1}$
\end_inset

.
 Given a triplet 
\begin_inset Formula $(a,b,c)\in V_{q(\alpha+1)}^{3}$
\end_inset

,
\end_layout

\begin_layout Itemize
If all elements of the triplet are in 
\begin_inset Formula $V_{q\alpha}$
\end_inset

,
 set 
\begin_inset Formula $S_{\alpha+1}(a,b,c)\equiv S_{\alpha}(a,b,c)$
\end_inset

,
\end_layout

\begin_layout Itemize
If,
 for some choice of 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $SA$
\end_inset

 that is good for 
\begin_inset Formula $\alpha$
\end_inset

,
 every element of the triplet is either in 
\begin_inset Formula $A$
\end_inset

 or is equal to 
\begin_inset Formula $w=w(\alpha,A,SA)$
\end_inset

,
 set 
\begin_inset Formula $S_{\alpha+1}(a,b,c)$
\end_inset

 to hold true if,
 and only if,
 upon replacing every instance of 
\begin_inset Formula $w$
\end_inset

 in the triplet 
\begin_inset Formula $(a,b,c)$
\end_inset

 by 
\begin_inset Formula $q\alpha$
\end_inset

,
 the resulting triplet is in 
\begin_inset Formula $SA$
\end_inset

.
 For example,
 if 
\begin_inset Formula $a,b\in A$
\end_inset

 and 
\begin_inset Formula $c=w(\alpha,A,SA)$
\end_inset

,
 set 
\begin_inset Formula $S_{\alpha+1}(a,b,c)\equiv[(a,b,q\alpha)\in SA]$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
In the sequence,
 when such a choice of 
\begin_inset Formula $\alpha$
\end_inset

,
 
\begin_inset Formula $A$
\end_inset

,
 and 
\begin_inset Formula $SA$
\end_inset

 is clear from context,
 denote by 
\begin_inset Formula $a^{*}$
\end_inset

 the operation of replacing 
\begin_inset Formula $q\alpha$
\end_inset

 by 
\begin_inset Formula $w(\alpha,A,SA)$
\end_inset

,
 and 
\begin_inset Formula $a_{*}$
\end_inset

 the inverse operation.
 Thus,
 the definition of 
\begin_inset Formula $S_{\alpha+1}$
\end_inset

 in this case can be reworded as:
 
\begin_inset Formula $S_{\alpha+1}(a,b,c)\equiv[(a_{*},b_{*},c_{*})\in SA]$
\end_inset

 or,
 equivalently,
 
\begin_inset Formula $S_{\alpha+1}(a^{*},b^{*},c^{*})\equiv[(a,b,c)\in SA]$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
For every other triplet from 
\begin_inset Formula $V_{q(\alpha+1)}$
\end_inset

,
 set 
\begin_inset Formula $S_{\alpha+1}(a,b,c)$
\end_inset

 to hold true.
\end_layout

\begin_layout Standard
With this,
 we define the 
\begin_inset Formula $S$
\end_inset

 relation within 
\begin_inset Formula $\ZFniptc$
\end_inset

 as follows:
 Given 
\begin_inset Formula $a$
\end_inset

,
 
\begin_inset Formula $b$
\end_inset

,
 and 
\begin_inset Formula $c$
\end_inset

,
 it holds by the axiom of transitive closure that all three lie in some common 
\begin_inset Formula $V_{\alpha}$
\end_inset

.
 Then,
 evaluate 
\begin_inset Formula $S(a,b,c)\equiv S_{\alpha}(a,b,c)$
\end_inset

.
\end_layout

\begin_layout Standard
As originally pointed out by Pakhomov,
 the main defining properties of the relation 
\begin_inset Formula $S$
\end_inset

 are the following two lemmas:
\end_layout

\begin_layout Lemma
Provably in 
\begin_inset Formula $\ZFniptc$
\end_inset

:
 Given sets 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

,
 
\begin_inset Formula $x\in y$
\end_inset

 iff 
\begin_inset Formula $\forall_{z}S(x,y,z)$
\end_inset

.
\end_layout

\begin_layout Proof
Suppose 
\begin_inset Formula $x\in y$
\end_inset

,
 but also that there is 
\begin_inset Formula $z$
\end_inset

 such that 
\begin_inset Formula $\neg S(x,y,z)$
\end_inset

.
 Let 
\begin_inset Formula $\alpha$
\end_inset

 be the least ordinal for which there exist 
\begin_inset Formula $x,y,z\in V_{q\alpha}$
\end_inset

 with 
\begin_inset Formula $x\in y$
\end_inset

 and 
\begin_inset Formula $\neg S_{\alpha}(x,y,z)$
\end_inset

.
 The only way for this to happen is if,
 for this value of 
\begin_inset Formula $\alpha$
\end_inset

,
 there is a good choice of 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $SA$
\end_inset

 for which 
\begin_inset Formula $(x_{*},y_{*},z_{*})\notin SA$
\end_inset

.
 Because 
\begin_inset Formula $\alpha$
\end_inset

 is minimal,
 at least one of 
\begin_inset Formula $x_{*}$
\end_inset

,
 
\begin_inset Formula $y_{*}$
\end_inset

,
 or 
\begin_inset Formula $z_{*}$
\end_inset

 must be 
\begin_inset Formula $q\alpha$
\end_inset

,
 and since 
\begin_inset Formula $x\in y$
\end_inset

 it cannot be 
\begin_inset Formula $x_{*}$
\end_inset

 nor 
\begin_inset Formula $y_{*}$
\end_inset

.
 However,
 since 
\begin_inset Formula $x_{*}\in y_{*}$
\end_inset

 and 
\begin_inset Formula $z_{*}=q\alpha$
\end_inset

 we must then have 
\begin_inset Formula $(x_{*},y_{*},z_{*})\in SA$
\end_inset

,
 a contradiction.
 This proves that 
\begin_inset Formula $x\in y$
\end_inset

 implies 
\begin_inset Formula $\forall_{z}S(x,y,z)$
\end_inset

.
\end_layout

\begin_layout Proof
For the other direction,
 assume 
\begin_inset Formula $x\notin y$
\end_inset

.
 Pick a large enough value of 
\begin_inset Formula $\alpha$
\end_inset

 such that 
\begin_inset Formula $A=\{x,y\}$
\end_inset

 is contained in 
\begin_inset Formula $V_{q\alpha}$
\end_inset

,
 and consider the set 
\begin_inset Formula $SA=\{(y,x,q\alpha)\}\cup(S_{\alpha}\cap A^{3})$
\end_inset

.
 It can be checked that the pair 
\begin_inset Formula $(A,SA)$
\end_inset

 is good (in fact,
 if 
\begin_inset Formula $y\notin x$
\end_inset

 we could even set 
\begin_inset Formula $SA=S_{\alpha}\cap A^{3}$
\end_inset

).
 As such,
 for 
\begin_inset Formula $w=w(\alpha,A,SA)$
\end_inset

,
 we shall have 
\begin_inset Formula $S_{\alpha+1}(x,y,w)$
\end_inset

 iff 
\begin_inset Formula $(x,y,q\alpha)\in SA$
\end_inset

,
 which is not the case.
 Thus,
 
\begin_inset Formula $\neg S_{\alpha}(x,y,w)$
\end_inset

,
 and so 
\begin_inset Formula $\exists_{z}\neg S(x,y,z)$
\end_inset

 as desired.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:sflex"

\end_inset

Let 
\begin_inset Formula $M$
\end_inset

 be a model of 
\begin_inset Formula $\ZFniptc$
\end_inset

.
 Let 
\begin_inset Formula $A$
\end_inset

 be a finite
\begin_inset Foot
status open

\begin_layout Plain Layout
Here we mean finite from the perspective of the metatheory,
 but indeed this result holds also from within the theory,
 basically by definition.
\end_layout

\end_inset

 subset of 
\begin_inset Formula $M$
\end_inset

,
 and suppose that we wish to find an element 
\begin_inset Formula $w$
\end_inset

 that 
\begin_inset Formula $S$
\end_inset

-relates to all elements of 
\begin_inset Formula $A$
\end_inset

 in a prescribed manner.
 So long as the prescription satisfies the rule:
 
\begin_inset Quotes eld
\end_inset

For all 
\begin_inset Formula $a,b\in A$
\end_inset

 with 
\begin_inset Formula $a\in b$
\end_inset

,
 we have 
\begin_inset Formula $S(a,b,w)$
\end_inset


\begin_inset Quotes erd
\end_inset

,
 there is in fact some 
\begin_inset Formula $w\in M\setminus A$
\end_inset

,
 not 
\begin_inset Formula $\in$
\end_inset

-related to any element of 
\begin_inset Formula $A$
\end_inset

,
 satisfying this prescription.
\end_layout

\begin_layout Proof
This follows basically from the definition of the 
\begin_inset Formula $S$
\end_inset

 relation,
 together with the fact that every finite set (from the perspective of the metatheory) is represented in 
\begin_inset Formula $M$
\end_inset

.
\end_layout

\begin_layout Standard
The above two properties suffice to establish the following jump inversion theorem,
 though we'll forego the proof,
 as 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:gen_pakhomov_jump_inversion"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 completely subsumes it.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:basic_pakhomov_jump_inversion"

\end_inset

If 
\begin_inset Formula $D$
\end_inset

 is a 
\begin_inset Formula $0'$
\end_inset

-computable model of the theory of 
\begin_inset Formula $(\in,S)$
\end_inset

 in 
\begin_inset Formula $\ZFniptc$
\end_inset

,
 the reduct 
\begin_inset Formula $D\upto S$
\end_inset

 admits a computable copy.
\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rmk:sjipakhomov1"

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:basic_pakhomov_jump_inversion"

\end_inset

 is almost an example of a Strong Jump Inversion result in the strong sense of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rmk:jumpinversion"

\end_inset

,
 because the structure 
\begin_inset Formula $(D,\notin,S)$
\end_inset

 is a structural jump of 
\begin_inset Formula $(D,S)$
\end_inset

.
 Indeed,
 from the fact that 
\begin_inset Formula $x\in y\leftrightarrow\forall_{z}S(x,y,z)$
\end_inset

 we conclude that 
\begin_inset Formula $\notin$
\end_inset

 is r.i.c.e.
\begin_inset space \space{}
\end_inset

in 
\begin_inset Formula $(D,S)$
\end_inset

,
 and we will establish in the proof of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:gen_pakhomov_jump_inversion"

\end_inset

 the following quantifier elimination result:
 Any formula 
\begin_inset Formula $\exists_{\vec{y}}q(\vec{x},\vec{y})$
\end_inset

 in the signature containing only 
\begin_inset Formula $S$
\end_inset

 is equivalent in 
\begin_inset Formula $D$
\end_inset

 to a first-order quantifier-free formula 
\begin_inset Formula $Q(\vec{x})$
\end_inset

 in the signature 
\begin_inset Formula $(\notin,S)$
\end_inset

 containing only positive instances of 
\begin_inset Formula $\notin$
\end_inset

.
 Thus,
 with access to an oracle from 
\begin_inset Formula $0'$
\end_inset

 we can uniformly turn any 
\begin_inset Formula $\Sigma_{1}^{c}(S)$
\end_inset

 formula into an equivalent finitary quantifier-free formula in 
\begin_inset Formula $(\notin,S)$
\end_inset

,
 which suffices to show that 
\begin_inset Formula $(D,\notin,S)$
\end_inset

 is a structural jump of 
\begin_inset Formula $(D,S)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:basic_pakhomov_jump_inversion"

\end_inset

 is enough to establish the following results of Pakhomov's original paper:
\end_layout

\begin_layout Corollary
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Pakhomov 
\begin_inset CommandInset citation
LatexCommand cite
key "pakhomov"
literal "false"

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "cor:cet0"

\end_inset

Every consistent c.e.
\begin_inset space \space{}
\end_inset

 extension 
\begin_inset Formula $T$
\end_inset

 of the theory of 
\begin_inset Formula $S$
\end_inset

 in 
\begin_inset Formula $\ZFniptc$
\end_inset

 admits a computable model.
\end_layout

\begin_layout Proof
The theory 
\begin_inset Formula $\ZFniptc$
\end_inset

 is c.e.,
 and so the theory 
\begin_inset Formula $T'$
\end_inset

 consisting of 
\begin_inset Formula $T$
\end_inset

,
 
\begin_inset Formula $\ZFniptc$
\end_inset

,
 and the definition of 
\begin_inset Formula $S$
\end_inset

 in terms of 
\begin_inset Formula $\in$
\end_inset

,
 is also c.e.
 Thus,
 there is a 
\begin_inset Formula $0'$
\end_inset

-computable complete and consistent extension 
\begin_inset Formula $T''$
\end_inset

 of 
\begin_inset Formula $T'$
\end_inset

,
 and by applying the relativized computable completeness theorem (see 
\begin_inset CommandInset citation
LatexCommand cite
key "harizanov"
literal "false"

\end_inset

),
 there is a 
\begin_inset Formula $0'$
\end_inset

-computable model of 
\begin_inset Formula $T''$
\end_inset

 and hence of the theory of 
\begin_inset Formula $(\in,S)$
\end_inset

.
 We then apply 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:basic_pakhomov_jump_inversion"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 to this model to obtain a computable copy of its reduct to 
\begin_inset Formula $S$
\end_inset

,
 which is a model of 
\begin_inset Formula $T$
\end_inset

.
\end_layout

\begin_layout Corollary
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Pakhomov 
\begin_inset CommandInset citation
LatexCommand cite
key "pakhomov"
literal "false"

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "cor:nonstd"

\end_inset

There is a computable nonstandard model of a theory definitionally equivalent to 
\begin_inset Formula $\mathsf{PA}$
\end_inset

.
\end_layout

\begin_layout Proof
Recall that 
\begin_inset Formula $\ZFfinptc$
\end_inset

 (that is,
 
\begin_inset Formula $\ZFniptc$
\end_inset

 plus the negation of the axiom of infinity) is definitionally equivalent to 
\begin_inset Formula $\mathsf{PA}$
\end_inset

 (see 
\begin_inset CommandInset citation
LatexCommand cite
key "kaye_wong"
literal "false"

\end_inset

 for details),
 and hence the theory of 
\begin_inset Formula $S$
\end_inset

 in 
\begin_inset Formula $\ZFfinptc$
\end_inset

 is as well.
 Thus,
 let 
\begin_inset Formula $T$
\end_inset

 be a theory containing the theory of 
\begin_inset Formula $S$
\end_inset

,
 plus the translation to the 
\begin_inset Formula $S$
\end_inset

-language of a statement consistent with 
\begin_inset Formula $\mathsf{PA}$
\end_inset

 not in true arithmetic.
 By 
\begin_inset CommandInset ref
LatexCommand formatted
reference "cor:cet0"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 there is a computable model of 
\begin_inset Formula $T$
\end_inset

.
\end_layout

\begin_layout Standard
The proof of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "cor:nonstd"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 presented above is very close to Pakhomov's original proof.
 We present an alternate proof,
 which is not directly possible as stated using only Pakhomov's results.
\end_layout

\begin_layout Proof
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand formatted
reference "cor:nonstd"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset


\end_layout

\end_inset

Let 
\begin_inset Formula $T$
\end_inset

 be the theory in the language of arithmetic,
 plus an added constant 
\begin_inset Formula $c$
\end_inset

,
 containing the theory of 
\begin_inset Formula $\mathsf{PA}$
\end_inset

,
 plus sentences saying that 
\begin_inset Formula $c$
\end_inset

 is nonstandard:
 
\begin_inset Formula $c\neq0$
\end_inset

,
 
\begin_inset Formula $c\neq S0$
\end_inset

,
 
\begin_inset Formula $c\neq SS0$
\end_inset

,
 and so on.
 Let 
\begin_inset Formula $T'$
\end_inset

 be the theory 
\begin_inset Formula $T$
\end_inset

,
 plus predicates 
\begin_inset Formula $S$
\end_inset

 and 
\begin_inset Formula $\in$
\end_inset

,
 and axioms defining 
\begin_inset Formula $S$
\end_inset

 and 
\begin_inset Formula $\in$
\end_inset

 in terms of the arithmetical symbols.
 Since 
\begin_inset Formula $T'$
\end_inset

 is a c.e.
\begin_inset space \space{}
\end_inset

theory,
 it admits a 
\begin_inset Formula $0'$
\end_inset

-computable model 
\begin_inset Formula $M$
\end_inset

,
 whose reduct to 
\begin_inset Formula $(\mathord{\in},S)$
\end_inset

 satisfies the assumptions of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "cor:cet0"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 and so its reduct to 
\begin_inset Formula $S$
\end_inset

 admits a computable copy.
\end_layout

\begin_layout Subsection
Generalizing Pakhomov's Construction
\end_layout

\begin_layout Standard
In Pakhomov's original construction,
 as explained in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:pakhomov_original"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 the predicate 
\begin_inset Formula $\in$
\end_inset

 is performing two distinct tasks.
 On the one hand,
 
\begin_inset Formula $S$
\end_inset

 is defined to mean 
\begin_inset Quotes eld
\end_inset

set inclusion,
 with a third argument that represents a witness in the case where inclusion does not hold
\begin_inset Quotes erd
\end_inset

,
 with the 
\begin_inset Quotes els
\end_inset

witness
\begin_inset Quotes ers
\end_inset

 part playing a crucial role by being flexible enough to turn 
\begin_inset Formula $0'$
\end_inset

-computable models into computable models.
 On the other hand,
 the predicate 
\begin_inset Formula $\in$
\end_inset

 is providing the 
\begin_inset Quotes eld
\end_inset

definitional flexibility
\begin_inset Quotes erd
\end_inset

 required to allow the entire construction of 
\begin_inset Formula $S$
\end_inset

 to take place,
 as we need the theory we're working in to be powerful enough to quantify over possible prescriptions of 
\begin_inset Formula $S$
\end_inset

 for a hypothetical extra element,
 in order to ensure that an element satisfying this prescription does exist.
 Upon understanding these roles as separate,
 one gets the idea that the construction could be applied to other predicates,
 or even applied to itself recursively.
\end_layout

\begin_layout Standard
There are a few technical hitches in the way of this idea,
 most notably the fact that an implicit ingredient in the construction of 
\begin_inset Formula $S$
\end_inset

 is that the 
\begin_inset Formula $\in$
\end_inset

-relation is 
\begin_inset Quotes eld
\end_inset

rare
\begin_inset Quotes erd
\end_inset

,
 making it easy to construct elements that are 
\begin_inset Formula $\in$
\end_inset

-incomparable to previous elements,
 while conversely the 
\begin_inset Formula $S$
\end_inset

 relation is 
\begin_inset Quotes eld
\end_inset

common
\begin_inset Quotes erd
\end_inset

.
 This foreshadows the idea that,
 in order to generalize to higher-order 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $S$
\end_inset

 relations
\begin_inset Quotes erd
\end_inset

,
 we will need to introduce a few negations (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:sneg"

\end_inset

).
\end_layout

\begin_layout Standard
Another technical matter regards the coefficient 
\begin_inset Formula $q$
\end_inset

 described in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:pakhomov_original"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
 If we adopt the same exact strategy described therein,
 we would need to increase our coefficient 
\begin_inset Formula $q$
\end_inset

 the more 
\begin_inset Quotes eld
\end_inset

iterations of 
\begin_inset Formula $S$
\end_inset


\begin_inset Quotes erd
\end_inset

 we would like to introduce.
 By itself,
 this is not necessarily an issue,
 but we've found that it simplifies the definition to adopt a slightly different perspective.
 In Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:pakhomov_original"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 we imagine that,
 for a given stage 
\begin_inset Formula $q\alpha$
\end_inset

 of the von
\begin_inset space ~
\end_inset

Neumann hierarchy,
 we look at all possible ways that a new element relates via 
\begin_inset Formula $S$
\end_inset

 to the elements of 
\begin_inset Formula $V_{q\alpha}$
\end_inset

,
 and designate someone realizing these possible relations in 
\begin_inset Formula $V_{q(\alpha+1)}$
\end_inset

.
 If,
 instead,
 we exercise some patience,
 we can instead consider that at every stage 
\begin_inset Formula $V_{\alpha}$
\end_inset

 of the von
\begin_inset space ~
\end_inset

Neumann hierarchy,
 for every possible way for an element to 
\begin_inset Formula $S$
\end_inset

-relate to the elements of 
\begin_inset Formula $V_{\alpha}$
\end_inset

 we 
\begin_inset Quotes eld
\end_inset

schedule
\begin_inset Quotes erd
\end_inset

 an element to relate to them in this manner,
 though this element might only be actually added,
 say,
 in 
\begin_inset Formula $V_{\alpha+100}$
\end_inset

.
 In our view,
 this adds some versatility and simplifies the construction.
\end_layout

\begin_layout Standard
We are now ready to state and prove:
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:nestedpakhomov"

\end_inset

There is a nested sequence of consistent c.e.
\begin_inset space \space{}
\end_inset

theories 
\begin_inset Formula $\ZFniptc\subseteq T^{0}\subseteq T^{1}\subseteq T^{2}\subseteq\cdots$
\end_inset

 satisfying the following properties:
\end_layout

\begin_deeper
\begin_layout Itemize
Each 
\begin_inset Formula $T^{n}$
\end_inset

 is in the language containing 
\begin_inset Formula $\in$
\end_inset

 and predicates 
\begin_inset Formula $S^{0}$
\end_inset

,
 
\begin_inset Formula $\dots$
\end_inset

,
 
\begin_inset Formula $S^{n}$
\end_inset

,
 with each 
\begin_inset Formula $S^{i}$
\end_inset

 being an 
\begin_inset Formula $(i+2)$
\end_inset

-ary predicate symbol,
\end_layout

\begin_layout Itemize
All of these extensions are conservative,
 in the sense that they contain no additional theorems in the predicate 
\begin_inset Formula $\in$
\end_inset

,
\end_layout

\begin_layout Itemize
The predicates 
\begin_inset Formula $\in$
\end_inset

 and 
\begin_inset Formula $S^{n}$
\end_inset

 are definable in terms of the other within 
\begin_inset Formula $T^{n}$
\end_inset

,
 and
\end_layout

\begin_layout Itemize
Given a 
\begin_inset Formula $0'$
\end_inset

-computable model 
\begin_inset Formula $D$
\end_inset

 of 
\begin_inset Formula $T^{n}$
\end_inset

 restricted to the language containing 
\begin_inset Formula $S^{i}$
\end_inset

,
 
\begin_inset Formula $\dots$
\end_inset

,
 and 
\begin_inset Formula $S^{n}$
\end_inset

,
 there is a computable copy 
\begin_inset Formula $M$
\end_inset

 of 
\begin_inset Formula $D\upto(S^{i+1},\dots,S^{n})$
\end_inset

.
\end_layout

\begin_layout Standard
The last item relativizes:
 Given an 
\begin_inset Formula $X'$
\end_inset

-computable model of 
\begin_inset Formula $T^{n}$
\end_inset

 in the last 
\begin_inset Formula $k$
\end_inset

 predicates,
 there is an 
\begin_inset Formula $X$
\end_inset

-computable copy of its reduct to the last 
\begin_inset Formula $k-1$
\end_inset

 predicates.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
We dedicate the remainder of this section to the proof of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:nestedpakhomov"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
 We start by defining the sequence 
\begin_inset Formula $\{T_{n}\}_{n\in\N}$
\end_inset

 inductively.
 For the base case,
 we set 
\begin_inset Formula $T^{0}$
\end_inset

 to be 
\begin_inset Formula $\ZFniptc$
\end_inset

,
 plus the axiom 
\begin_inset Formula $\forall_{x,y}[S^{0}(x,y)\leftrightarrow(x\notin y)]$
\end_inset

.
 It trivially (and,
 in the case of the last bullet point,
 almost vacuously) satisfies all required conditions.
 Now,
 we suppose that 
\begin_inset Formula $T^{n}$
\end_inset

 has already been defined,
 and set out to define 
\begin_inset Formula $T^{n+1}$
\end_inset

.
\end_layout

\begin_layout Standard
Within 
\begin_inset Formula $T^{n}$
\end_inset

,
 we define the ordinal-indexed sequence of predicates 
\begin_inset Formula $S_{\alpha}^{n+1}(\vec{x},y)$
\end_inset

,
 where 
\begin_inset Formula $\vec{x}$
\end_inset

 is an 
\begin_inset Formula $(n+1)$
\end_inset

-uple
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
is there precedent for this?
 upl.
 Future duarte here:
 yes...
 in portuguese and french....
 but there is a small amount of precedent on stack exchange.
 i guess.
\end_layout

\end_inset

 of variables,
 in a way similar to the definition of 
\begin_inset Formula $S_{\alpha}(x,y,z)$
\end_inset

 in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:pakhomov_original"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
 The big picture is the same:
 We define 
\begin_inset Formula $S_{\alpha}^{n+1}$
\end_inset

 inductively as a compatible sequence of relations on 
\begin_inset Formula $V_{\alpha}$
\end_inset

 (note the absence of the constant 
\begin_inset Formula $q$
\end_inset

) with 
\begin_inset Formula $S_{\lambda}^{n+1}$
\end_inset

 having an obvious definition for limit ordinals 
\begin_inset Formula $\lambda$
\end_inset

,
 so it suffices to describe the successor step.
 To assist us in that regard,
 we define the following sequence of class functions:
\end_layout

\begin_layout Standard
Given sets 
\begin_inset Formula $A$
\end_inset

,
 
\begin_inset Formula $mA$
\end_inset

,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The set 
\begin_inset Formula $mA$
\end_inset

 is not present in the original construction of 
\begin_inset Formula $S$
\end_inset

,
 and it is technically not necessary here,
 but it will save us trouble.
 It should be seen as encoding some 
\begin_inset Quotes eld
\end_inset

metadata
\begin_inset Quotes erd
\end_inset

 on the element 
\begin_inset Formula $w$
\end_inset

 we are about to define,
 which is essentially used inductively to give flexibility to higher-order 
\begin_inset Formula $S^{N}$
\end_inset

 predicates.
\end_layout

\end_inset

 an ordinal 
\begin_inset Formula $\alpha$
\end_inset

,
 and sets 
\begin_inset Formula $S^{i}A\subseteq(A\cup\{\alpha\})^{i+2}$
\end_inset

 for 
\begin_inset Formula $i=0,\dots,n+1$
\end_inset

,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Here,
 the expression 
\begin_inset Formula $S^{i}A$
\end_inset

 is merely notation (where 
\begin_inset Formula $i$
\end_inset

 is a finite ordinal and 
\begin_inset Formula $A$
\end_inset

 is a set),
 intended to evoke the idea that 
\begin_inset Formula $S^{i}A$
\end_inset

 is defining the relation 
\begin_inset Formula $S^{i}$
\end_inset

 between the elements of 
\begin_inset Formula $A$
\end_inset

 and a new element.
 Note that 
\begin_inset Formula $S^{0}A$
\end_inset

 is not the same as 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\end_inset

 define an element 
\begin_inset Formula $w^{n}(\alpha,mA,A,SA,\dots,S^{n}A)$
\end_inset

 inductively in 
\begin_inset Formula $n$
\end_inset

 as follows.
 We assume the usage of Kuratowski pairs throughout.
\end_layout

\begin_layout Itemize
\begin_inset Formula $w^{0}(\alpha,mA,A)=(\alpha,(A,mA))$
\end_inset

,
 and
\end_layout

\begin_layout Itemize
\begin_inset Formula $w^{n+1}(\alpha,mA,A,S^{0}A,S^{1}A,\dots,S^{n}A,S^{n+1}A)=w^{n}(\alpha,(S^{n+1}A,mA),A,S^{0}A,\dots,S^{n}A)$
\end_inset

.
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
The main defining features of this sequence of class functions are:
\end_layout

\begin_layout Itemize
For every 
\begin_inset Formula $n$
\end_inset

,
 
\begin_inset Formula $(\alpha,mA,A,S^{0}A,\dots,S^{n}A)\mapsto w^{n}(\alpha,mA,A,S^{0}A,\dots,S^{n}A)$
\end_inset

 is an injective definable class function,
 and
\end_layout

\begin_layout Itemize
\begin_inset Formula $w^{n}(\alpha,mA,A,S^{0}A,\dots,S^{n}A)$
\end_inset

 is 
\emph on
not
\emph default
 in 
\begin_inset Formula $V_{\alpha}$
\end_inset

.
\end_layout

\begin_layout Standard
Let us go back to defining 
\begin_inset Formula $S^{n+1}$
\end_inset

 inductively,
 assuming that we have already defined 
\begin_inset Formula $S^{0}$
\end_inset

 up to 
\begin_inset Formula $S^{n}$
\end_inset

,
 for 
\begin_inset Formula $n\geq0$
\end_inset

.
 Assuming that 
\begin_inset Formula $S_{\alpha}^{n+1}$
\end_inset

 is already defined on tuples of elements of 
\begin_inset Formula $V_{\alpha}$
\end_inset

,
 we define a 
\begin_inset Quotes eld
\end_inset

good sequence
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $(\alpha,mA,A,S^{0}A,\dots,S^{n+1}A)$
\end_inset

 as one that satisfies the following properties:
\end_layout

\begin_layout Itemize
\begin_inset Formula $A$
\end_inset

 is a subset of 
\begin_inset Formula $V_{\alpha}$
\end_inset

,
\end_layout

\begin_layout Itemize
For 
\begin_inset Formula $i=0,\dots,n+1$
\end_inset

,
 the set 
\begin_inset Formula $S^{i}A$
\end_inset

 is a subset of 
\begin_inset Formula $(A\cup\{\alpha\})^{i+2}$
\end_inset

,
\end_layout

\begin_layout Itemize
For 
\begin_inset Formula $i=0,\dots,n$
\end_inset

,
 the set 
\begin_inset Formula $S^{i}A\cap A^{i+2}$
\end_inset

 coincides with the relation 
\begin_inset Formula $S^{i}$
\end_inset

 on 
\begin_inset Formula $A$
\end_inset

,
\end_layout

\begin_layout Itemize
The set 
\begin_inset Formula $S^{n+1}A\cap A^{n+2}$
\end_inset

 coincides with the relation 
\begin_inset Formula $S_{\alpha}^{n+1}$
\end_inset

 on 
\begin_inset Formula $A$
\end_inset

,
\end_layout

\begin_layout Itemize
The set 
\begin_inset Formula $S^{0}A$
\end_inset

 contains all pairs 
\begin_inset Formula $(a,\alpha)$
\end_inset

,
 
\begin_inset Formula $(\alpha,a)$
\end_inset

,
 and 
\begin_inset Formula $(\alpha,\alpha$
\end_inset

),
 with 
\begin_inset Formula $a\in A$
\end_inset

.
\end_layout

\begin_layout Itemize
For 
\begin_inset Formula $i=0,\dots,n$
\end_inset

,
 the following condition holds:
 For every 
\begin_inset Formula $(i+3)$
\end_inset

-uple 
\begin_inset Formula $(\vec{a},b)$
\end_inset

 of elements of 
\begin_inset Formula $A\cup\{\alpha\}$
\end_inset

,
 if 
\begin_inset Formula $\vec{a}\notin S^{i}A$
\end_inset

,
 then 
\begin_inset Formula $(\vec{a},b)\in S^{i+1}A$
\end_inset

.
\end_layout

\begin_layout Standard
We are now ready to define 
\begin_inset Formula $S_{\alpha+1}^{n+1}$
\end_inset

.
 Given an 
\begin_inset Formula $(n+3)$
\end_inset

-uple 
\begin_inset Formula $\vec{x}$
\end_inset

 of elements in 
\begin_inset Formula $V_{\alpha+1}$
\end_inset

,
\end_layout

\begin_layout Itemize
If all elements of the tuple are in 
\begin_inset Formula $V_{\alpha}$
\end_inset

,
 set 
\begin_inset Formula $S_{\alpha+1}^{n+1}(\vec{x})\equiv S_{\alpha}^{n+1}(\vec{x})$
\end_inset

,
\end_layout

\begin_layout Itemize
If there is a good sequence 
\begin_inset Formula $(\beta,mA,A,S^{0}A,\dots,S^{n+1}A)$
\end_inset

,
 for some 
\begin_inset Formula $\beta\leq\alpha$
\end_inset

,
 such that the element 
\begin_inset Formula $w=w^{n+1}(\beta,mA,A,S^{0}A,\dots,S^{n+1}A)$
\end_inset

 is in 
\begin_inset Formula $V_{\alpha+1}$
\end_inset

,
 and every entry of 
\begin_inset Formula $\vec{x}$
\end_inset

 is an element of 
\begin_inset Formula $A\cup\{w\}$
\end_inset

,
 set 
\begin_inset Formula $S_{\alpha+1}^{n+1}(\vec{x})$
\end_inset

 to hold true if,
 and only if,
 upon replacing every instance of 
\begin_inset Formula $w$
\end_inset

 in the tuple 
\begin_inset Formula $\vec{x}$
\end_inset

 by 
\begin_inset Formula $\beta$
\end_inset

,
 the resulting tuple is in 
\begin_inset Formula $S^{n+1}A$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
In the sequence,
 when such a choice of good sequence is clear from context,
 denote by 
\begin_inset Formula $\vec{x}^{*}$
\end_inset

 the operation of replacing every entry of 
\begin_inset Formula $\vec{x}$
\end_inset

 that equals 
\begin_inset Formula $\beta$
\end_inset

 by 
\begin_inset Formula $w$
\end_inset

,
 and let 
\begin_inset Formula $\vec{x}_{*}$
\end_inset

 denote the inverse operation.
 Thus,
 the definition of 
\begin_inset Formula $S_{\alpha+1}^{n+1}$
\end_inset

 in this case can be reworded as:
 
\begin_inset Formula $S_{\alpha+1}^{n+1}(\vec{x})\equiv[\vec{x}^{*}\in S^{n+1}A]$
\end_inset

.
\end_layout

\begin_layout Standard
Remark:
 Note that,
 by definition,
 if 
\begin_inset Formula $(\beta,mA,A,S^{0}A,\dots,S^{n+1}A)$
\end_inset

 is a good sequence and 
\begin_inset Formula $n\geq0$
\end_inset

,
 we also have that 
\begin_inset Formula $(\beta,(S^{n+1}A,mA),A,S^{0}A,\dots,S^{n}A)$
\end_inset

 is also a good sequence (for a smaller value of 
\begin_inset Formula $n$
\end_inset

),
 and thus the element 
\begin_inset Formula $w=w^{n+1}(\beta,mA,A,S^{0}A,\dots,S^{n+1})=w^{n}(\beta,(S^{n+1}A,mA),A,S^{0}A,\dots,S^{n}A)$
\end_inset

 will also satisfy:
 
\begin_inset Formula $S^{n}(\vec{x})\equiv[\vec{x}^{*}\in S^{n}A]$
\end_inset

 for all tuples of elements of 
\begin_inset Formula $A\cup\{w\}$
\end_inset

,
 and inductively for lower indices.
 The case of 
\begin_inset Formula $S^{0}$
\end_inset

 is an edge case,
 but the definition of good sequence still ensures that 
\begin_inset Formula $S^{0}(x,y)\equiv[(x,y)^{*}\in S^{0}A]$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
For every other triplet of elements from 
\begin_inset Formula $V_{\alpha+1}$
\end_inset

,
 set 
\begin_inset Formula $S_{\alpha+1}^{n+1}(\vec{x})$
\end_inset

 to hold true.
\end_layout

\begin_layout Standard
Note that the first and second item in the definition do not contradict each other:
 If a tuple 
\begin_inset Formula $\vec{x}$
\end_inset

 fits both bullet points,
 then either all its elements are in 
\begin_inset Formula $A$
\end_inset

,
 in which case the definition of good sequence ensures that there is agreement between both possible definitions of 
\begin_inset Formula $S_{\alpha+1}^{n+1}(\vec{x})$
\end_inset

,
 or one of its elements is 
\begin_inset Formula $w=w^{n+1}(\beta,mA,A,\dots,S^{n+1}A)$
\end_inset

,
 in which case 
\begin_inset Formula $S_{\gamma}^{n+1}(\vec{x})$
\end_inset

 would have been defined to agree with the second bullet point for 
\begin_inset Formula $\gamma$
\end_inset

 the smallest ordinal such that 
\begin_inset Formula $w\in V_{\gamma}$
\end_inset

.
\end_layout

\begin_layout Standard
This induces a well-defined relation 
\begin_inset Formula $S^{n+1}$
\end_inset

,
 whose main defining properties are as follows:
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:sneg"

\end_inset

Provably in 
\begin_inset Formula $\ZFniptc$
\end_inset

,
 
\begin_inset Formula $\neg S^{n}(\vec{x})$
\end_inset

 iff 
\begin_inset Formula $\forall_{y}S^{n+1}(\vec{x},y)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:sflex_general"

\end_inset

Let 
\begin_inset Formula $M$
\end_inset

 be a model of 
\begin_inset Formula $\ZFniptc$
\end_inset

.
 Let 
\begin_inset Formula $A$
\end_inset

 be a finite subset of 
\begin_inset Formula $M$
\end_inset

,
 and suppose that we wish to find an element 
\begin_inset Formula $w$
\end_inset

 that relates to all elements of 
\begin_inset Formula $A$
\end_inset

 with regard to the predicates 
\begin_inset Formula $S^{0},\dots,S^{n+1}$
\end_inset

 in a prescribed manner.
 The following is a sufficient condition for there to exist an element 
\begin_inset Formula $w$
\end_inset

 of 
\begin_inset Formula $M$
\end_inset

 satisfying this prescription:
 For every 
\begin_inset Formula $0\leq i\leq n$
\end_inset

,
 the prescription satisfies the rules
\end_layout

\begin_deeper
\begin_layout Itemize
The prescription agrees with the pre-existing relations on tuples that don't contain any instance of 
\begin_inset Formula $w$
\end_inset

,
\end_layout

\begin_layout Itemize
For all 
\begin_inset Formula $x\in A\cup\{w\}$
\end_inset

,
 it is prescribed that 
\begin_inset Formula $S^{0}(x,w)$
\end_inset

 and 
\begin_inset Formula $S^{0}(w,x)$
\end_inset

.
\end_layout

\begin_layout Itemize
For all 
\begin_inset Formula $(\vec{x},y)\in(A\cup\{w\})^{i+2}$
\end_inset

 such that 
\begin_inset Formula $\neg S^{i}(\vec{x})$
\end_inset

 is prescribed,
 it is also prescribed that 
\begin_inset Formula $S^{i+1}(\vec{x},y)$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Lemma
These two properties are enough to establish:
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:gen_pakhomov_jump_inversion"

\end_inset

Let 
\begin_inset Formula $D$
\end_inset

 be an 
\begin_inset Formula $X'$
\end_inset

-computable model of 
\begin_inset Formula $T^{n}$
\end_inset

 in the predicates 
\begin_inset Formula $S^{i},\dots,S^{n}$
\end_inset

,
 with 
\begin_inset Formula $i<n$
\end_inset

.
 Then,
 the reduct 
\begin_inset Formula $D\upto(S^{i+1},\dots,S^{n})$
\end_inset

 admits an 
\begin_inset Formula $X$
\end_inset

-computable copy.
\end_layout

\begin_layout Remark
The same reasoning used in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rmk:sjipakhomov1"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 will show that 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:gen_pakhomov_jump_inversion"

\end_inset

 is an example of a Strong Jump Inversion result in the strong sense of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rmk:jumpinversion"

\end_inset

.
 More precisely,
 that reasoning shows that the structure 
\begin_inset Formula $(D,S^{i},\dots,S^{n})$
\end_inset

 is a structural jump of 
\begin_inset Formula $(D,S^{i+1},\dots,S^{n})$
\end_inset

.
\end_layout

\begin_layout Proof
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:gen_pakhomov_jump_inversion"

\end_inset


\end_layout

\end_inset

We will apply 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 to 
\begin_inset Formula $D$
\end_inset

 which,
 as an 
\begin_inset Formula $X'$
\end_inset

-computable model over a finite language,
 is also an 
\begin_inset Formula $X'$
\end_inset

-computable 
\begin_inset Formula $X$
\end_inset

-c.e.-typed model.
 We need only establish that 
\begin_inset Formula $D$
\end_inset

 has the QETP over 
\begin_inset Formula $\Lang=(S^{i+1},\dots,S^{n})$
\end_inset

 (plus negations) and 
\begin_inset Formula $\Lang'=(S^{i},\dots,S^{n})$
\end_inset

 (plus negations).
\begin_inset FormulaMacro
\newcommand{\abs}[1]{\left|#1\right|}
\end_inset


\end_layout

\begin_layout Proof
We construct 
\begin_inset Formula $\chi$
\end_inset

,
 
\begin_inset Formula $\tau$
\end_inset

,
 and 
\begin_inset Formula $\etau$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize
First,
 we construct 
\begin_inset Formula $\chi_{q}$
\end_inset

.
 We assume without loss of generality that 
\begin_inset Formula $q$
\end_inset

 is a quantifier-free type all whose variables are distinct (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rmk:assumeq"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

).
\end_layout

\begin_deeper
\begin_layout Standard
We start by considering the case where 
\begin_inset Formula $q(\vec{x},y)$
\end_inset

 only has one 
\begin_inset Formula $y$
\end_inset

-variable.
 In this case,
 the formula 
\begin_inset Formula $\exists_{y}q(\vec{x},y)$
\end_inset

 is true if,
 and only if,
 there exists an element 
\begin_inset Formula $y$
\end_inset

 satisfying a certain prescription of predicates 
\begin_inset Formula $S^{i+1},\dots,S^{n}$
\end_inset

.
 We show that the following three statements are equivalent:
\end_layout

\begin_layout Itemize
\begin_inset Formula $P(\vec{x})\equiv\exists_{y}q(\vec{x},y)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $Q(\vec{x})$
\end_inset

:
 For every instance of 
\begin_inset Formula $\neg S^{j+1}(\vec{z}_{0},z_{1})$
\end_inset

 in 
\begin_inset Formula $q(\vec{x},y)$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize
If 
\begin_inset Formula $j>i$
\end_inset

,
 we require that 
\begin_inset Formula $S^{j}(\vec{z}_{0})$
\end_inset

 be in 
\begin_inset Formula $q$
\end_inset

,
 and
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Note:
 This demand is happening outside of first-order logic.
 Rather,
 it's a check that we metatheoretically make of 
\begin_inset Formula $q(\vec{x},y)$
\end_inset

,
 and if this check is failed,
 we set 
\begin_inset Formula $Q(\vec{x})\equiv\bot$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $j=i$
\end_inset

,
 
\begin_inset Formula $z_{1}\equiv y$
\end_inset

,
 and 
\begin_inset Formula $\vec{z}_{0}$
\end_inset

 is a subtuple of 
\begin_inset Formula $\vec{x}$
\end_inset

,
 we require 
\begin_inset Formula $S^{i}(\vec{z}_{0})$
\end_inset

,
\end_layout

\begin_layout Standard
Moreover,
 we also demand 
\begin_inset Formula $(q\upto\vec{x})(\vec{x})$
\end_inset

,
 i.e.
\begin_inset space \space{}
\end_inset

whatever demand 
\begin_inset Formula $q$
\end_inset

 makes of the tuple 
\begin_inset Formula $\vec{x}$
\end_inset

,
 we also demand it.
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $R(\vec{x})\equiv$
\end_inset

 There is a 
\begin_inset Formula $y$
\end_inset

 such that 
\begin_inset Formula $q(\vec{x},y)$
\end_inset

 and the relations 
\begin_inset Formula $S^{0}$
\end_inset

 to 
\begin_inset Formula $S^{i}$
\end_inset

 hold for all tuples including elements from 
\begin_inset Formula $(\vec{x},y)$
\end_inset

 and at least one instance of 
\begin_inset Formula $y$
\end_inset


\begin_inset Formula $)$
\end_inset

.
\end_layout

\begin_layout Standard
Here is the proof.
 First,
 
\begin_inset Formula $P(\vec{x})\rightarrow Q(\vec{x})$
\end_inset

 follows from the fact that 
\begin_inset Formula $\forall_{\vec{z}_{0}}(\exists_{z_{1}}\neg S^{j+1}(\vec{z}_{0},z_{1}))\rightarrow S^{j}(\vec{z}_{0})$
\end_inset

 (and the assumption that 
\begin_inset Formula $q$
\end_inset

 is a type).
 Second,
 
\begin_inset Formula $Q(\vec{x})\rightarrow R(\vec{x})$
\end_inset

 follows by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:sflex_general"

\end_inset

 as follows:
 
\begin_inset Formula $R(\vec{x})$
\end_inset

 is true if we can find an element 
\begin_inset Formula $w$
\end_inset

 that relates to the elements of 
\begin_inset Formula $\vec{x}$
\end_inset

 in a certain manner.
 This manner consists of using 
\begin_inset Formula $q$
\end_inset

 to dictate 
\begin_inset Formula $S^{i+1}$
\end_inset

 to 
\begin_inset Formula $S^{n}$
\end_inset

,
 and setting all 
\begin_inset Formula $S^{0}$
\end_inset

 to 
\begin_inset Formula $S^{i}$
\end_inset

 as true for tuples containing 
\begin_inset Formula $w$
\end_inset

 and whatever-it-already-is for tuples that do not.
 Finally,
 
\begin_inset Formula $R(\vec{x})$
\end_inset

 obviously implies 
\begin_inset Formula $P(\vec{x})$
\end_inset

.
\end_layout

\begin_layout Standard
Now,
 still in the case where there is only one 
\begin_inset Formula $y$
\end_inset

-variable,
 we set 
\begin_inset Formula $\chi_{q}(\vec{x})\equiv Q(\vec{x})$
\end_inset

 as above.
 We will now handle the case where there are two 
\begin_inset Formula $y$
\end_inset

-variables,
 say 
\begin_inset Formula $y_{1}$
\end_inset

 and 
\begin_inset Formula $y_{2}$
\end_inset

,
 and an obvious induction will handle the general case.
 We will use the formulas 
\begin_inset Formula $P$
\end_inset

,
 
\begin_inset Formula $Q$
\end_inset

,
 and 
\begin_inset Formula $R$
\end_inset

 constructed above for different formulas 
\begin_inset Formula $q$
\end_inset

.
 We will use a subscript to indicate which formula 
\begin_inset Formula $q$
\end_inset

 is being used.
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $q(\vec{x},y_{1},y_{2})$
\end_inset

 be a quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

-type.
 Then,
 let us look at 
\begin_inset Formula $\chi_{q}(\vec{x},y_{1})$
\end_inset

.
 As above,
 it's either 
\begin_inset Formula $\bot$
\end_inset

 (if the first bullet point of the definition of 
\begin_inset Formula $Q_{q}(\vec{x},y_{1})$
\end_inset

 fails),
 in which case the quantifier elimination is trivial,
 or otherwise it consists of 
\begin_inset Formula $q\upto(\vec{x},y_{1})$
\end_inset

,
 together with a few 
\emph on
positive
\emph default
 requirements of type 
\begin_inset Formula $S^{i}(\vec{z}_{0})$
\end_inset

 with 
\begin_inset Formula $\vec{z}_{0}$
\end_inset

 a subtuple of 
\begin_inset Formula $(\vec{x},y_{1})$
\end_inset

.
 Let 
\begin_inset Formula $q'(\vec{x},y_{1})$
\end_inset

 be 
\begin_inset Formula $q\upto(\vec{x},y_{1})$
\end_inset

 together with those requirements that include 
\begin_inset Formula $y_{1}$
\end_inset

,
 and 
\begin_inset Formula $q^{*}(\vec{x})$
\end_inset

 be the remainder of these requirements.
 Note that
\begin_inset Formula 
\[
\exists_{y_{1}}\exists_{y_{2}}q(\vec{x},y_{1},y_{2})\leftrightarrow\exists_{y_{1}}\chi_{q}(\vec{x},y_{1})\leftrightarrow q^{*}(\vec{x})\land\exists_{y_{1}}q'(\vec{x},y_{1}),
\]

\end_inset

and crucially that,
 since all 
\begin_inset Formula $S^{i}$
\end_inset

-requirements made by 
\begin_inset Formula $q'$
\end_inset

 are positive,
 
\begin_inset Formula $\exists_{y_{1}}q'(\vec{x},y_{1})$
\end_inset

 is logically between 
\begin_inset Formula $P_{q'}(\vec{x})$
\end_inset

 and 
\begin_inset Formula $R_{q'}(\vec{x})$
\end_inset

,
 and hence equivalent to both,
 and hence equivalent to 
\begin_inset Formula $Q_{q'}(\vec{x})$
\end_inset

.
 Thus,
 we conclude 
\begin_inset Formula $\exists_{\vec{y}}q(\vec{x},\vec{y})\leftrightarrow q^{*}(\vec{x})\land Q_{q'}(\vec{x})$
\end_inset

,
 and so we define the latter as 
\begin_inset Formula $\chi_{q}$
\end_inset

 in this scenario.
 The induction continues in a similar fashion,
 in the event that there are more 
\begin_inset Formula $y$
\end_inset

-variables,
 with the essential point being that every 
\begin_inset Formula $S^{i}$
\end_inset

-demand being made at any step is positive.
\end_layout

\end_deeper
\begin_layout Itemize
Now,
 we construct 
\begin_inset Formula $\tau$
\end_inset

.
 Given 
\begin_inset Formula $q(\vec{x},y,\vec{z})$
\end_inset

,
 we set 
\begin_inset Formula $\tau_{q\top}(\vec{x},y)$
\end_inset

 to be the demand that every 
\begin_inset Formula $S^{i}$
\end_inset

-relation including 
\begin_inset Formula $y$
\end_inset

 at least once holds,
 and that 
\begin_inset Formula $\chi_{q}(\vec{x})$
\end_inset

 holds.
\end_layout

\begin_layout Itemize
Finally,
 
\begin_inset Formula $\etau_{q\top Q}(\vec{x})$
\end_inset

 is simply 
\begin_inset Formula $\chi_{Q}(\vec{x})$
\end_inset

.
\end_layout

\begin_layout Standard
The proof that these formulas are witnesses to the QETP is simple and follows the same 
\begin_inset Formula $P$
\end_inset

,
 
\begin_inset Formula $Q$
\end_inset

,
 
\begin_inset Formula $R$
\end_inset

 reasoning used to establish that 
\begin_inset Formula $\chi_{q}(\vec{x})\leftrightarrow\exists_{y}q(\vec{x},y)$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:nestedpakhomov"

\end_inset

 immediately follows.
\end_layout

\begin_layout Standard
As explained in the introduction,
 we obtain as a corollary:
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:pakhomov_answer"

\end_inset

For every 
\begin_inset Formula $n$
\end_inset

,
 there is a theory definitionally equivalent to 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\mathsf{PA}$
\end_inset

 plus all true 
\begin_inset Formula $\Pi_{n}$
\end_inset

 sentences
\begin_inset Quotes erd
\end_inset

 that admits a computable non-standard model.
\end_layout

\begin_layout Section
Further Questions
\end_layout

\begin_layout Standard
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:gen_pakhomov_jump_inversion"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 we were able to get the complexity of models down by 
\begin_inset Quotes eld
\end_inset

one jump
\begin_inset Quotes erd
\end_inset

,
 turning a 
\begin_inset Formula $0'$
\end_inset

-computable model of a c.e.
\begin_inset space \space{}
\end_inset

theory into a computable model.
 However,
 a c.e.
\begin_inset space \space{}
\end_inset

theory admits models with complexity far below 
\begin_inset Formula $0'$
\end_inset

.
 We wonder if this could be exploited to obtain stronger results.
\end_layout

\begin_layout Question
Is there something else that can be said beyond 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:gen_pakhomov_jump_inversion"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 in the assumption that we are given,
 say,
 a low model instead of a merely 
\begin_inset Formula $0'$
\end_inset

-computable model?
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
As always with this kind of work,
 one may wonder whether there exist less artificial theories or predicates that could have filled the role of our predicates 
\begin_inset Formula $S^{1}$
\end_inset

,
 
\begin_inset Formula $S^{2}$
\end_inset

,
 etc.
 In keeping with 
\begin_inset CommandInset citation
LatexCommand cite
key "lutz_walsh_tennenbaum"
literal "false"

\end_inset

,
 we define a 
\begin_inset Quotes els
\end_inset

natural
\begin_inset Quotes ers
\end_inset

 theory or predicate as one that has been studied by mathematicians who are not logicians.
\end_layout

\begin_layout Question
\begin_inset CommandInset label
LatexCommand label
name "question:natural1"

\end_inset

Does there exist a natural theory that is definitionally equivalent to 
\begin_inset Formula $\mathsf{PA}$
\end_inset

 and admits a non-standard computable model?
\end_layout

\begin_layout Standard
As a dual to 
\begin_inset CommandInset ref
LatexCommand formatted
reference "question:natural1"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 once one has been made aware of the role of the signature in Tennenbaum's theorem,
 one may think to study more deeply the impact that the signature has on the complexity of nonstandard models of 
\begin_inset Formula $\mathsf{PA}$
\end_inset

.
 For example:
 It is a standard theorem (or definition) that a 
\begin_inset Formula $\mathrm{PA}$
\end_inset

 degree is the same as one which computes a nonstandard model of 
\begin_inset Formula $\mathsf{PA}$
\end_inset

.
 On the other hand,
 we saw that there is a computable nonstandard model of the definitionally equivalent theory 
\begin_inset Formula $T_{0}$
\end_inset

 constructed by Pakhomov – and hence,
 by a theorem of Knight 
\begin_inset CommandInset citation
LatexCommand cite
key "knight_degrees_coded_in_jumps"
literal "false"

\end_inset

,
 there exists one in every degree.
 Let us define,
 for a theory 
\begin_inset Formula $T$
\end_inset

 that is definitionally equivalent to 
\begin_inset Formula $\mathsf{PA}$
\end_inset

,
 its 
\emph on
nonstandard spectrum
\emph default
 as the set of degrees of nonstandard models of 
\begin_inset Formula $T$
\end_inset

.
\end_layout

\begin_layout Question
If 
\begin_inset Formula $T$
\end_inset

 is a c.e.
\begin_inset space \space{}
\end_inset

theory that is definitionally equivalent to 
\begin_inset Formula $\mathsf{PA}$
\end_inset

,
 we can see that its nonstandard spectrum is at most the set of all Turing degrees,
 and at least the set of all 
\begin_inset Formula $\mathrm{PA}$
\end_inset

 degrees.
 Does there exist such a theory whose nonstandard spectrum is strictly in-between these two cases?
 More generally,
 what can the nonstandard spectrum of a c.e.
\begin_inset space \space{}
\end_inset

theory definitionally equivalent to 
\begin_inset Formula $\mathsf{PA}$
\end_inset

 look like?
\end_layout

\begin_layout Standard
The methods used in this paper are too coarse to address this question;
 they would have to be cleverly modified to stop the nonstandard spectrum from including 
\begin_inset Formula $0$
\end_inset

.
\end_layout

\begin_layout Standard
As a dual question,
 albeit unrelated to the contents of this paper:
 We mentioned in the introduction that Lutz and Walsh 
\begin_inset CommandInset citation
LatexCommand cite
key "lutz_walsh_tennenbaum"
literal "false"

\end_inset

 produced a c.e.
\begin_inset space \space{}
\end_inset

consistent theory such that no definitionally equivalent theory admits a computable model.
 To be more precise,
 they actually constructed an entire family of c.e.
\begin_inset space \space{}
\end_inset

consistent theories 
\begin_inset Formula $T_{\mathrm{LW}}(R)$
\end_inset

,
 parametrized by an infinite computable binary tree 
\begin_inset Formula $R$
\end_inset

 none of whose paths are 
\begin_inset Quotes eld
\end_inset

guessable
\begin_inset Quotes erd
\end_inset

 (a term defined in 
\begin_inset CommandInset citation
LatexCommand cite
key "lutz_walsh_tennenbaum"
literal "false"

\end_inset

),
 such that no model of any theory definitionally equivalent to 
\begin_inset Formula $T_{\mathrm{LW}}(R)$
\end_inset

 admits a computable model.
 We think it would be interesting to ask how close we can get such models to computable.
\end_layout

\begin_layout Question
Define the Lutz–Walsh spectrum of an infinite computable binary tree 
\begin_inset Formula $R$
\end_inset

 none of whose paths are guessable,
 say 
\begin_inset Formula $\mathrm{LWSpec}(R)$
\end_inset

,
 as the set of Turing degrees that compute a model of a theory definitionally equivalent to 
\begin_inset Formula $T_{\mathrm{LW}}(R)$
\end_inset

.
 It is clear that this 
\begin_inset Formula $\mathrm{LWSpec}(R)$
\end_inset

 always contains all 
\begin_inset Formula $\mathrm{PA}$
\end_inset

 degrees,
 and in 
\begin_inset CommandInset citation
LatexCommand cite
key "lutz_walsh_tennenbaum"
literal "false"

\end_inset

 it is proven that 
\begin_inset Formula $\mathrm{LWSpec}(R)$
\end_inset

 does not contain 
\begin_inset Formula $0$
\end_inset

 (if,
 again,
 none of the paths of 
\begin_inset Formula $R$
\end_inset

 are guessable).
 Does 
\begin_inset Formula $\mathrm{LWSpec}(R)$
\end_inset

 ever contain any degrees that are not 
\begin_inset Formula $\mathrm{PA}$
\end_inset

?
 If so,
 how far from 
\begin_inset Formula $\mathrm{PA}$
\end_inset

 can we get?
 Is there such a tree 
\begin_inset Formula $R$
\end_inset

 for which 
\begin_inset Formula $\mathrm{LWSpec}(R)$
\end_inset

 consists of all non-zero degrees?
 Is there any nonzero degree that can never be in 
\begin_inset Formula $\mathrm{LWSpec}(R)$
\end_inset

?
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
In the statement of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:nestedpakhomov"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 the arity of the predicate used to replace set inclusion increased by 
\begin_inset Formula $1$
\end_inset

 for every jump in complexity.
 We wonder if this is a logical necessity or merely an artifact of our construction.
\end_layout

\begin_layout Question
For a given value of 
\begin_inset Formula $n$
\end_inset

,
 does there exist a theory 
\begin_inset Formula $T_{Q}^{n}$
\end_inset

,
 axiomatizing a single ternary predicate 
\begin_inset Formula $Q(x,y,z)$
\end_inset

,
 such that 
\begin_inset Formula $T_{Q}^{n}$
\end_inset

 is definitionally equivalent to 
\begin_inset Formula $\mathsf{PA}$
\end_inset

 plus 
\begin_inset Quotes els
\end_inset

all 
\begin_inset Formula $\Pi_{n}$
\end_inset

 truths
\begin_inset Quotes ers
\end_inset

 which admits a computable nonstandard model?
 What if we require the predicate to be binary,
 instead?
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Regarding our jump inversion theorem,
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 the following question remains open:
\end_layout

\begin_layout Question
Does there exist a proof of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:JIbool"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 (jump inversion for Boolean algebras) as a corollary of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

?
\end_layout

\begin_layout Standard
While 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 guarantees the existence of a 
\begin_inset Formula $0'$
\end_inset

-computable isomorphism between the original structure and its computable copy,
 most results in the literature can only guarantee (out of necessity) a 
\begin_inset Formula $0''$
\end_inset

 or 
\begin_inset Formula $0'''$
\end_inset

-computable isomorphism.
 This is explained by the fact that,
 in our proofs,
 we must first create a 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed copy which is isomorphic to the original structure,
 though this isomorphism may itself need to be complex.
 Hirschfeldt asked whether one could obtain a more direct result,
 for example by weakening the assumptions of the QETP.
\end_layout

\begin_layout Question
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Hirschfeldt
\end_layout

\end_inset

Does there exist a version of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 that requires weaker assumptions,
 possibly using an infinite injury method instead of finite injury,
 from which theorems such as 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:JIlinear-1"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 (jump inversion for linear orders) or 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:eqvinf"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 (jump inversion for equivalence relations with infinitely many infinite classes) may be obtained more easily?
\end_layout

\begin_layout Standard
Many general results in computable structure theory necessitate the use of a finite relational signature,
 oftentimes for reasons similar the ones discussed at the start of Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:cetypedstructures"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
 It was for these reasons that we introduced the notion of 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed structure.
 We wonder if our definition would be applicable to other scenarios.
\end_layout

\begin_layout Question
Are there results in the literature,
 applicable to finite relational signatures,
 which could be further (and usefully) generalized using the notion of 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed structure?
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
In Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:qetp"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 we found it useful to work with 
\begin_inset Formula $\llorc$
\end_inset

 formulas,
 which are related to but not exactly the same as 
\begin_inset Formula $\Sigma_{1}^{c}$
\end_inset

 formulas.
 Ash,
 Knight,
 Manasse and Slaman showed that the definability of a relation by a 
\begin_inset Formula $\Sigma_{1}^{c}$
\end_inset

 formula is related to computability-theoretic properties,
 namely the notion of being a r.i.c.e.
 (relatively intrinsically c.e.) relation;
 see 
\begin_inset CommandInset citation
LatexCommand cite
key "montalban_cst"
posttextlist "montalban_cst Theorem II.16"
literal "false"

\end_inset

 for details.
 We wonder if 
\begin_inset Formula $\llorc$
\end_inset

 formulas admit a similar treatment.
\end_layout

\begin_layout Question
Is there a computability-theoretic characterization of those relations in a structure that are definable by a 
\begin_inset Formula $\llorc$
\end_inset

 formula?
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "bibliography"
options "plain"
encoding "default"

\end_inset


\end_layout

\end_body
\end_document
