#LyX 2.4 created this file. For more info see https://www.lyx.org/
\lyxformat 620
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble

\usepackage{listings}
\lstset{
basicstyle=\ttfamily\footnotesize,
keepspaces=true,
tabsize=4,
breaklines=true,
columns=fullflexible,
mathescape=true
}
\usepackage{fullpage}
\usepackage{braket}

\setlist[enumerate,2]{ref=\theenumi.\theenumii}
\setlist[enumerate,3]{ref=\theenumi.\theenumii.\theenumiii}
\setlist[enumerate,4]{ref=\theenumi.\theenumii.\theenumiii.\theenumiv}


\newref{sec}{refcmd={Section \ref{#1}}}

\usepackage[style=numeric]{biblatex}
\DeclareFieldFormat{postnote}{#1}
\end_preamble
\use_default_options true
\begin_modules
duarte_theorems
enumitem
InStar
\end_modules
\maintain_unincluded_children no
\language english
\language_package default
\inputencoding auto-legacy
\fontencoding auto
\font_roman "lmodern" "default"
\font_sans "lmss" "default"
\font_typewriter "lmtt" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_roman_osf false
\font_sans_osf false
\font_typewriter_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 1
\bibtex_command default
\index_command default
\float_placement H
\float_alignment class
\paperfontsize default
\spacing single
\use_hyperref false
\papersize letter
\use_geometry false
\use_package amsmath 2
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine biblatex
\cite_engine_type authoryear
\biblio_style plain
\biblatex_bibstyle numeric
\biblatex_citestyle numeric
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_formatted_ref 1
\use_minted 0
\use_lineno 0
\index Index
\shortcut idx
\color #008000
\end_index
\spellchecker_ignore english QETP
\spellchecker_ignore english QEWTP
\spellchecker_ignore english WQETP
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tablestyle default
\tracking_changes false
\output_changes false
\change_bars false
\postpone_fragile_content false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\docbook_table_output 0
\docbook_mathml_prefix 1
\end_header

\begin_body

\begin_layout Title
Escaping Tennenbaum's Theorem and a Strong Jump Inversion Theorem
\end_layout

\begin_layout Author
Duarte Maia
\end_layout

\begin_layout In Preamble
\begin_inset FormulaMacro
\newcommand{\N}{\mathbb{N}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Z}{\mathbb{Z}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Q}{\mathbb{Q}}
\end_inset


\end_layout

\begin_layout In Preamble
\begin_inset FormulaMacro
\newcommand{\Lang}{\mathcal{L}}
\end_inset


\end_layout

\begin_layout In Preamble
\begin_inset FormulaMacro
\newcommand{\iswd}{\mathord{\downarrow}}
\end_inset


\end_layout

\begin_layout In Preamble
\begin_inset FormulaMacro
\newcommand{\isnotwd}{\mathord{\uparrow}}
\end_inset


\end_layout

\begin_layout In Preamble
\begin_inset FormulaMacro
\newcommand{\turing}{\mathrm{T}}
\end_inset


\end_layout

\begin_layout In Preamble
\begin_inset FormulaMacro
\newcommand{\upto}{\mathord{\upharpoonright}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\ZFniptc}{\mathsf{ZF}\mathord{-}\mathsf{inf}\mathord{+}\mathsf{TC}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\ZFfinptc}{\mathsf{ZFfin}\mathord{+}\mathsf{TC}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\restrict}[1]{\left.#1\right|}
\end_inset


\begin_inset FormulaMacro
\newcommand{\PP}{\mathcal{P}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\PPfin}{\PP^{\mathrm{fin}}}
\end_inset


\end_layout

\begin_layout In Preamble
\begin_inset FormulaMacro
\newcommand{\llor}{\bigvee\mathchoice{\hspace{-1.1em}}{\hspace{-0.7em}}{\hspace{-0.7em}}{\hspace{-0.6em}}\bigvee}
{\bigvee\bigvee}
\end_inset


\begin_inset FormulaMacro
\newcommand{\lland}{\bigwedge\mathchoice{\hspace{-1.1em}}{\hspace{-0.7em}}{\hspace{-0.7em}}{\hspace{-0.6em}}\bigwedge}
{\bigwedge\bigwedge}
\end_inset


\begin_inset FormulaMacro
\newcommand{\llorc}{\llor^{c}}
\end_inset


\end_layout

\begin_layout Section
Acknowledgements
\end_layout

\begin_layout Standard
I would like to thank Denis Hirschfeldt,
 Miles Kretschmer,
 and Patrick Lutz for their valuable feedback,
 help,
 and advice,
 without which this work would not have been possible.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Subsection
Background I – Tennenbaum's Theorem
\end_layout

\begin_layout Standard
\begin_inset CommandInset citation
LatexCommand nocite
key "lutz_walsh_tennenbaum"
literal "false"

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
introduction to the introduction
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is a well-known result of Stanley Tennenbaum (see e.g.
\begin_inset space \space{}
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "kaye_book"
literal "false"

\end_inset

) that 
\begin_inset Formula $\mathsf{PA}$
\end_inset

,
 the first-order theory of Peano Arithmetic,
 does not admit any non-standard computable model.
 In fact,
 in every non-standard model of 
\begin_inset Formula $\mathsf{PA}$
\end_inset

,
 neither addition nor multiplication are computable.
 Generalizations of this theorem can be found in the literature,
 including versions of it for weaker fragments of 
\begin_inset Formula $\mathsf{PA}$
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "wilmers_PA"
literal "false"

\end_inset

,
 alternative operations 
\begin_inset CommandInset citation
LatexCommand cite
key "schmerl_tennenbaum_recursive_reducts"
literal "false"

\end_inset

,
 and finite set theory 
\begin_inset CommandInset citation
LatexCommand cite
key "mancini_zambella_set_theories,computable_quotient_arithmetic_set_theory"
literal "false"

\end_inset

,
 to name a few.
 However,
 all of these approaches and variations appear to depend heavily on the specificities of the chosen signature.
 This was observed by Fedor Pakhomov,
 who in 2022 
\begin_inset CommandInset citation
LatexCommand cite
key "pakhomov"
literal "false"

\end_inset

 constructed a theory that is definitionally equivalent to 
\begin_inset Formula $\mathsf{PA}$
\end_inset

 (the meaning of which will be described shortly,
 but roughly means 
\begin_inset Quotes eld
\end_inset

it's 
\begin_inset Formula $\mathsf{PA}$
\end_inset

 but with a different choice of signature
\begin_inset Quotes erd
\end_inset

) for which there is a computable nonstandard model.
 This shows that Tennenbaum's theorem really is reliant on the choice of signature.
\end_layout

\begin_layout Standard
Let us elaborate on the way in which this theory is 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\mathsf{PA}$
\end_inset

 with a different signature
\begin_inset Quotes erd
\end_inset

,
 by means of an example.
 In the literature,
 the choice of signature used to define 
\begin_inset Formula $\mathsf{PA}$
\end_inset

 is not set in stone.
 Some authors choose to include a symbol for successor,
 while others choose to omit it.
 This is not a problem,
 as long as a symbol for 
\begin_inset Formula $1$
\end_inset

 and a symbol for 
\begin_inset Formula $+$
\end_inset

 remain in the signature,
 because the successor of 
\begin_inset Formula $x$
\end_inset

 can always be rewritten as 
\begin_inset Formula $x+1$
\end_inset

.
 In a similar vein,
 some authors choose to omit a symbol for 
\begin_inset Formula $1$
\end_inset

,
 opting instead to write it as the successor of zero.
 Thus,
 we have two distinct axiomatizations of 
\begin_inset Formula $\mathsf{PA}$
\end_inset

,
 in two signatures neither of which contains the other,
 but which are intuitively seen to both be able to define the missing symbols from their counterpart.
 This idea of defining new symbols in terms of previous ones underlies the notion of 
\emph on
definitional extension
\emph default
,
 and the way in which 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\mathsf{PA}$
\end_inset

 without successor
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\mathsf{PA}$
\end_inset

 without 
\begin_inset Formula $1$
\end_inset


\begin_inset Quotes erd
\end_inset

 are 
\begin_inset Quotes els
\end_inset

kind of the same theory
\begin_inset Quotes ers
\end_inset

 corresponds to the notion of 
\emph on
definitional equivalence
\emph default
.
\end_layout

\begin_layout Definition
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Definitional Extension
\end_layout

\end_inset

Let 
\begin_inset Formula $T$
\end_inset

 be a theory over a signature 
\begin_inset Formula $\Lang$
\end_inset

.
 A 
\emph on
definitional extension
\emph default
 of 
\begin_inset Formula $T$
\end_inset

 is a theory 
\begin_inset Formula $S\supseteq T$
\end_inset

,
 over a language 
\begin_inset Formula $\Lang'\supseteq\Lang$
\end_inset

,
 such that
\end_layout

\begin_deeper
\begin_layout Itemize
Every theorem of 
\begin_inset Formula $S$
\end_inset

 that only uses symbols from the language 
\begin_inset Formula $\Lang$
\end_inset

 is also a theorem of 
\begin_inset Formula $T$
\end_inset

,
 and
\end_layout

\begin_layout Itemize
Every symbol of 
\begin_inset Formula $\Lang'\setminus\Lang$
\end_inset

 is 
\begin_inset Formula $S$
\end_inset

-definable in terms of symbols in 
\begin_inset Formula $\Lang$
\end_inset

.
 For example,
 if 
\begin_inset Formula $P$
\end_inset

 is any propositional symbol in 
\begin_inset Formula $\Lang'$
\end_inset

,
 there is an 
\begin_inset Formula $\Lang$
\end_inset

-formula 
\begin_inset Formula $\varphi$
\end_inset

 such that
\begin_inset Formula 
\[
S\vdash\forall_{\vec{x}}(P(\vec{x})\leftrightarrow\varphi(\vec{x})),
\]

\end_inset

and a similar statement holds for function symbols.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Definitional Equivalence
\end_layout

\end_inset

Let 
\begin_inset Formula $T_{1}$
\end_inset

 and 
\begin_inset Formula $T_{2}$
\end_inset

 be two theories,
 whose signatures 
\begin_inset Formula $\Lang_{1}$
\end_inset

 and 
\begin_inset Formula $\Lang_{2}$
\end_inset

 respectively are assumed to be disjoint with no loss of generality.
 We say that 
\begin_inset Formula $T_{1}$
\end_inset

 and 
\begin_inset Formula $T_{2}$
\end_inset

 are 
\emph on
definitionally equivalent
\emph default
 if there is a theory 
\begin_inset Formula $T$
\end_inset

 which is a definitional extension of both.
\end_layout

\begin_layout Standard
The notion of definitional equivalence is related,
 but not identical,
 to a more common notion of 
\begin_inset Quotes eld
\end_inset

equal power of theories
\begin_inset Quotes erd
\end_inset

 called bi-interpretability:
 definitional equivalence is strictly stronger,
 though these two notions coincide for most natural examples.
 The interested reader will find a thorough comparison of these two notions in 
\begin_inset CommandInset citation
LatexCommand cite
key "biinterpretabilityvssynonymy"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
A nontrivial example of two definitionally equivalent theories is that of 
\begin_inset Formula $\mathsf{PA}$
\end_inset

 and a specific version of finite set theory,
 which we will refer to as 
\begin_inset Formula $\ZFfinptc$
\end_inset

.
 This theory,
 and a closely related one,
 shall play an important role in the sequel,
 so we formally introduce them to the reader.
\end_layout

\begin_layout Definition
The theory 
\begin_inset Formula $\ZFniptc$
\end_inset

 consists of the usual axioms of Zermelo-Fraenkel set theory,
 with the removal of the axiom of infinity,
 and with the addition of the so-called 
\begin_inset Quotes eld
\end_inset

axiom of transitive closure
\begin_inset Quotes erd
\end_inset

,
 which states that any set is contained in a transitive set.
\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rmk:vonneumann"

\end_inset

Under the remaining axioms of 
\begin_inset Formula $\mathsf{ZF}$
\end_inset

 (minus infinity),
 the axiom of transitive closure is equivalent to the validity of 
\begin_inset Formula $\in$
\end_inset

-induction.
 It is also equivalent (under the same circumstances) to the claim that every set is in some level of the von
\begin_inset space ~
\end_inset

Neumann hierarchy 
\begin_inset Formula $V_{\alpha}$
\end_inset

.
 This is,
 in fact,
 the principal way in which this axiom will be necessary for our work.
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
The theory 
\begin_inset Formula $\ZFfinptc$
\end_inset

 consists of 
\begin_inset Formula $\ZFniptc$
\end_inset

,
 together with the negation of the axiom of infinity.
\end_layout

\begin_layout Remark
The usual theory of 
\begin_inset Formula $\mathsf{ZF}$
\end_inset

 consists of 
\begin_inset Formula $\ZFniptc$
\end_inset

,
 together with the axiom of infinity – the axiom of transitive closure adds no deductive power in this case.
 In other words,
 the axiom of transitive closure can be proven in 
\begin_inset Formula $\mathsf{ZF}$
\end_inset

.
 This is because the transitive closure of a set can be obtained by iterating the operation 
\begin_inset Formula $x\mapsto x\cup\bigcup x$
\end_inset

 countably many times,
 but to define this countable iteration requires recourse to 
\begin_inset Formula $\omega$
\end_inset

.
 This recourse cannot be avoided,
 and indeed it turns out that 
\begin_inset Formula $\mathsf{ZF}-\mathsf{inf}+\neg\mathsf{TC}$
\end_inset

 is consistent;
 see 
\begin_inset CommandInset citation
LatexCommand cite
key "mancini_zambella_set_theories"
literal "false"

\end_inset

 or 
\begin_inset CommandInset citation
LatexCommand cite
key "kaye_wong"
literal "false"

\end_inset

 for a proof.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:pazffineqv"

\end_inset

The theories 
\begin_inset Formula $\mathsf{PA}$
\end_inset

 and 
\begin_inset Formula $\ZFfinptc$
\end_inset

 are definitionally equivalent.
\end_layout

\begin_layout Proof
See 
\begin_inset CommandInset citation
LatexCommand cite
key "kaye_wong"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
Besides serving as an interesting example of definitional equivalence,
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:pazffineqv"

\end_inset

 also underlies the entirety of Pakhomov's construction,
 as it is more convenient to work with a set-theoretical framework than it would be to work directly with 
\begin_inset Formula $\mathsf{PA}$
\end_inset

.
 It also gives us a little bit more flexibility,
 allowing us to construct computable models of theories definitionally equivalent to 
\begin_inset Formula $\mathsf{ZF}$
\end_inset

 or 
\begin_inset Formula $\mathsf{ZFC}$
\end_inset

,
 though we will not explore this avenue in this document.
 We now briefly present the idea behind Pakhomov's construction,
 before elaborating on our original contributions.
\end_layout

\begin_layout Subsection
Pakhomov's Construction and New Results
\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\Tboth}{T_{\mathrm{both}}}
\end_inset

In Fedor Pakhomov's paper 
\begin_inset Quotes eld
\end_inset

How to Escape Tennenbaum's Theorem
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "pakhomov"
literal "false"

\end_inset

,
 the author defines a theory 
\begin_inset Formula $T_{S}$
\end_inset

,
 definitionally equivalent to 
\begin_inset Formula $\ZFniptc$
\end_inset

,
 which axiomatizes a certain ternary predicate 
\begin_inset Formula $S(x,y,z)$
\end_inset

.
 This ternary predicate acts as 
\begin_inset Quotes eld
\end_inset

set membership with witnesses
\begin_inset Quotes erd
\end_inset

,
 and is initially defined in 
\begin_inset Formula $\ZFniptc$
\end_inset

 by transfinite recursion in the von
\begin_inset space ~
\end_inset

Neumann hierarchy (see also 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rmk:vonneumann"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

) in such a way as to satisfy the rule
\begin_inset Formula 
\begin{equation}
\ZFniptc\vdash\forall_{x,y}(x\in y\leftrightarrow\forall_{z}S(x,y,z)).\label{eq:Sdef}
\end{equation}

\end_inset

Since 
\begin_inset Formula $S$
\end_inset

 is initially defined in the context of set theory,
 it is definable in terms of set membership,
 and Equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Sdef"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 ensures that set membership is itself definable in terms of 
\begin_inset Formula $S$
\end_inset

,
 which is why these two theories are definitionally equivalent.
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "def:tboth"

\end_inset

Henceforth,
 
\begin_inset Formula $\Tboth$
\end_inset

 denotes the set of all sentences provable from 
\begin_inset Formula $\ZFniptc$
\end_inset

 plus the definition of 
\begin_inset Formula $S$
\end_inset

 in the signature containing both 
\begin_inset Formula $S$
\end_inset

 and set inclusion.
 Moreover,
 
\begin_inset Formula $T_{S}$
\end_inset

 denotes the theory of 
\begin_inset Formula $S$
\end_inset

,
 that is,
 
\begin_inset Formula $\Tboth$
\end_inset

 restricted to the sentences containing only the predicate 
\begin_inset Formula $S$
\end_inset

.
 
\end_layout

\begin_layout Standard
The main property of this predicate 
\begin_inset Formula $S$
\end_inset

 is that it is endowed with a certain 
\begin_inset Quotes els
\end_inset

flexibility
\begin_inset Quotes ers
\end_inset

 or 
\begin_inset Quotes els
\end_inset

genericity
\begin_inset Quotes ers
\end_inset

.
 As we will later make precise,
 if we are attempting to build a model of 
\begin_inset Formula $T_{S}$
\end_inset

 and make some mistakes along the way,
 any extra 
\begin_inset Quotes els
\end_inset

garbage
\begin_inset Quotes ers
\end_inset

 elements we might have added on accident can still be reused as 
\begin_inset Quotes els
\end_inset

real
\begin_inset Quotes ers
\end_inset

 elements added later on.
 Pakhomov exploits this flexibility to prove:
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:premain"

\end_inset

If 
\begin_inset Formula $T$
\end_inset

 is a consistent c.e.
\begin_inset space \space{}
\end_inset

theory extending 
\begin_inset Formula $T_{S}$
\end_inset

,
 then 
\begin_inset Formula $T$
\end_inset

 admits a computable model.
\end_layout

\begin_layout Standard
Pakhomov proves this using an explicit 
\begin_inset Quotes eld
\end_inset

Henkin construction
\begin_inset Quotes erd
\end_inset

 type of argument.
 We reframe his work in terms of the following stronger result:
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:main"

\end_inset

If 
\begin_inset Formula $M$
\end_inset

 is a 
\begin_inset Formula $0'$
\end_inset

-computable model of 
\begin_inset Formula $T_{S}$
\end_inset

,
 then the reduct of 
\begin_inset Formula $M$
\end_inset

 to 
\begin_inset Formula $S$
\end_inset

 admits a computable copy.
\end_layout

\begin_layout Standard
We provide a brief sketch of how 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main"

\end_inset

 implies 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:premain"

\end_inset

.
 If 
\begin_inset Formula $T$
\end_inset

 is a consistent c.e.
\begin_inset space \space{}
\end_inset

theory extending 
\begin_inset Formula $T_{S}$
\end_inset

,
 consider the consistent c.e.
\begin_inset space \space{}
\end_inset

theory 
\begin_inset Formula $\bar{T}=T\cup T_{\mathrm{both}}$
\end_inset

.
 By the computable completeness theorem,
 there is a 
\begin_inset Formula $0'$
\end_inset

-computable model 
\begin_inset Formula $M$
\end_inset

 of 
\begin_inset Formula $\bar{T}$
\end_inset

,
 whose computable reduct to 
\begin_inset Formula $S$
\end_inset

 is a computable model of 
\begin_inset Formula $T$
\end_inset

 by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main"

\end_inset

.
\end_layout

\begin_layout Standard
We broadly generalize the methods used by Pakhomov to answer a question posed by him in the affirmative:
\end_layout

\begin_layout Question*
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Pakhomov 
\begin_inset CommandInset citation
LatexCommand cite
key "pakhomov"
literal "false"

\end_inset


\end_layout

\end_inset

Fix a value of 
\begin_inset Formula $n$
\end_inset

.
 Are there theories definitionally equivalent to 
\begin_inset Formula $\mathsf{PA}$
\end_inset

 plus 
\begin_inset Quotes eld
\end_inset

all true 
\begin_inset Formula $\Pi_{n}$
\end_inset

 sentences
\begin_inset Quotes erd
\end_inset

 that have computable non-standard models?
\end_layout

\begin_layout Standard
The motivation for this question is that,
 as Pakhomov proved in 
\begin_inset CommandInset citation
LatexCommand cite
key "pakhomov"
literal "false"

\end_inset

,
 this statement is not true 
\begin_inset Quotes els
\end_inset

in the limit
\begin_inset Quotes ers
\end_inset

.
 More precisely,
 Pakhomov showed that any nonstandard model of a theory that is definitionally equivalent to true arithmetic cannot be computable.
 This leads to the question of whether a partial result can be recovered.
\end_layout

\begin_layout Standard
We answer Pakhomov's question via the following improvement on the construction of Pakhomov's theory 
\begin_inset Formula $T_{S}$
\end_inset

:
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:main2"

\end_inset

There is a nested sequence of consistent c.e.
\begin_inset space \space{}
\end_inset

theories 
\begin_inset Formula $\ZFniptc\subseteq T^{0}\subseteq T^{1}\subseteq T^{2}\subseteq\cdots$
\end_inset

 satisfying the following properties:
\end_layout

\begin_deeper
\begin_layout Itemize
Each 
\begin_inset Formula $T^{n}$
\end_inset

 is in the signature containing 
\begin_inset Formula $\in$
\end_inset

 and predicates 
\begin_inset Formula $S^{0}$
\end_inset

,
 
\begin_inset Formula $\dots$
\end_inset

,
 
\begin_inset Formula $S^{n}$
\end_inset

,
 with each 
\begin_inset Formula $S^{i}$
\end_inset

 being an 
\begin_inset Formula $(i+2)$
\end_inset

-ary predicate symbol,
\end_layout

\begin_layout Itemize
All of these extensions are conservative over 
\begin_inset Formula $\ZFniptc$
\end_inset

,
 in the sense that they contain no additional theorems in the predicate 
\begin_inset Formula $\in$
\end_inset

,
\end_layout

\begin_layout Itemize
The predicates 
\begin_inset Formula $\in$
\end_inset

 and 
\begin_inset Formula $S^{n}$
\end_inset

 are definable in terms of the other within 
\begin_inset Formula $T^{n}$
\end_inset

,
 and
\end_layout

\begin_layout Itemize
Given a 
\begin_inset Formula $0'$
\end_inset

-computable model 
\begin_inset Formula $D$
\end_inset

 of 
\begin_inset Formula $T^{n}$
\end_inset

 restricted to the language containing 
\begin_inset Formula $S^{i}$
\end_inset

,
 
\begin_inset Formula $\dots$
\end_inset

,
 and 
\begin_inset Formula $S^{n}$
\end_inset

,
 there is a computable copy 
\begin_inset Formula $M$
\end_inset

 of 
\begin_inset Formula $D\upto(S^{i+1},\dots,S^{n})$
\end_inset

.
\end_layout

\begin_layout Standard
The last item relativizes:
 Given an 
\begin_inset Formula $X'$
\end_inset

-computable model of 
\begin_inset Formula $T^{n}$
\end_inset

 implementing the last 
\begin_inset Formula $k$
\end_inset

 predicates,
 there is an 
\begin_inset Formula $X$
\end_inset

-computable copy of its reduct to the last 
\begin_inset Formula $k-1$
\end_inset

 predicates.
\end_layout

\end_deeper
\begin_layout Remark
The second and third bullet point imply that,
 for every 
\begin_inset Formula $n$
\end_inset

,
 
\begin_inset Formula $\ZFniptc$
\end_inset

 and 
\begin_inset Formula $T^{n}\upto S^{n}$
\end_inset

 are definitionally equivalent.
\end_layout

\begin_layout Standard
From 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main2"

\end_inset

,
 we conclude one of the main results of this paper:
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:nonstdpin"

\end_inset

For every 
\begin_inset Formula $n$
\end_inset

,
 there is a theory definitionally equivalent to 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\mathsf{PA}$
\end_inset

 plus all true 
\begin_inset Formula $\Pi_{n}$
\end_inset

 sentences
\begin_inset Quotes erd
\end_inset

 that admits a computable non-standard model.
\end_layout

\begin_layout Proof
First,
 note that the theory 
\begin_inset Formula $T$
\end_inset

 containing 
\begin_inset Formula $\mathsf{PA}$
\end_inset

 plus all true 
\begin_inset Formula $\Pi_{n}$
\end_inset

 sentences is a 
\begin_inset Formula $0^{(n)}$
\end_inset

-c.e.
\begin_inset space \space{}
\end_inset

theory.
 By the results of Kaye and Wong 
\begin_inset CommandInset citation
LatexCommand cite
key "kaye_wong"
literal "false"

\end_inset

,
 
\begin_inset Formula $\mathsf{PA}$
\end_inset

 is definitionally equivalent to 
\begin_inset Formula $\ZFfinptc$
\end_inset

,
 and therefore 
\begin_inset Formula $T$
\end_inset

 is definitionally equivalent to a 
\begin_inset Formula $0^{(n)}$
\end_inset

-c.e.
\begin_inset space \space{}
\end_inset

extension of the theory 
\begin_inset Formula $T^{n+1}$
\end_inset

 from 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main2"

\end_inset

.
 Say 
\begin_inset Formula $\bar{T}$
\end_inset

 is this theory,
 and let 
\begin_inset Formula $\bar{T}^{+}$
\end_inset

 be the same with an added constant 
\begin_inset Formula $c$
\end_inset

 and an axiom schema ensuring that 
\begin_inset Formula $c$
\end_inset

 is a nonstandard element.
 Let 
\begin_inset Formula $D$
\end_inset

 be a 
\begin_inset Formula $0^{(n+1)}$
\end_inset

-computable model of 
\begin_inset Formula $\bar{T}^{+}$
\end_inset

,
 in the signature containing the 
\begin_inset Formula $n+2$
\end_inset

 predicates 
\begin_inset Formula $S^{0}$
\end_inset

 to 
\begin_inset Formula $S^{n+1}$
\end_inset

,
 which exists by the computable completeness theorem (see 
\begin_inset CommandInset citation
LatexCommand cite
key "harizanov"
literal "false"

\end_inset

).
 Then,
 apply the relativized version of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main2"

\end_inset

 
\begin_inset Formula $n+1$
\end_inset

 times,
 obtaining a computable model of 
\begin_inset Formula $\bar{T}\upto S^{n+1}$
\end_inset

.
 This shows that 
\begin_inset Formula $\bar{T}\upto S^{n+1}$
\end_inset

 is the theory we sought:
 It is definitionally equivalent to 
\begin_inset Formula $\mathsf{PA}$
\end_inset

 plus all true 
\begin_inset Formula $\Pi_{n}$
\end_inset

 sentences,
 and it admits a computable nonstandard model.
\end_layout

\begin_layout Standard
As an aside,
 we note that Pakhomov posed another question in his original paper,
 which has since been answered by Lutz and Walsh.
\end_layout

\begin_layout Question*
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Pakhomov 
\begin_inset CommandInset citation
LatexCommand cite
key "pakhomov"
literal "false"

\end_inset


\end_layout

\end_inset

Is there a c.e.
\begin_inset space \space{}
\end_inset

theory 
\begin_inset Formula $T$
\end_inset

 such that no definitionally equivalent theory 
\begin_inset Formula $T'$
\end_inset

 admits a computable model?
\end_layout

\begin_layout Theorem
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Lutz–Walsh 
\begin_inset CommandInset citation
LatexCommand cite
key "lutz_walsh_tennenbaum"
literal "false"

\end_inset


\end_layout

\end_inset

There is a c.e.
\begin_inset space \space{}
\end_inset

theory 
\begin_inset Formula $T$
\end_inset

 such that every model of every theory 
\begin_inset Formula $T'$
\end_inset

 definitionally equivalent to 
\begin_inset Formula $T$
\end_inset

 is noncomputable.
\end_layout

\begin_layout Subsection
Background II – Strong Jump Inversion
\end_layout

\begin_layout Standard
In the process of answering Pakhomov's question,
 it happened that certain parts of our construction were not specific to the particularities of arithmetic,
 and so we were able to extract a general-purpose theorem for strong jump inversion.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Patrick Lutz was the first person to bring the idea of a broad generalization to my attention.
 He also provided a working conjecture that was very useful in developing the theory.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For our purposes,
 a strong jump inversion type theorem is one of the following form:
 
\begin_inset Quotes eld
\end_inset

If [structure of a certain type with a lot of data] admits a copy computable in 
\begin_inset Formula $X'$
\end_inset

,
 then [reduct of the same structure with fewer data] admits a copy computable in 
\begin_inset Formula $X$
\end_inset

.
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Our definition of strong jump inversion does not agree exactly with other definitions found in the literature,
 e.g.
\begin_inset space \space{}
\end_inset

in Definition 1.1 of 
\begin_inset CommandInset citation
LatexCommand cite
key "strong_jump_inversion"
literal "false"

\end_inset

.
 Nevertheless,
 there is a close relation between the two perspectives,
 enough that we feel justified in referring to the results we cite as 
\begin_inset Quotes eld
\end_inset

strong jump inversion type theorems
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
ehhhh
\end_layout

\end_inset

 Here are a few examples.
 We state them all for the computable case,
 but they all relativize uniformly in the obvious way.
\begin_inset Note Note
status open

\begin_layout Plain Layout
look at montalbans equivalences of jump inversion type theorems,
 hopefully i can get these to actually work
\end_layout

\end_inset


\end_layout

\begin_layout Theorem
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Folklore,
 
\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "cst_downey_melnikov"
posttextlist "cst_downey_melnikov Theorem 9.1.4"
literal "false"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "thm:JIeqv"

\end_inset

Suppose that 
\begin_inset Formula $E$
\end_inset

 is an equivalence relation with infinitely many infinite equivalence classes.
 Let 
\begin_inset Formula $\equiv$
\end_inset

 denote the equivalence relation,
 and for 
\begin_inset Formula $n\in\N$
\end_inset

 let 
\begin_inset Formula $P_{n}(x)$
\end_inset

 be the predicate 
\begin_inset Quotes eld
\end_inset

the equivalence class of 
\begin_inset Formula $x$
\end_inset

 has at least 
\begin_inset Formula $n$
\end_inset

 elements
\begin_inset Quotes erd
\end_inset

.
 If 
\begin_inset Formula $(E,\equiv,\{P_{n}\}_{n\in\N})$
\end_inset

 admits a 
\begin_inset Formula $0'$
\end_inset

-computable copy,
 then 
\begin_inset Formula $(E,\equiv)$
\end_inset

 admits a computable copy.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Theorem
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset CommandInset citation
LatexCommand cite
key "knight_stob_computable_boolean_algebras"
literal "false"

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "thm:JIbool"

\end_inset

Suppose that 
\begin_inset Formula $B$
\end_inset

 is a Boolean algebra,
 and suppose that the structure 
\begin_inset Formula $(B,\land,\lor,\mathrm{isAtom})$
\end_inset

 admits a 
\begin_inset Formula $0'$
\end_inset

-computable copy.
 Then,
 the structure 
\begin_inset Formula $(B,\land,\lor)$
\end_inset

 admits a computable copy.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Theorem
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "montalban_cst"
posttextlist "montalban_cst VII.26"
literal "false"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "thm:JIlinear"

\end_inset

Suppose that 
\begin_inset Formula $L$
\end_inset

 is a linear order for which every element admits a successor and predecessor,
 and suppose that the structure 
\begin_inset Formula $(L,<,S)$
\end_inset

 admits a 
\begin_inset Formula $0'$
\end_inset

-computable copy,
 where 
\begin_inset Formula $S(x,y)$
\end_inset

 is the successor relation.
 Then,
 the structure 
\begin_inset Formula $(L,<)$
\end_inset

 admits a computable copy.
\end_layout

\begin_layout Standard
It would be interesting to find a broad theorem from which Theorems 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:JIeqv"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:JIbool"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:JIlinear"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 could follow as corollaries.
 In this goal,
 we have acheived mixed success.
 We are not the first to seek such a theorem – the 2018 paper 
\begin_inset CommandInset citation
LatexCommand cite
key "strong_jump_inversion"
literal "false"

\end_inset

 also contains a general-purpose theorem from which results related to the above are partially recovered.
 Our theorem seems to follow similar themes as the theorem found in 
\begin_inset CommandInset citation
LatexCommand cite
key "strong_jump_inversion"
literal "false"

\end_inset

,
 but our assumptions have a different flavor and our conclusion goes in a different direction.
 Neither our theorem nor the one in 
\begin_inset CommandInset citation
LatexCommand cite
key "strong_jump_inversion"
literal "false"

\end_inset

 are able to completely subsume Theorems 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:JIeqv"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:JIbool"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:JIlinear"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 and we believe that this is for a good reason,
 as we describe in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rmk:complexityconsiderations"

\end_inset

 below.
\end_layout

\begin_layout Standard
Henceforth,
 we restrict our attention to relational structures.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "def:cetypedpresentation"

\end_inset

Let 
\begin_inset Formula $\Lang'$
\end_inset

 be a computable relational signature.
\begin_inset FormulaMacro
\newcommand{\tp}{\mathrm{tp}}
\end_inset

 A
\emph on
 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed structure
\emph default
 
\begin_inset Formula $D$
\end_inset

 consists of a 
\begin_inset Formula $0'$
\end_inset

-computable function 
\begin_inset Formula $\tau$
\end_inset

,
 whose domain is the finite power-set of an initial segment of 
\begin_inset Formula $\N$
\end_inset

 (this initial segment we call the 
\emph on
domain
\emph default
 of 
\begin_inset Formula $D$
\end_inset

),
 which takes as input the strong index of a finite set of natural numbers 
\begin_inset Formula $\vec{n}=\{n_{0}<n_{1}<\dots<n_{k-1}\}$
\end_inset

 and outputs the c.e.
\begin_inset space \space{}
\end_inset

index 
\begin_inset Formula $\tau(\vec{n})$
\end_inset

 for an atomic 
\begin_inset Formula $\Lang'$
\end_inset

-type 
\begin_inset Formula $\tp(\vec{n})$
\end_inset

 in the variables 
\begin_inset Formula $(x_{n_{0}},\dots,x_{n_{k-1}})$
\end_inset

,
 with the compatibility condition that if 
\begin_inset Formula $\vec{n}\subseteq\vec{m}$
\end_inset

 then 
\begin_inset Formula $\tp(\vec{n})\subseteq\tp(\vec{m})$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
A 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed structure 
\begin_inset Formula $D$
\end_inset

 induces a natural 
\begin_inset Formula $\Lang'$
\end_inset

 structure on the domain of 
\begin_inset Formula $D$
\end_inset

.
 Thus,
 in a slight abuse of notation we often identify 
\begin_inset Formula $D$
\end_inset

 with the 
\begin_inset Formula $\Lang'$
\end_inset

-structure obtained in this manner,
 allowing us to speak,
 for example,
 of an isomorphism between a 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed structure and other structures.
 In particular,
 if 
\begin_inset Formula $D_{0}$
\end_inset

 is a pre-existing 
\begin_inset Formula $\Lang'$
\end_inset

-structure we define a 
\emph on

\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed copy of 
\begin_inset Formula $D_{0}$
\end_inset


\emph default
 to mean a 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed structure 
\begin_inset Formula $D$
\end_inset

 which is isomorphic to 
\begin_inset Formula $D_{0}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "def:ceqe"

\end_inset

Let 
\begin_inset Formula $\Lang\subseteq\Lang'$
\end_inset

 be relational signatures,
 with 
\begin_inset Formula $\Lang'$
\end_inset

 computable and 
\begin_inset Formula $\Lang$
\end_inset

 finite,
 and let 
\begin_inset Formula $D$
\end_inset

 be a structure over 
\begin_inset Formula $\Lang'$
\end_inset

.
 We say that 
\begin_inset Formula $D$
\end_inset

 satisfies the 
\emph on
c.e.
\begin_inset space \space{}
\end_inset

relative quantifier elimination property
\emph default
 (relative to 
\begin_inset Formula $\Lang\subseteq\Lang'$
\end_inset

) if the following properties hold:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

label=(
\backslash
alph*)
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\Lang$
\end_inset

 is closed under negation,
 and includes the predicate 
\begin_inset Formula $\neq$
\end_inset

,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
This assumption is technically not necessary,
 but the definition and subsequent theorems are cleaner if we include it.
\end_layout

\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
We did not explicitly state it in the definition,
 but implicit here is the assumption that if 
\begin_inset Formula $P$
\end_inset

 is a predicate in 
\begin_inset Formula $\Lang$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 is its negation,
 
\begin_inset Formula $D$
\end_inset

 satisfies 
\begin_inset Formula $P(\vec{x})\leftrightarrow\neg Q(\vec{x})$
\end_inset

.
 Likewise,
 we assume that 
\begin_inset Formula $\neq$
\end_inset

 is interpreted in the usual manner.
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
explain this better outside of footnote and include 
\begin_inset Quotes eld
\end_inset

bc changes whats positive
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
For every quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

-formula 
\begin_inset Formula $q(\vec{x},\vec{y})$
\end_inset

 that is realized in 
\begin_inset Formula $D$
\end_inset

 there is a quantifier-free 
\begin_inset Formula $\Lang'$
\end_inset

 
\emph on
positive 
\emph default
formula 
\begin_inset Formula $\chi_{q}(\vec{x})$
\end_inset

,
 computable from 
\begin_inset Formula $q$
\end_inset

,
 such that 
\begin_inset Formula $D\vDash\forall_{\vec{x}}\left[\chi_{q}(\vec{x})\leftrightarrow\exists_{\vec{y}}q(\vec{x},\vec{y})\right]$
\end_inset

,
 and
\end_layout

\begin_layout Enumerate
The set of existential positive 
\begin_inset Formula $\Lang'$
\end_inset

-sentences true in 
\begin_inset Formula $D$
\end_inset

 is c.e.
\end_layout

\end_deeper
\begin_layout Definition
We now state the central result of this paper.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:mainresult"

\end_inset

If 
\begin_inset Formula $D$
\end_inset

 is a 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed structure which satisfies the c.e.
\begin_inset space \space{}
\end_inset

relative quantifier elimination property relative to 
\begin_inset Formula $\Lang\subseteq\Lang'$
\end_inset

,
 then the reduct 
\begin_inset Formula $D\upto\Lang$
\end_inset

 admits a computable copy 
\begin_inset Formula $M$
\end_inset

.
 Moreover,
 there is a 
\begin_inset Formula $0'$
\end_inset

-computable isomorphism of 
\begin_inset Formula $\Lang$
\end_inset

-structures 
\begin_inset Formula $f\colon D\xrightarrow{\cong}M$
\end_inset

.
 This result is uniform,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
To be more precise,
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:mainresult"

\end_inset

 is uniform in the following data:
 An index for 
\begin_inset Formula $D$
\end_inset

,
 and indices for witnesses that 
\begin_inset Formula $D$
\end_inset

 satisfies the c.e.
\begin_inset space \space{}
\end_inset

relative quantifier elimination.
 This includes data such as how to negate symbols in 
\begin_inset Formula $\Lang$
\end_inset

,
 an index for the function 
\begin_inset Formula $q\mapsto\chi_{q}$
\end_inset

,
 and an index for a computable enumeration of the set of existential positive 
\begin_inset Formula $\Lang'$
\end_inset

-sentences true in 
\begin_inset Formula $D$
\end_inset

.
\end_layout

\end_inset

 and relativizes uniformly.
\end_layout

\begin_layout Standard
As previously mentioned,
 we would be happy to obtain pre-existing results from the literature as corollaries of Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:mainresult"

\end_inset

.
 We will now describe the extent to which we were successful in that regard,
 followed by the limitations of this result.
\end_layout

\begin_layout Standard
In the positive side,
 in Section (add reference)
\begin_inset Note Note
status open

\begin_layout Plain Layout
ADD REF
\end_layout

\end_inset

 we obtain Pakhomov's result as a corollary,
 as well as our generalization thereof.
\end_layout

\begin_layout Corollary
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main2"

\end_inset


\end_layout

\end_inset

Let 
\begin_inset Formula $\{T_{i}\}_{i\in\N}$
\end_inset

 be the sequence of theories outlined in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main2"

\end_inset

.
 Then,
 given a 
\begin_inset Formula $0'$
\end_inset

-computable model 
\begin_inset Formula $D$
\end_inset

 of 
\begin_inset Formula $T^{n}$
\end_inset

 restricted to the language containing 
\begin_inset Formula $S^{i}$
\end_inset

,
 
\begin_inset Formula $\dots$
\end_inset

,
 and 
\begin_inset Formula $S^{n}$
\end_inset

,
 there is a computable copy of 
\begin_inset Formula $D\upto(S^{i+1},\dots,S^{n})$
\end_inset

.
 In particular,
 given a 
\begin_inset Formula $0'$
\end_inset

-computable model 
\begin_inset Formula $D$
\end_inset

 of Pakhomov's theory 
\begin_inset Formula $\Tboth$
\end_inset

 (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "def:tboth"

\end_inset

),
 the reduct 
\begin_inset Formula $D\upto S$
\end_inset

 admits a computable copy.
\end_layout

\begin_layout Standard
We are also able to obtain 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:JIeqv"

\end_inset

:
\end_layout

\begin_layout Corollary
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:JIeqv"

\end_inset


\end_layout

\end_inset

Suppose that 
\begin_inset Formula $E$
\end_inset

 is an equivalence relation with infinitely many infinite equivalence classes.
 Let 
\begin_inset Formula $\equiv$
\end_inset

 denote the equivalence relation,
 and for 
\begin_inset Formula $n\in\N$
\end_inset

 let 
\begin_inset Formula $P_{n}(x)$
\end_inset

 be the predicate 
\begin_inset Quotes eld
\end_inset

the equivalence class of 
\begin_inset Formula $x$
\end_inset

 has at least 
\begin_inset Formula $n$
\end_inset

 elements
\begin_inset Quotes erd
\end_inset

.
 Then,
 if 
\begin_inset Formula $(E,\equiv,\{P_{n}\}_{n\in\N})$
\end_inset

 admits a 
\begin_inset Formula $0'$
\end_inset

-computable copy,
 
\begin_inset Formula $(E,\equiv)$
\end_inset

 admits a computable copy.
\end_layout

\begin_layout Standard
Finally,
 we were also able to obtain the following result,
 which is not,
 strictly speaking,
 a strong jump inversion type result,
 but we were able to obtain it by passing through an intermediate structure which we then applied 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:mainresult"

\end_inset

 to:
\end_layout

\begin_layout Corollary
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Khisamiev's Theorem,
 
\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "cst_downey_melnikov"
posttextlist "cst_downey_melnikov Theorem 5.1.41"
literal "false"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset

Every c.e.
\begin_inset space \space{}
\end_inset

presented
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Here we use the word 
\begin_inset Quotes eld
\end_inset

presentation
\begin_inset Quotes erd
\end_inset

 in the sense of abstract algebra:
 A (computably enumerated) list of generators and algebraic equalities between them.
\end_layout

\end_inset

 torsion-free abelian group is isomorphic to a computable group.
 Furthermore,
 if the group is non-trivial,
 then this computable copy can be built uniformly in the index of the c.e.
\begin_inset space \space{}
\end_inset

presentation.
\end_layout

\begin_layout Standard
Now let us discuss the negative side of things.
\end_layout

\begin_layout Claim
Neither 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:JIbool"

\end_inset

 nor 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:JIlinear"

\end_inset

 can be obtained directly from 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:mainresult"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
\end_layout

\begin_layout Standard
Such a claim cannot possibly admit a 
\begin_inset Quotes eld
\end_inset

proof
\begin_inset Quotes erd
\end_inset

 in the usual sense,
 because the word 
\begin_inset Quotes eld
\end_inset

directly
\begin_inset Quotes erd
\end_inset

 allows for much ambiguity.
 Nevertheless,
 we provide a strong plausibility argument as follows:
 Notice that 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:mainresult"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 provides a 
\begin_inset Formula $0'$
\end_inset

-computable isomorphism between the original structure and the computable copy.
 However,
 neither 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:JIbool"

\end_inset

 nor 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:JIlinear"

\end_inset

 can guarantee the same,
 as per the following results:
\end_layout

\begin_layout Proposition
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Unpublished,
 see end of p.
\begin_inset space \space{}
\end_inset

1508 of 
\begin_inset CommandInset citation
LatexCommand cite
key "strong_jump_inversion"
literal "false"

\end_inset


\end_layout

\end_inset

There is a 
\begin_inset Formula $0'$
\end_inset

-computable Boolean algebra 
\begin_inset Formula $(B,\land,\lor,\mathrm{isAtom})$
\end_inset

 that admits no 
\begin_inset Formula $0''$
\end_inset

-computable isomorphism to a computable Boolean algebra 
\begin_inset Formula $(B',\land,\lor)$
\end_inset

.
 In particular,
 it admits no such 
\begin_inset Formula $0'$
\end_inset

-computable isomorphism.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Proposition
There is a 
\begin_inset Formula $0'$
\end_inset

-computable linear order 
\begin_inset Formula $(L,<,S)$
\end_inset

 such that every isomorphism between 
\begin_inset Formula $(L,<)$
\end_inset

 and a computable linear order 
\begin_inset Formula $(L',<)$
\end_inset

 computes 
\begin_inset Formula $0''$
\end_inset

.
 In particular,
 it admits no such 
\begin_inset Formula $0'$
\end_inset

-computable isomorphism.
\end_layout

\begin_layout Standard
It is possible that one or both of Theorems 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:JIbool"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:JIlinear"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 do admit a proof via 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:mainresult"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
 But such a proof would necessarily go through a modification of the original structure that preserves the isomorphism type in some manner,
 though in a way that the isomorphism between the original structure and its modification is allowed to be computationally more complicated than either of these structures.
 We were not imaginative enough to find such a proof.
\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rmk:complexityconsiderations"

\end_inset

Our result is not the only one that is found to be of limited generality due to isomorphism complexity considerations.
 In 
\begin_inset CommandInset citation
LatexCommand cite
key "strong_jump_inversion"
literal "false"

\end_inset

,
 the authors obtain as a corollary of their own general theorem a result strongly related to 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:JIbool"

\end_inset

,
 for the case of Boolean algebras without 
\begin_inset Formula $1$
\end_inset

-atoms.
 Implicitly,
 this weakening is justified through the fact that their argument provides them a 
\begin_inset Formula $0''$
\end_inset

-computable isomorphism between the original Boolean algebra and the computable one.
 To the present author,
 this suggests that any attempt to obtain many jump inversion type theorems from the literature as corollaries of a small collection of results may have to follow a tiered approach:
 One result to encompass the cases where one obtains a 
\begin_inset Formula $0'$
\end_inset

-computable isomorphism,
 a different argument to encompass the cases where one can do no better than a 
\begin_inset Formula $0''$
\end_inset

-computable isomorphism,
 and so on.
\end_layout

\begin_layout Section
A General Jump Inversion Theorem
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "def:limitcomputablestructure"

\end_inset

discuss here the notion of limit computable view of a 
\begin_inset Formula $0'$
\end_inset

-computable structre.
 see montalban and/or d&m for a reference.
 i'm not sure that 
\begin_inset Quotes eld
\end_inset

definition
\begin_inset Quotes erd
\end_inset

 is the right thing to use here.
\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rmk:qftypes-1-1-1"

\end_inset

In the following,
 we restrict our attention to quantifier-free types over finite relational languages with a finite number of variables.
 Such types therefore contain finite amounts of information – one need only specify,
 for every atomic predicate 
\begin_inset Formula $P$
\end_inset

,
 how our variables relate to each other and to the constants in the language.
 Therefore,
 we shall blur the line between type as (finite) set of formulas vs.
 a single formula (namely,
 the conjunction of all of those).
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "def:cetyped-1-1"

\end_inset

A
\emph on
 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed presentation of a structure
\emph default
 
\begin_inset Formula $D$
\end_inset

 over a computable language 
\begin_inset Formula $\Lang'$
\end_inset

 consists of a 
\begin_inset Formula $0'$
\end_inset

-computable process that outputs elements and,
 upon outputting a new element,
 also produces an index that enumerates the atomic 
\begin_inset Formula $\Lang'$
\end_inset

-type of the tuple of elements output until this moment.
 (As a trivial but necessary edge case,
 we assume that we also have access to a c.e.
\begin_inset space \space{}
\end_inset

index for the atomic 
\begin_inset Formula $\Lang'$
\end_inset

-type of the empty tuple,
 which corresponds to an enumeration of the true zero-ary 
\begin_inset Formula $\Lang'$
\end_inset

-predicates in 
\begin_inset Formula $D$
\end_inset

.)
\end_layout

\begin_layout Remark
\begin_inset CommandInset ref
LatexCommand formatted
reference "def:cetyped-1-1"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 is very much not symmetric with regard to negation of predicates.
 It can make a stark difference as to whether our language includes,
 for every predicate 
\begin_inset Formula $P$
\end_inset

,
 its negation 
\begin_inset Formula $\neg P$
\end_inset

 or not.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
We shall work in the Computable Infinitary Language,
 as described in 
\begin_inset CommandInset citation
LatexCommand cite
key "montalban_cst"
posttextlist "montalban_cst Part 2, III"
literal "false"

\end_inset

.
 We will only work with a very small fragment of this language,
 which we now describe.
\end_layout

\begin_layout Definition
Given a relational signature 
\begin_inset Formula $\Lang'$
\end_inset

,
 we define the set of 
\emph on
positive computable quantifier-free disjunctive formulas
\emph default
,
 denoted by 
\begin_inset Formula $\llorc$
\end_inset

,
 as the set of formulas in finitely many variables of the type
\begin_inset Formula 
\[
\varphi(\vec{x})\equiv\llor_{i<\omega}\varphi_{i}(\vec{x}),
\]

\end_inset

where 
\begin_inset Formula $\{\varphi_{i}\}_{i<\omega}$
\end_inset

 is a 
\emph on
computable
\emph default
 sequence of formulas of the type
\begin_inset Formula 
\[
\varphi_{i}(\vec{x})=P_{1}\land\dots\land P_{n},
\]

\end_inset

where each 
\begin_inset Formula $P_{j}$
\end_inset

 denotes a relation in 
\begin_inset Formula $\Lang'$
\end_inset

 being applied to a tuple of variables from 
\begin_inset Formula $\vec{x}$
\end_inset

,
 in any order,
 with the possibility of repeated or omitted variables.
 We also allow for 
\begin_inset Formula $P_{j}$
\end_inset

 to denote 
\begin_inset Formula $\top$
\end_inset

,
 the 
\begin_inset Quotes eld
\end_inset

true
\begin_inset Quotes erd
\end_inset

 predicate,
 and 
\begin_inset Formula $\bot$
\end_inset

,
 the 
\begin_inset Quotes eld
\end_inset

false
\begin_inset Quotes erd
\end_inset

 predicate.
\end_layout

\begin_layout Definition
Given a 
\begin_inset Formula $\llorc$
\end_inset

 formula,
 say 
\begin_inset Formula $\varphi(\vec{x})$
\end_inset

,
 a structure 
\begin_inset Formula $D$
\end_inset

,
 and a tuple of elements 
\begin_inset Formula $\vec{b}$
\end_inset

 of 
\begin_inset Formula $D$
\end_inset

,
 we assign a truth value to the expression 
\begin_inset Formula $D\vDash\varphi(\vec{b})$
\end_inset

 in the obvious way.
 We also assign truth values to 
\begin_inset Formula $D\vDash\alpha$
\end_inset

,
 where 
\begin_inset Formula $\alpha$
\end_inset

 may denote a more complicated expression in the Computable Infinitary Language,
 always with the obvious meaning.
 For example,
 if 
\begin_inset Formula $\varphi(x,y)$
\end_inset

 is a 
\begin_inset Formula $\llorc$
\end_inset

 formula,
 the expression 
\begin_inset Formula $D\vDash\exists_{x}\forall_{y}\varphi(x,y)$
\end_inset

 means:
 
\begin_inset Quotes eld
\end_inset

There is 
\begin_inset Formula $a\in D$
\end_inset

 such that,
 for every 
\begin_inset Formula $b\in D$
\end_inset

,
 we have 
\begin_inset Formula $D\vDash\varphi(a,b)$
\end_inset


\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rmk:llorc"

\end_inset

The main properties of the 
\begin_inset Formula $\llorc$
\end_inset

 formulas are the following:
\end_layout

\begin_deeper
\begin_layout Itemize
There is a canonical way to associate indices to 
\begin_inset Formula $\llorc$
\end_inset

 formulas,
 so that a computer program may manipulate them,
 and
\end_layout

\begin_layout Itemize
Given a c.e.
\begin_inset space \space{}
\end_inset

index for the atomic 
\begin_inset Formula $\Lang'$
\end_inset

-type of a tuple of elements 
\begin_inset Formula $\vec{b}$
\end_inset

 in some structure,
 and a 
\begin_inset Formula $\llorc$
\end_inset

 formula 
\begin_inset Formula $\varphi(\vec{x})$
\end_inset

,
 we can computably confirm in finite time that (if) the tuple 
\begin_inset Formula $\vec{b}$
\end_inset

 satisfies the formula 
\begin_inset Formula $\varphi$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
Compare the properties in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rmk:llorc"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 to the following properties of a related class of computable infinitary formulas.
 The 
\begin_inset Formula $\Sigma_{1}^{c}$
\end_inset

 formulas are those formulas in the Computable Infinitary Language of the form:
\begin_inset Formula 
\[
\llor_{i<\omega}\exists_{\vec{y}_{i}}\varphi_{i}(\vec{x},\vec{y}_{i}),
\]

\end_inset

where the sequence of formulas 
\begin_inset Formula $\{\exists_{\vec{y}_{i}}\varphi_{i}(\vec{x},\vec{y})\}_{i\in\N}$
\end_inset

 is computable,
 and each 
\begin_inset Formula $\varphi_{i}$
\end_inset

 is a finite Boolean combination of predicates applied to variables in the tuple 
\begin_inset Formula $(\vec{x},\vec{y})$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Itemize
The 
\begin_inset Formula $\Sigma_{1}^{c}$
\end_inset

 formulas also admit a canonical way to associate indices,
 and
\end_layout

\begin_layout Itemize
Given a tuple 
\begin_inset Formula $\vec{b}$
\end_inset

 of elements in a computable structure 
\begin_inset Formula $D$
\end_inset

,
 we can confirm in finite time that (if) the tuple 
\begin_inset Formula $\vec{b}$
\end_inset

 satisfies the formula 
\begin_inset Formula $\varphi$
\end_inset

.
\end_layout

\begin_layout Standard
Despite the similarities,
 the 
\begin_inset Formula $\llorc$
\end_inset

 formulas shall be more useful in our treatment,
 because to check the truth of a 
\begin_inset Formula $\Sigma_{1}^{c}$
\end_inset

 formula,
 we need access to the entire model (so that we may brute-force the tuples 
\begin_inset Formula $\vec{y}_{i}$
\end_inset

),
 whilst we shall be working with 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed structures,
 which may contain 
\begin_inset Quotes eld
\end_inset

phantom elements
\begin_inset Quotes erd
\end_inset

 that could otherwise lead to false positives.
 Moreover,
 since we only have a c.e.
\begin_inset space \space{}
\end_inset

index for the positive information about elements,
 we cannot computably check arbitrary finite Boolean combinations of predicates – hence why we restrict to positive formulas.
\end_layout

\end_deeper
\begin_layout Definition
(work in progress) a 
\begin_inset Formula $\llorc_{2}$
\end_inset

 formula is one of the form 
\begin_inset Formula 
\[
\llor_{i\in\N}\left(\psi_{i}(\vec{x})\land\neg\llor_{j\in\N}\varphi_{ij}(\vec{x})\right)
\]

\end_inset

 with 
\begin_inset Formula $\psi_{i}$
\end_inset

 and 
\begin_inset Formula $\varphi_{ij}$
\end_inset

 positive computable.
\end_layout

\begin_layout Remark
The main property of a 
\begin_inset Formula $\llorc_{2}$
\end_inset

 formula 
\begin_inset Formula $\varphi(\vec{x})$
\end_inset

 is that,
 given a tuple of elements and a c.e.
\begin_inset space \space{}
\end_inset

index for their type,
 it is 
\begin_inset Formula $0'$
\end_inset

-c.e.
\begin_inset space \space{}
\end_inset

to determine whether the formula holds of the elements.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
Note that every 
\begin_inset Formula $\llorc$
\end_inset

 formula is naturally equivalent to a 
\begin_inset Formula $\llorc_{2}$
\end_inset

 formula.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
In the sequence,
 we shall have two nested signatures,
 
\begin_inset Formula $\Lang\subseteq\Lang'$
\end_inset

.
 We shall follow the following conventions:
\end_layout

\begin_deeper
\begin_layout Itemize
Unless indicated otherwise,
 all formulas are assumed to be quantifier-free,
\end_layout

\begin_layout Itemize
All named 
\begin_inset Formula $\Lang$
\end_inset

-formulas will be quantifier-free finitary first-order formulas,
 and will be denoted by lower-case Roman letters,
\end_layout

\begin_layout Itemize
All named 
\begin_inset Formula $\Lang'$
\end_inset

-formulas will be 
\begin_inset Formula $\llorc$
\end_inset

,
 except for the formulas named 
\begin_inset Formula $\tau$
\end_inset

,
 which will be 
\begin_inset Formula $\llorc_{2}$
\end_inset

,
 and will be denoted by lower-case Greek letters.
 Conversely,
 all 
\begin_inset Formula $\llorc$
\end_inset

 or 
\begin_inset Formula $\llorc_{2}$
\end_inset

 formulas in the sequence are assumed to be over the signature 
\begin_inset Formula $\Lang'$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
\begin_inset Argument 1
status open

\begin_layout Plain Layout
QETP
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "def:qetp"

\end_inset

Let 
\begin_inset Formula $\Lang\subseteq\Lang'$
\end_inset

 be computable signatures,
 and let 
\begin_inset Formula $D$
\end_inset

 be a structure over 
\begin_inset Formula $\Lang'$
\end_inset

.
 We say that 
\begin_inset Formula $D$
\end_inset

 satisfies the 
\emph on
Computable Positive Quantifier Elimination and Trash Existence Property
\emph default
,
 abbreviated to 
\emph on
QETP,

\emph default
 if the following properties hold:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

label=(
\backslash
alph*)
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "enu:qetp0"

\end_inset


\begin_inset Formula $\Lang$
\end_inset

 is finite,
 closed under negation,
 and includes the predicate 
\begin_inset Formula $\neq$
\end_inset

,
\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:qetp1"

\end_inset

For every 
\begin_inset Formula $\Lang$
\end_inset

 formula 
\begin_inset Formula $q(\vec{x},\vec{y})$
\end_inset

,
 there is a 
\begin_inset Formula $\llorc$
\end_inset


\emph on
 
\emph default
formula 
\begin_inset Formula $\chi_{q}(\vec{x})$
\end_inset

,
 computable from 
\begin_inset Formula $q$
\end_inset

,
 such that
\begin_inset Formula 
\[
D\vDash\forall_{\vec{x}}\left[\chi_{q}(\vec{x})\leftrightarrow\exists_{\vec{y}}q(\vec{x},\vec{y})\right],
\]

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:qetp2"

\end_inset

There is a 
\begin_inset Formula $0'$
\end_inset

-computable 
\emph on
partial
\emph default
 function denoted 
\begin_inset Formula $\tau$
\end_inset

,
 which takes as input a pair 
\begin_inset Formula $(q(\vec{x},y,\vec{z}),\varphi(\vec{x}))$
\end_inset

,
 where 
\begin_inset Formula $q(\vec{x},y,\vec{z})$
\end_inset

 is a quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

-type
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Note the lack of 
\begin_inset Quotes eld
\end_inset

vector arrow
\begin_inset Quotes erd
\end_inset

 on the variable 
\begin_inset Formula $y$
\end_inset

.
 This denotes a 
\emph on
single
\emph default
 variable,
 not a tuple of them.
\end_layout

\end_inset

 and 
\begin_inset Formula $\varphi(\vec{x})$
\end_inset

 is a 
\emph on
finitary
\emph default
 
\begin_inset Formula $\Lang'$
\end_inset

-formula,
 whose output is a 
\begin_inset Formula $\llorc_{2}$
\end_inset

 formula denoted 
\begin_inset Formula $\tau_{q\varphi}(\vec{x},y)$
\end_inset

 that satisfies the following two properties:
\end_layout

\begin_deeper
\begin_layout Itemize
For every tuple 
\begin_inset Formula $(\vec{x},y,\vec{z})$
\end_inset

 of elements in 
\begin_inset Formula $D$
\end_inset

,
 of 
\begin_inset Formula $\Lang$
\end_inset

-type 
\begin_inset Formula $q(\vec{x},y,\vec{z})$
\end_inset

,
 there is a formula 
\begin_inset Formula $\varphi(\vec{x})$
\end_inset

 satisfied by 
\begin_inset Formula $\vec{x}$
\end_inset

 such that 
\begin_inset Formula $(q,\varphi)$
\end_inset

 is in the domain of 
\begin_inset Formula $\tau$
\end_inset

.
 Equivalently,
 if 
\begin_inset Formula $\vec{b}$
\end_inset

 is a tuple of elements in 
\begin_inset Formula $D$
\end_inset

 such that 
\begin_inset Formula $D\vDash\chi_{q}(\vec{b})$
\end_inset

,
 there is 
\begin_inset Formula $\varphi(\vec{x})$
\end_inset

 such that 
\begin_inset Formula $(q,\varphi)$
\end_inset

 is in the domain of 
\begin_inset Formula $\tau$
\end_inset

 and 
\begin_inset Formula $D\vDash\varphi(\vec{b})$
\end_inset

.
 Moreover,
\end_layout

\begin_layout Itemize
The following formula holds in 
\begin_inset Formula $D$
\end_inset

:
\begin_inset Formula 
\[
D\vDash\forall_{\vec{x}}\left[\chi_{q}(\vec{x})\land\varphi(\vec{x})\rightarrow\exists_{y}\tau_{q\varphi}(\vec{x},y)\right].
\]

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
denis idea:
 assume that tau only hits the true tau i.o.
 instead of a.e.
 and try to get a 
\begin_inset Formula $0''$
\end_inset

 isomorphism
\end_layout

\end_inset


\begin_inset FormulaMacro
\newcommand{\etau}{\mathord{\varepsilon\tau}}
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:qetpetau"

\end_inset

Given a pair 
\begin_inset Formula $(q(\vec{x},y,\vec{z}),\varphi(\vec{x}))$
\end_inset

 in the domain of 
\begin_inset Formula $\tau$
\end_inset

 as above,
 together with a quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

-type 
\begin_inset Formula $Q(\vec{x},y,\vec{z},\vec{w})$
\end_inset

 extending 
\begin_inset Formula $q(\vec{x},y,\vec{z})$
\end_inset

,
 there is a 
\begin_inset Formula $\llorc$
\end_inset

 formula 
\begin_inset Formula $\etau_{q\varphi Q}(\vec{x})$
\end_inset

,
 computable from the triple 
\begin_inset Formula $(q,\varphi,Q)$
\end_inset

,
 such that
\begin_inset Formula 
\[
D\vDash\forall_{\vec{x}}\left[\exists_{y}\left[\chi_{Q}(\vec{x},y)\land\tau_{q\varphi}(\vec{x},y)\right]\leftrightarrow\etau_{q\varphi Q}(\vec{x})\right].
\]

\end_inset

The function 
\begin_inset Formula $(q,\varphi,Q)\mapsto\etau_{q\varphi Q}$
\end_inset

 may be defined in some cases even if the pair 
\begin_inset Formula $(q,\varphi)$
\end_inset

 is not in the domain of 
\begin_inset Formula $\tau$
\end_inset

.
 In this scenario,
 we do not make any requirement of 
\begin_inset Formula $\etau_{q\varphi Q}$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
Note:
 As a corollary of 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:qetp2"

\end_inset

,
 we obtain 
\begin_inset Formula $D\vDash\forall_{\vec{x}}\left[\chi_{q}(\vec{x})\land\varphi(\vec{x})\rightarrow\etau_{q\varphi q}(\vec{x})\right]$
\end_inset

 for 
\begin_inset Formula $(q,\varphi)$
\end_inset

 in the domain of 
\begin_inset Formula $\tau$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:qetp3"

\end_inset

Finally,
 for all 
\begin_inset Formula $q$
\end_inset

,
 
\begin_inset Formula $\varphi$
\end_inset

,
 
\begin_inset Formula $Q$
\end_inset

,
 we require 
\begin_inset Formula 
\[
D\vDash\forall_{\vec{x},y}\left[\etau_{q\varphi Q}(\vec{x})\land\tau_{q\varphi}(\vec{x},y)\rightarrow\chi_{Q}(\vec{x},y)\right].
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\end_deeper
\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rmk:tauwork"

\end_inset

We will work with Item 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:qetp2"

\end_inset

 of the QETP in the following manner:
 We envision a computable process that enumerates triplets 
\begin_inset Formula $(q,\varphi,\tau)$
\end_inset

,
 and sometimes deletes them,
 in such a manner that,
 if 
\begin_inset Formula $\tau_{q\varphi}$
\end_inset

 is well-defined,
 the triple 
\begin_inset Formula $(q,\varphi,\tau_{q\varphi})$
\end_inset

 will eventually be enumerated and never removed,
 and ever triplet that is not of the form 
\begin_inset Formula $(q,\varphi,\tau_{q\varphi})$
\end_inset

 for 
\begin_inset Formula $(q,\varphi)$
\end_inset

 in the domain of 
\begin_inset Formula $\tau$
\end_inset

 will eventually be removed.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
As a consequence of Item 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:qetp1"

\end_inset

 of Definition 
\begin_inset CommandInset ref
LatexCommand ref
reference "def:qetp"

\end_inset

,
 if 
\begin_inset Formula $D$
\end_inset

 is a 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed structure satisfying the QETP,
 we can enumerate the quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

-types that are realized in 
\begin_inset Formula $D$
\end_inset

.
 This is because,
 to tell if a type 
\begin_inset Formula $q(\vec{y})$
\end_inset

 is realized in 
\begin_inset Formula $D$
\end_inset

,
 we inspect the truth value of the zero-ary positive sentence 
\begin_inset Formula $\chi_{q}$
\end_inset

,
 which will consist of a positive combination of zero-ary predicates of 
\begin_inset Formula $D$
\end_inset

.
 By inspecting the type of the zero-ary tuple of elements of 
\begin_inset Formula $D$
\end_inset

 we can therefore enumerate the types 
\begin_inset Formula $q(\vec{y})$
\end_inset

 that are realized.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
By inspection of the proof of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 one can actually work with a slightly weaker version of the QETP,
 where 
\begin_inset Formula $\chi_{q}(\vec{x})$
\end_inset

 need only be defined when 
\begin_inset Formula $q(\vec{x},\vec{y})$
\end_inset

.
 However,
 in that scenario,
 one needs to add the additional assumption:
 The set of quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

-types realized in 
\begin_inset Formula $D$
\end_inset

 is c.e.
 This added generality was not necessary in our work,
 so we did not add it.
\end_layout

\begin_layout Standard
We now present our main result.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:main_final"

\end_inset

If 
\begin_inset Formula $D$
\end_inset

 is a 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed structure over the signature 
\begin_inset Formula $\Lang'\supseteq\Lang$
\end_inset

 satisfying the QETP,
 then the reduct 
\begin_inset Formula $D\upto\Lang$
\end_inset

 admits a computable copy 
\begin_inset Formula $M$
\end_inset

.
 There is a 
\begin_inset Formula $0'$
\end_inset

-computable isomorphism between 
\begin_inset Formula $D\upto\Lang$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

.
 This result is uniform in the index for 
\begin_inset Formula $D$
\end_inset

 and index for witnesses that 
\begin_inset Formula $D$
\end_inset

 satisfies the QETP,
 and relativizes uniformly.
\end_layout

\begin_layout Proof
We shall build a computable copy of 
\begin_inset Formula $D\upto\Lang$
\end_inset

 via a finite injury argument.
 First,
 we lay down the foundation for the functioning of our algorithm:
\end_layout

\begin_deeper
\begin_layout Itemize
We visualize the structure 
\begin_inset Formula $D$
\end_inset

 as being given by a computable process,
 outputting elements and c.e.
\begin_inset space \space{}
\end_inset

indices for the atomic 
\begin_inset Formula $\Lang'$
\end_inset

-type of the elements output thus far,
 and sometimes erasing previously constructed elements.
 We shall be executing this construction in parallel in the background of ours.
\end_layout

\begin_layout Itemize
We shall build the 
\begin_inset Formula $\Lang$
\end_inset

-structure 
\begin_inset Formula $M\cong D\upto\Lang$
\end_inset

 via a computable process that outputs a sequence of elements,
 and with each element,
 the quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

-type of the elements output thus far.
\end_layout

\begin_layout Itemize
We well-order the elements of 
\begin_inset Formula $M$
\end_inset

 and the elements of 
\begin_inset Formula $D$
\end_inset

 by time of addition.
 This includes 
\begin_inset Quotes eld
\end_inset

fake
\begin_inset Quotes erd
\end_inset

 elements of 
\begin_inset Formula $D$
\end_inset

.
 When we refer to 
\begin_inset Quotes eld
\end_inset

the first element of 
\begin_inset Formula $M$
\end_inset

 (or 
\begin_inset Formula $D$
\end_inset

) that satisfies such-and-such property
\begin_inset Quotes erd
\end_inset

,
 we mean the one that was added earliest.
\end_layout

\begin_layout Itemize
We shall imagine an assortment of workers,
 referred to as 
\begin_inset Quotes eld
\end_inset

worker 
\begin_inset Formula $i$
\end_inset


\begin_inset Quotes erd
\end_inset

 for 
\begin_inset Formula $i=0,1,2,\dots$
\end_inset

,
 each of which will be responsible for one step in a back-and-forth construction of an isomorphism between 
\begin_inset Formula $D$
\end_inset

 and the structure 
\begin_inset Formula $M$
\end_inset

 that we are constructing.
\end_layout

\begin_layout Itemize
We assume that only one worker is active at each time.
 When worker 
\begin_inset Formula $i$
\end_inset

 is done with its task,
 it will activate worker 
\begin_inset Formula $i+1$
\end_inset

.
 When an injury occurs (the means by which this may be caused will be discussed later),
 we may divert execution back to a prior worker,
 say worker 
\begin_inset Formula $j$
\end_inset

,
 and delete the state of all workers past worker 
\begin_inset Formula $j$
\end_inset

.
\end_layout

\begin_layout Itemize
The internal state of this construction,
 that is,
 the information we shall be keeping track of,
 consists of the following data (plus whatever ancilliary information is necessary to keep track of the worker mechanism):
\end_layout

\begin_deeper
\begin_layout Itemize
The current status of the structures 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $D$
\end_inset

,
\end_layout

\begin_layout Itemize
One-to-one matchings between some elements of 
\begin_inset Formula $M$
\end_inset

 and some elements of 
\begin_inset Formula $D$
\end_inset

,
 the latter of which may or may not be real,
\end_layout

\begin_layout Itemize
To some elements 
\begin_inset Formula $m$
\end_inset

 of 
\begin_inset Formula $M$
\end_inset

,
 we match a triplet of formulas 
\begin_inset Formula $(q(\vec{x},y,\vec{z}),\varphi(\vec{x}),\tau(\vec{x},y))$
\end_inset

 that have been output by the process from 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rmk:tauwork"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 together with a decomposition of the elements of 
\begin_inset Formula $M$
\end_inset

 at the time that this matching was created,
 into 
\begin_inset Formula $\vec{x}$
\end_inset

,
 
\begin_inset Formula $y=m$
\end_inset

,
 and 
\begin_inset Formula $\vec{z}$
\end_inset

.
\end_layout

\begin_layout Itemize
To each matching of the previous two kinds,
 we keep track of which worker created it and when.
\end_layout

\end_deeper
\begin_layout Itemize
The internal state of this construction may be modified via the following operations:
\end_layout

\begin_deeper
\begin_layout Itemize
We may add a new element to 
\begin_inset Formula $M$
\end_inset

,
 in which case we immediately match it to an element of 
\begin_inset Formula $D$
\end_inset

,
\end_layout

\begin_layout Itemize
We may create a matching between an element of 
\begin_inset Formula $M$
\end_inset

 and an element of 
\begin_inset Formula $D$
\end_inset

,
\end_layout

\begin_layout Itemize
We may match a triplet of formulas 
\begin_inset Formula $(q,\varphi,\tau)$
\end_inset

 to an element 
\begin_inset Formula $y\in M$
\end_inset

,
 together with the decomposition 
\begin_inset Formula $M_{\mathrm{current}}=(\vec{x},y,\vec{z})$
\end_inset

,
 where 
\begin_inset Formula $\vec{x}$
\end_inset

 denotes the elements of 
\begin_inset Formula $M$
\end_inset

 that have a match in 
\begin_inset Formula $D$
\end_inset

 at this moment (note that in particular we assume 
\begin_inset Formula $y$
\end_inset

 does not have a match at this moment),
\end_layout

\begin_layout Itemize
In the event of injury,
 we may remove matches of the two kinds above.
\end_layout

\end_deeper
\begin_layout Itemize
The construction will be injured if either of the following three events occur:
\end_layout

\begin_deeper
\begin_layout Itemize
An element of 
\begin_inset Formula $D$
\end_inset

 which admits a match to an element of 
\begin_inset Formula $M$
\end_inset

 is deleted,
\end_layout

\begin_layout Itemize
There is an element of 
\begin_inset Formula $M$
\end_inset

,
 with an assigned triplet of formulas 
\begin_inset Formula $(q,\varphi,\tau)$
\end_inset

,
 for which the triplet of formulas has been deleted from the enumeration of the process of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rmk:tauwork"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
\end_layout

\begin_layout Itemize
There is an element of 
\begin_inset Formula $M$
\end_inset

,
 with an assigned triplet 
\begin_inset Formula $(q,\varphi,\tau)$
\end_inset

 and a matched element 
\begin_inset Formula $d\in D$
\end_inset

,
 such that our guess about whether 
\begin_inset Formula $\tau$
\end_inset

 holds of this element has changed to 
\begin_inset Quotes els
\end_inset

no
\begin_inset Quotes ers
\end_inset

.
\end_layout

\begin_layout Standard
In either of these cases,
 all matches created after the 
\begin_inset Quotes eld
\end_inset

faulty match
\begin_inset Quotes erd
\end_inset

 will be deleted.
\end_layout

\end_deeper
\begin_layout Standard
Now,
 we establish some assumptions about the internal state of the construction,
 which we will be careful to uphold at every step.
 Together with each assumption,
 we point out the operations that we need to be careful in exercising – the remaining operations will always preserve the given assumption.
 Moreover,
 the assumptions will not be broken with the passage of time unless injury happens,
 in which case the injury-handling part of the algorithm will rectify any issues.
\end_layout

\begin_layout Enumerate
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

label={Assumption (
\backslash
Alph*)},
 leftmargin=*
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "enu:asmchi"

\end_inset

If 
\begin_inset Formula $M=(\vec{x},\vec{y})$
\end_inset

,
 where 
\begin_inset Formula $\vec{x}$
\end_inset

 denotes the elements of 
\begin_inset Formula $M$
\end_inset

 that currently admit matches in 
\begin_inset Formula $D$
\end_inset

,
 
\begin_inset Formula $\vec{b}$
\end_inset

 denotes these matches,
 and 
\begin_inset Formula $q(\vec{x},\vec{y})$
\end_inset

 is the type of the elements of 
\begin_inset Formula $M$
\end_inset

,
 we demand that 
\begin_inset Formula $D\vDash\chi_{q}(\vec{b})$
\end_inset

 if all elements of 
\begin_inset Formula $\vec{b}$
\end_inset

 are real.
\end_layout

\begin_deeper
\begin_layout Standard
We need to be careful to ensure that this is true when we add new elements to 
\begin_inset Formula $M$
\end_inset

,
 and when we create matches between elements of 
\begin_inset Formula $M$
\end_inset

 and elements of 
\begin_inset Formula $D$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:asmphi"

\end_inset

If 
\begin_inset Formula $y\in M$
\end_inset

 is matched with a triplet of formulas 
\begin_inset Formula $(q,\varphi,\tau)$
\end_inset

 and decomposition 
\begin_inset Formula $(\vec{x},y,\vec{z})\subseteq M$
\end_inset

,
 we demand that 
\begin_inset Formula $M\vDash q(\vec{x},y,\vec{z})$
\end_inset

 and that all elements of 
\begin_inset Formula $\vec{x}$
\end_inset

 admit matches 
\begin_inset Formula $\vec{b}$
\end_inset

 in 
\begin_inset Formula $D$
\end_inset

,
 which satisfy 
\begin_inset Formula $D\vDash\varphi(\vec{b})$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
We need to be careful to ensure that this is true when we assign a triplet to an element.
 We don't need to be careful when removing matches or elements of 
\begin_inset Formula $D$
\end_inset

,
 because our injury process will,
 in that case,
 unmatch the formulas assigned to 
\begin_inset Formula $y$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:asmutau"

\end_inset

At most one unmatched element 
\begin_inset Formula $m$
\end_inset

 of 
\begin_inset Formula $M$
\end_inset

 will have an assigned triplet at any given time,
 and in this event,
 the variables 
\begin_inset Formula $\vec{x}$
\end_inset

 correspond to the elements of 
\begin_inset Formula $M$
\end_inset

 currently matched to elements of 
\begin_inset Formula $D$
\end_inset

,
 and the next action to be taken shall be to match 
\begin_inset Formula $m$
\end_inset

 to an element of 
\begin_inset Formula $D$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:asmtau"

\end_inset

If 
\begin_inset Formula $y$
\end_inset

 is an element of 
\begin_inset Formula $M$
\end_inset

 with assigned triplet 
\begin_inset Formula $(q(\vec{x},y,\vec{z}),\varphi(\vec{x}),\tau(\vec{x},y))$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 admits a match 
\begin_inset Formula $d$
\end_inset

 in 
\begin_inset Formula $D$
\end_inset

,
 if 
\begin_inset Formula $\vec{b}$
\end_inset

 is the tuple of elements matched with 
\begin_inset Formula $\vec{x}$
\end_inset

,
 it must be the case that 
\begin_inset Formula $D\vDash\tau(\vec{b},d)$
\end_inset

 
\emph on
at the current approximation
\emph default
.
\end_layout

\begin_deeper
\begin_layout Standard
We need to be careful to ensure that this is true when we create a match between an element of 
\begin_inset Formula $M$
\end_inset

 with an assigned triplet 
\begin_inset Formula $(q,\varphi,\tau)$
\end_inset

 and an element of 
\begin_inset Formula $D$
\end_inset

.
 We will not need to be careful when we assign a triplet 
\begin_inset Formula $(q,\varphi,\tau)$
\end_inset

 to an element of 
\begin_inset Formula $M$
\end_inset

,
 because (it turns out) we will always match such triplets to unmatched elements.
 We also need to be careful if the current approximation ever changes,
 which is why 
\begin_inset Quotes els
\end_inset

the approximation of the value of 
\begin_inset Formula $\tau(\vec{b},d)$
\end_inset

 changes
\begin_inset Quotes ers
\end_inset

 is a cause of injury.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:asmetau"

\end_inset

If 
\begin_inset Formula $m$
\end_inset

 is an element with assigned formulas 
\begin_inset Formula $(q(\vec{x},y,\vec{z}),\varphi(\vec{x}),\tau(\vec{x},y))$
\end_inset

,
 with 
\begin_inset Formula $\vec{b}$
\end_inset

 denoting the matches of the 
\begin_inset Formula $\vec{x}$
\end_inset

,
 and at this stage 
\begin_inset Formula $M$
\end_inset

 is decomposed as 
\begin_inset Formula $M=(\vec{x},y,\vec{z},\vec{w})$
\end_inset

 with quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

-type 
\begin_inset Formula $Q(\vec{x},y,\vec{z},\vec{w})$
\end_inset

,
 it must be the case that,
 if the 
\begin_inset Formula $\vec{b}$
\end_inset

 are real elements of 
\begin_inset Formula $D$
\end_inset

,
 we have 
\begin_inset Formula $D\vDash\etau_{q\varphi Q}(\vec{b})$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
We need to be careful to ensure that this is true when new elements are added to 
\begin_inset Formula $M$
\end_inset

,
 and when we assign triplets 
\begin_inset Formula $(q,\varphi,\tau)$
\end_inset

 to elements of 
\begin_inset Formula $M$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
The process starts with the initialization of worker 
\begin_inset Formula $0$
\end_inset

.
\end_layout

\begin_layout Standard
Now,
 let us describe the algorithm that will be followed by worker 
\begin_inset Formula $i$
\end_inset

.
 Upon initialization:
\end_layout

\begin_layout Itemize
To begin,
 find the first element of 
\begin_inset Formula $M$
\end_inset

,
 if any,
 that does not have a match in 
\begin_inset Formula $D$
\end_inset

.
 If there is none,
 skip to the end of this bullet point.
 If there is one,
 call it 
\begin_inset Formula $m$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
If 
\begin_inset Formula $m$
\end_inset

 does not have an assigned formula:
 Let 
\begin_inset Formula $(\vec{x},y,\vec{z})$
\end_inset

 be the current elements of 
\begin_inset Formula $M$
\end_inset

,
 with 
\begin_inset Formula $\vec{x}$
\end_inset

 corresponding to the elements that currently have a match in 
\begin_inset Formula $D$
\end_inset

 – call them 
\begin_inset Formula $\vec{b}$
\end_inset

 –,
 
\begin_inset Formula $y$
\end_inset

 corresponding to 
\begin_inset Formula $m$
\end_inset

,
 and 
\begin_inset Formula $\vec{z}$
\end_inset

 corresponding to the remaining elements.
 Look through the triplets 
\begin_inset Formula $(q,\varphi,\tau)$
\end_inset

 enumerated as per 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rmk:tauwork"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 until you find such a triplet that satisfies 
\begin_inset Formula $M\vDash q(\vec{x},y,\vec{z})$
\end_inset

 and 
\begin_inset Formula $D\vDash\varphi(\vec{b})$
\end_inset

.
 If all elements of 
\begin_inset Formula $\vec{b}$
\end_inset

 are real,
 such a triple will be found in finite time by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "enu:asmchi"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 in conjunction with Item 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:qetp2"

\end_inset

 of the QETP.
 If not all are real,
 injury will occur.
 Once such a triple is found,
 we assign to 
\begin_inset Formula $m$
\end_inset

 the triplet 
\begin_inset Formula $(q,\varphi,\tau)$
\end_inset

 with the decomposition 
\begin_inset Formula $(\vec{x},y,\vec{z})$
\end_inset

 above.
\end_layout

\begin_layout Standard
We need to make sure that 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:asmphi"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:asmetau"

\end_inset

 are preserved.
\end_layout

\begin_layout Itemize
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:asmphi"

\end_inset

 – By design.
\end_layout

\begin_layout Itemize
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:asmetau"

\end_inset

 – We need to guarantee that,
 if the 
\begin_inset Formula $\vec{b}$
\end_inset

 are all real,
 we have 
\begin_inset Formula $D\vDash\etau_{q\varphi q}(\vec{b})$
\end_inset

.
 This is a consequence of the note at the end of Item 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:qetpetau"

\end_inset

 of the QETP.
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $(q,\varphi,\tau)$
\end_inset

 be the formula assigned to 
\begin_inset Formula $m$
\end_inset

.
 The formula 
\begin_inset Formula $q(\vec{x},y,\vec{z})$
\end_inset

 will not,
 in general,
 be the the quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

-type of the current elements of 
\begin_inset Formula $M$
\end_inset

,
 but it is definitely the quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

-type of some subset of elements of 
\begin_inset Formula $M$
\end_inset

.
 By 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:asmutau"

\end_inset

,
 the elements corresponding to 
\begin_inset Formula $\vec{x}$
\end_inset

 are exactly the ones that currently admit matches in 
\begin_inset Formula $D$
\end_inset

.
 Let 
\begin_inset Formula $\vec{b}$
\end_inset

 denote their matches.
\end_layout

\begin_layout Standard
We let 
\begin_inset Formula $Q(\vec{x},y,\vec{z},\vec{w})$
\end_inset

 denote the quantifier-free type of the current elements of 
\begin_inset Formula $M$
\end_inset

,
 where 
\begin_inset Formula $\vec{x}$
\end_inset

,
 
\begin_inset Formula $y$
\end_inset

,
 and 
\begin_inset Formula $\vec{z}$
\end_inset

 are the same as above.
\end_layout

\begin_layout Standard
Look through the elements of 
\begin_inset Formula $D$
\end_inset

 until you find an element 
\begin_inset Formula $d$
\end_inset

 satisfying 
\begin_inset Formula $D\vDash\tau(\vec{b},d)$
\end_inset

 to current approximation.
\end_layout

\begin_layout Standard

\size small
Technical note:
 This search must be done in some systematic way so that,
 if all 
\begin_inset Formula $\vec{b}$
\end_inset

 are real,
 we eventually find a 
\emph on
real
\emph default
 element 
\begin_inset Formula $d$
\end_inset

 satisfying this formula in such a way that the approximation nevermore changes.
 An example of such a systematic way:
 Let's say we give the 
\begin_inset Formula $n$
\end_inset

-th element added to 
\begin_inset Formula $D$
\end_inset

,
 say 
\begin_inset Formula $d_{n}$
\end_inset

,
 a penalty of 
\begin_inset Formula $n$
\end_inset

 stages in the time it takes to compute whether 
\begin_inset Formula $D\vDash\tau(\vec{b},d_{n})$
\end_inset

,
 and select the 
\begin_inset Formula $d$
\end_inset

 such that 
\begin_inset Formula $D\vDash\tau(\vec{b},d)$
\end_inset

 is verified and not disproven until now in the least amount of stages.
 This will be important when proving finite injury.
\end_layout

\begin_layout Standard
We claim that,
 unless an injury occurs,
 this search will eventually terminate.
 By this we mean:
 Assume that all 
\begin_inset Formula $\vec{b}$
\end_inset

 are real,
 and that the triple 
\begin_inset Formula $(q,\varphi,\tau)$
\end_inset

 will never be removed from the enumeration from 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rmk:tauwork"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
 Then,
 by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "enu:asmchi"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 it must be the case that 
\begin_inset Formula $D\vDash\chi_{Q}(\vec{b})$
\end_inset

 and by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "enu:asmetau"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 it must be the case that 
\begin_inset Formula $D\vDash\etau_{q\varphi Q}(\vec{b})$
\end_inset

.
 Thus,
 by definition of 
\begin_inset Formula $\etau$
\end_inset

,
 it must be the case that 
\begin_inset Formula $D\vDash\exists_{y}\tau_{q}(\vec{b},y)$
\end_inset

,
 and any witness to this statement will serve as the 
\begin_inset Formula $d$
\end_inset

 above.
\end_layout

\begin_layout Standard
Once such a 
\begin_inset Formula $d$
\end_inset

 is found,
 we match 
\begin_inset Formula $m$
\end_inset

 to 
\begin_inset Formula $d$
\end_inset

.
\end_layout

\begin_layout Standard
We need to make sure that 
\begin_inset CommandInset ref
LatexCommand formatted
reference "enu:asmchi"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "enu:asmtau"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 hold.
\end_layout

\begin_layout Itemize
\begin_inset CommandInset ref
LatexCommand formatted
reference "enu:asmchi"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 – If 
\begin_inset Formula $d$
\end_inset

 is real,
 this is direct by Item 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:qetp3"

\end_inset

 of the QETP.
\end_layout

\begin_layout Itemize
\begin_inset CommandInset ref
LatexCommand formatted
reference "enu:asmtau"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 – By construction
\end_layout

\end_deeper
\begin_layout Itemize
Next,
 find the first element of 
\begin_inset Formula $D$
\end_inset

 – call it 
\begin_inset Formula $d$
\end_inset

 – that does not have a match in 
\begin_inset Formula $M$
\end_inset

.
 If there is no such element as of right now,
 proceed to the next bullet point.
\end_layout

\begin_deeper
\begin_layout Standard
Let 
\begin_inset Formula $q(\vec{x},\vec{y})$
\end_inset

 be the quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

-type of the elements of 
\begin_inset Formula $M$
\end_inset

,
 and 
\begin_inset Formula $\vec{b}$
\end_inset

 the matches of the elements of 
\begin_inset Formula $M$
\end_inset

 that admit matches.
 Let 
\begin_inset Formula $r(\vec{x},z)$
\end_inset

 be the quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

-type of the tuple 
\begin_inset Formula $(\vec{b},d)$
\end_inset

.
\begin_inset Foot
status open

\begin_layout Plain Layout
Here,
 we use Item 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:qetp0"

\end_inset

 of the QETP.
\end_layout

\end_inset

 In parallel,
 look through the realized quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

 existential types 
\begin_inset Formula $\exists_{\vec{x}}\exists_{\vec{y}}\exists_{z}Q(\vec{x},z,\vec{y})$
\end_inset

 until you find such a 
\begin_inset Formula $Q(\vec{x},z,\vec{y})$
\end_inset

 extending 
\begin_inset Formula $q(\vec{x},\vec{y})\land r(\vec{x},z)$
\end_inset

 such that:
\end_layout

\begin_layout Itemize
\begin_inset Formula $D\vDash\chi_{Q(\vec{x},z,\cdot)}(\vec{b},d)$
\end_inset

,
 and
\end_layout

\begin_layout Itemize
For every 
\begin_inset Formula $m$
\end_inset

 with an assigned triplet 
\begin_inset Formula $(q_{0}(\vec{x}_{0},y_{0},\vec{z}_{0}),\varphi(\vec{x}_{0}),\tau(\vec{x}_{0},y_{0}))$
\end_inset

,
 if 
\begin_inset Formula $\vec{b}_{0}$
\end_inset

 are the elements of 
\begin_inset Formula $M$
\end_inset

 corresponding to 
\begin_inset Formula $\vec{x}_{0}$
\end_inset

,
 
\begin_inset Formula $D\vDash\etau_{q_{0}\varphi Q}(\vec{b}_{0})$
\end_inset

.
\end_layout

\begin_layout Standard
We argue that either such a 
\begin_inset Formula $Q$
\end_inset

 is found in finite time or otherwise an injury will occur.
 Indeed,
 suppose that both 
\begin_inset Formula $d$
\end_inset

 and the elements of 
\begin_inset Formula $\vec{b}$
\end_inset

 are all real,
 and that every triplet 
\begin_inset Formula $(q_{0},\varphi,\tau)$
\end_inset

 will nevermore be injured.
 Now,
 since we assume 
\begin_inset Formula $D\vDash\chi_{q}(\vec{b})$
\end_inset

,
 there must be a tuple of real elements 
\begin_inset Formula $\vec{c}$
\end_inset

 in 
\begin_inset Formula $D$
\end_inset

 such that 
\begin_inset Formula $D\vDash q(\vec{b},\vec{c})$
\end_inset

.
 Now,
 we claim that the type 
\begin_inset Formula $Q$
\end_inset

 of the tuple 
\begin_inset Formula $(\vec{b},d,\vec{c})$
\end_inset

 satisfies the desired requisites:
\end_layout

\begin_layout Itemize
Since 
\begin_inset Formula $D\vDash Q(\vec{b},d,\vec{c})$
\end_inset

,
 we must have 
\begin_inset Formula $D\vDash\exists_{\vec{y}}Q(\vec{b},d,\vec{y})$
\end_inset

 and hence 
\begin_inset Formula $D\vDash\chi_{Q}(\vec{b},d)$
\end_inset

,
 and
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $m$
\end_inset

 has the triplet 
\begin_inset Formula $(q_{0},\varphi,\tau)$
\end_inset

 assigned,
 with decomposition 
\begin_inset Formula $(\vec{x}_{0},y_{0},\vec{z}_{0})\subseteq M$
\end_inset

,
 with 
\begin_inset Formula $\vec{b}_{0}$
\end_inset

 being the elements of 
\begin_inset Formula $D$
\end_inset

 corresponding to 
\begin_inset Formula $\vec{x}_{0}$
\end_inset

 and 
\begin_inset Formula $d_{0}$
\end_inset

 being the element corresponding to 
\begin_inset Formula $m$
\end_inset

,
 we have 
\begin_inset Formula $D\vDash\chi_{Q}(\vec{b}_{0},d_{0})$
\end_inset

 as a consequence of 
\begin_inset Formula $D\vDash\chi_{Q}(\vec{b},d)$
\end_inset

 as a consequence of 
\begin_inset Formula $D\vDash Q(\vec{b},d,\vec{c})$
\end_inset

,
 and moreover 
\begin_inset Formula $D\vDash\tau(\vec{b}_{0},d_{0})$
\end_inset

 by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "enu:asmtau"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 hence 
\begin_inset Formula $D\vDash\exists_{y}\left[\chi_{Q}(\vec{b}_{0},y)\land\tau_{q\varphi}(\vec{b}_{0},y)\right])$
\end_inset

,
 and thus 
\begin_inset Formula $D\vDash\etau_{q_{0}\varphi Q}(\vec{b}_{0})$
\end_inset

 by Item 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:qetpetau"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 of the QETP.
\end_layout

\begin_layout Standard
Once such a 
\begin_inset Formula $Q(\vec{x},z,\vec{y})$
\end_inset

 is found,
 one of two things occurs.
 Either it includes 
\begin_inset Formula $z=y_{j}$
\end_inset

 for some value of 
\begin_inset Formula $j$
\end_inset

,
 in which case we match 
\begin_inset Formula $d$
\end_inset

 to the element corresponding to 
\begin_inset Formula $y_{j}$
\end_inset

,
 or it includes the information that all its variables represent distinct elements,
 in which case we add a new element to 
\begin_inset Formula $M$
\end_inset

,
 whose relations to the previous elements are those dictated by 
\begin_inset Formula $Q$
\end_inset

,
 and match it to 
\begin_inset Formula $d$
\end_inset

.
\end_layout

\begin_layout Standard
We need to make sure that 
\begin_inset CommandInset ref
LatexCommand formatted
reference "enu:asmchi"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "enu:asmetau"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 hold.
\end_layout

\begin_layout Itemize
\begin_inset CommandInset ref
LatexCommand formatted
reference "enu:asmchi"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 – By construction,
 since we ensured 
\begin_inset Formula $D\vDash\chi_{Q}(\vec{b},d)$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset CommandInset ref
LatexCommand formatted
reference "enu:asmetau"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 – By construction.
\end_layout

\end_deeper
\begin_layout Itemize
Once both of the above steps are done,
 worker 
\begin_inset Formula $i$
\end_inset

 shall pause its execution,
 and initialize worker 
\begin_inset Formula $i+1$
\end_inset

.
\end_layout

\begin_layout Standard
We now describe the process of injury.
 There are three means of injury:
\end_layout

\begin_layout Itemize
Suppose that an element of 
\begin_inset Formula $D$
\end_inset

 is seen to be removed.
 If this element does not have a match in 
\begin_inset Formula $M$
\end_inset

,
 no action must be taken.
 On the other hand,
 suppose that this element 
\begin_inset Formula $d$
\end_inset

 is matched to an element 
\begin_inset Formula $m$
\end_inset

 in 
\begin_inset Formula $M$
\end_inset

.
 In that event,
 suppose that worker 
\begin_inset Formula $i$
\end_inset

 is the one that made this match,
 and halt the execution of all workers with index greater than 
\begin_inset Formula $i$
\end_inset

,
 erasing matches and assigned formulas created past the moment that 
\begin_inset Formula $m$
\end_inset

 and 
\begin_inset Formula $d$
\end_inset

 were matched.
 If the match between 
\begin_inset Formula $d$
\end_inset

 and 
\begin_inset Formula $m$
\end_inset

 was created by the first bullet point,
 restart the execution of worker 
\begin_inset Formula $i$
\end_inset

.
 If the match between 
\begin_inset Formula $d$
\end_inset

 and 
\begin_inset Formula $m$
\end_inset

 was created by the second bullet point,
 initialize worker 
\begin_inset Formula $i+1$
\end_inset

.
\end_layout

\begin_layout Itemize
Suppose that an element 
\begin_inset Formula $m\in M$
\end_inset

 has an assigned triplet 
\begin_inset Formula $(q,\varphi,\tau)$
\end_inset

,
 which is seen to be deleted from the enumeration described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rmk:tauwork"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 at a given stage.
 Suppose worker 
\begin_inset Formula $i$
\end_inset

 is the one who has assigned this formula.
 Then,
 we halt the execution of all workers with index greater than 
\begin_inset Formula $i$
\end_inset

,
 and erase all matches and assigned formulas created past the moment that this formula was assigned to 
\begin_inset Formula $m$
\end_inset

.
 Then,
 we run worker 
\begin_inset Formula $i$
\end_inset

.
\end_layout

\begin_layout Itemize
Suppose that an element 
\begin_inset Formula $m\in M$
\end_inset

 has an assigned triplet 
\begin_inset Formula $(q(\vec{x},y,\vec{z}),\varphi(\vec{x}),\tau(\vec{x},y))$
\end_inset

 and a matched element 
\begin_inset Formula $d$
\end_inset

.
 Suppose worker 
\begin_inset Formula $i$
\end_inset

 is the one who has created these matches.
 Suppose that the elements 
\begin_inset Formula $\vec{x}$
\end_inset

 are matched to the tuple 
\begin_inset Formula $\vec{b}$
\end_inset

,
 and suppose that the current approximation of 
\begin_inset Formula $D\vDash\tau(\vec{b},d)$
\end_inset

 has changed to 
\begin_inset Quotes els
\end_inset

no
\begin_inset Quotes ers
\end_inset

.
 Then,
 we halt the execution of all workers with index greater than 
\begin_inset Formula $i$
\end_inset

,
 erase all matches and assigned formulas created past this point (including the match between 
\begin_inset Formula $m$
\end_inset

 and 
\begin_inset Formula $d$
\end_inset

,
 but we retain the assigned triplet 
\begin_inset Formula $(q,\varphi,\tau)$
\end_inset

),
 and run worker 
\begin_inset Formula $i$
\end_inset

.
\end_layout

\begin_layout Standard
This concludes the construction.
 It remains to show that the resulting structure 
\begin_inset Formula $M$
\end_inset

 is isomorphic to 
\begin_inset Formula $D\upto\Lang$
\end_inset

,
 and this is done via a finite injury argument.
 We show that each worker will be injured finitely many times.
 This will show that every element in 
\begin_inset Formula $D$
\end_inset

 is eventually matched to an element of 
\begin_inset Formula $M$
\end_inset

 (the 
\begin_inset Formula $i$
\end_inset

-th element of 
\begin_inset Formula $D$
\end_inset

 (counting both real and fake elements) will be matched by,
 at worst,
 the 
\begin_inset Formula $i$
\end_inset

-th worker past the moment when this element is added to 
\begin_inset Formula $D$
\end_inset

),
 and that every element of 
\begin_inset Formula $M$
\end_inset

 is eventually matched to an element of 
\begin_inset Formula $D$
\end_inset

 (given an orphan element of 
\begin_inset Formula $M$
\end_inset

,
 inductively consider the first worker activated after all previous elements of 
\begin_inset Formula $M$
\end_inset

 have been matched),
 and since these matches all preserve the predicates in 
\begin_inset Formula $\Lang$
\end_inset

,
 the resulting map will be an isomorphism.
\end_layout

\begin_layout Standard
Suppose,
 for the sake of induction,
 that all workers prior to worker 
\begin_inset Formula $i$
\end_inset

 are injured finitely many times.
 We show that worker 
\begin_inset Formula $i$
\end_inset

 itself also suffers finite injury.
 We do this individually for each of the bullet points:
\end_layout

\begin_layout Itemize
First,
 we show that the matching created by the first orphan element of 
\begin_inset Formula $m$
\end_inset

 at this moment,
 if there is any,
 is injured finitely many times.
 Indeed,
 per the notation of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rmk:tauwork"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 and using Item 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:qetp2"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 of the QETP,
 eventually a triplet 
\begin_inset Formula $(q,\varphi,\tau)$
\end_inset

 will be enumerated and never removed,
 such that the relevant elements of 
\begin_inset Formula $D$
\end_inset

 satisfy 
\begin_inset Formula $\chi_{q}\land\varphi$
\end_inset

.
 Past this point,
 after all previously-added false triplets have been removed,
 this triplet (or another) will be permanently assigned to 
\begin_inset Formula $m$
\end_inset

.
 Afterward,
 we know (see the technical note in the first bullet point of the description of the worker process) that after enough steps we match 
\begin_inset Formula $m$
\end_inset

 with a real element 
\begin_inset Formula $d$
\end_inset

 of 
\begin_inset Formula $D$
\end_inset

 that satisfies 
\begin_inset Formula $\tau(\vec{b},d)$
\end_inset

 at the current approximation,
 which will nevermore change.
 Thus,
 past this point,
 this match will never be injured.
\end_layout

\begin_layout Itemize
Now,
 assuming that we've reached a time where the matching created by the previous bullet point or previous workers will never suffer injury,
 suppose that there is an unmatched element in 
\begin_inset Formula $D$
\end_inset

 for worker 
\begin_inset Formula $i$
\end_inset

 to match with an element of 
\begin_inset Formula $M$
\end_inset

.
 If this element is real,
 no injury will be suffered.
 If it is not,
 eventually it shall be erased,
 and execution will move to worker 
\begin_inset Formula $i+1$
\end_inset

,
 with worker 
\begin_inset Formula $i$
\end_inset

 nevermore suffering injury from that point.
\end_layout

\begin_layout Standard
This concludes the proof.
\end_layout

\end_deeper
\begin_layout Section
Previously Known Applications
\end_layout

\begin_layout Standard
In this section,
 we present a list of some consequences of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
 We claim originality over none of the results themselves – our goal here is merely to show how they all follow from the same general principle,
 and we present prior references to where the results may be found in the literature.
\end_layout

\begin_layout Standard
All of the following results are bidirectional,
 but due to the direction of this paper,
 we will only be focusing on the most relevant of the two directions in each case,
 which will generally be arguably the most difficult one.
\end_layout

\begin_layout Subsection
Equivalence Relations of Infinite Rank
\end_layout

\begin_layout Proposition
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Folklore,
 
\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "cst_downey_melnikov"
posttextlist "cst_downey_melnikov Theorem 9.1.4"
literal "false"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "prop:eqvinf"

\end_inset


\begin_inset FormulaMacro
\newcommand{\eqvrel}{\simeq}
\end_inset

Let 
\begin_inset Formula $(E,\eqvrel)$
\end_inset

 be an equivalence relation with infinitely many equivalence classes,
 and assume that the structure 
\begin_inset Formula $(E,\eqvrel,\{P_{\geq n}\}_{n\in\N})$
\end_inset

 admits a 
\begin_inset Formula $0'$
\end_inset

-computable copy,
 where 
\begin_inset Formula $P_{\geq n}(x)$
\end_inset

 is the predicate 
\begin_inset Quotes eld
\end_inset

the equivalence class of 
\begin_inset Formula $x$
\end_inset

 has size at least 
\begin_inset Formula $n$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 Then,
 
\begin_inset Formula $(E,\eqvrel)$
\end_inset

 admits a computable copy.
\end_layout

\begin_layout Proof
First,
 we note that if 
\begin_inset Formula $(E,\eqvrel,\{P_{\geq n}\}_{n\in\N})$
\end_inset

 admits a 
\begin_inset Formula $0'$
\end_inset

-computable copy then 
\begin_inset Formula $(E,\eqvrel,\{P_{\geq n}\}_{n\in\N\cup\{\infty\}})$
\end_inset

 admits a 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed copy,
 where 
\begin_inset Formula $P_{\geq\infty}(x)$
\end_inset

 is the predicate 
\begin_inset Quotes eld
\end_inset

the equivalence class of 
\begin_inset Formula $x$
\end_inset

 is infinite
\begin_inset Quotes erd
\end_inset

.
 We construct this copy as follows:
 With an oracle for 
\begin_inset Formula $0'$
\end_inset

,
 run the construction of 
\begin_inset Formula $(E,\eqvrel,\{P_{\geq n}\}_{n\in\N})$
\end_inset

,
 and every time you see an element in a new finite equivalence class of size exactly 
\begin_inset Formula $n$
\end_inset

 (i.e.
\begin_inset space \space{}
\end_inset

satisfies 
\begin_inset Formula $P_{\geq n}$
\end_inset

 but not 
\begin_inset Formula $P_{\geq n+1}$
\end_inset

),
 output an equivalence class of size exactly 
\begin_inset Formula $n$
\end_inset

.
 In the limit,
 you will output a copy of the substructure of 
\begin_inset Formula $E$
\end_inset

 consisting of the elements in finite equivalence classes.
 In parallel,
 build countably many infinite equivalence classes.
 Since we know everything about the equivalence class of any given element when we are outputting it,
 it is trivial to provide a c.e.
\begin_inset space \space{}
\end_inset

(or even computable) index for the type of the tuple of elements output up to a given point.
\end_layout

\begin_layout Proof
Next,
 we show that 
\begin_inset Formula $E$
\end_inset

 satisfies the QETP relative to the languages:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\Lang$
\end_inset

 is the language containing 
\begin_inset Formula $\eqvrel$
\end_inset

,
 
\begin_inset Formula $\not\eqvrel$
\end_inset

,
 
\begin_inset Formula $=$
\end_inset

,
 and 
\begin_inset Formula $\neq$
\end_inset

,
\end_layout

\begin_layout Itemize
\begin_inset Formula $\Lang'$
\end_inset

 is the language containing 
\begin_inset Formula $\Lang$
\end_inset

,
 plus the countably many predicates 
\begin_inset Formula $P_{\geq n}$
\end_inset

.
\end_layout

\begin_layout Standard
It is obvious that 
\begin_inset Formula $\Lang$
\end_inset

 is finite and closed under negation,
 so it suffices to construct 
\begin_inset Formula $\chi$
\end_inset

,
 
\begin_inset Formula $\tau$
\end_inset

,
 and 
\begin_inset Formula $\etau$
\end_inset

.
\end_layout

\begin_layout Itemize
To construct 
\begin_inset Formula $\chi_{q}(\vec{x})$
\end_inset

 given 
\begin_inset Formula $q(\vec{x},\vec{y})$
\end_inset

:
 Without loss of generality,
 as is usual in quantifier-elimination type arguments,
 we assume that 
\begin_inset Formula $q(\vec{x},\vec{y})$
\end_inset

 is a maximal disjunction of atomic formulas of the types:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $y_{i}\eqvrel x_{j}$
\end_inset

 or 
\begin_inset Formula $y_{i}\not\eqvrel x_{j}$
\end_inset

,
 and one of these is included for every 
\begin_inset Formula $i$
\end_inset

 and 
\begin_inset Formula $j$
\end_inset

,
\end_layout

\begin_layout Itemize
\begin_inset Formula $y_{i}\eqvrel y_{j}$
\end_inset

 or 
\begin_inset Formula $y_{i}\not\eqvrel y_{j}$
\end_inset

,
 and one of these is included for every 
\begin_inset Formula $i$
\end_inset

 and 
\begin_inset Formula $j$
\end_inset

,
\end_layout

\begin_layout Itemize
\begin_inset Formula $y_{i}\neq y_{j}$
\end_inset

,
 and all of these are included for 
\begin_inset Formula $i\neq j$
\end_inset

,
\end_layout

\begin_layout Itemize
\begin_inset Formula $y_{i}\neq x_{j}$
\end_inset

,
 and all of these are included for every 
\begin_inset Formula $i$
\end_inset

 and 
\begin_inset Formula $j$
\end_inset

.
\end_layout

\begin_layout Standard
We also assume without loss of generality that 
\begin_inset Formula $q$
\end_inset

 includes the information that every 
\begin_inset Formula $x_{i}$
\end_inset

 and 
\begin_inset Formula $y_{j}$
\end_inset

 is distinct from evert other,
 and that we have knowledge about the equivalences or lack thereof between them.
\end_layout

\begin_layout Standard
Thus,
 
\begin_inset Formula $q(\vec{x},\vec{y})$
\end_inset

 includes all the information about these elements in terms of what equivalence classes they inhabit.
 If the information is inconsistent,
 (namely,
 if it fails transitivity,
 reflexivity,
 or symmetry),
 simply set 
\begin_inset Formula $\chi_{q}(\vec{x})\equiv\bot$
\end_inset

.
 On the other hand,
 if the information is consistent,
 for such a tuple 
\begin_inset Formula $\vec{y}$
\end_inset

 to exist given the tuple 
\begin_inset Formula $\vec{x}$
\end_inset

 requires,
 and indeed is equivalent,
 to the demand that the equivalence class of each 
\begin_inset Formula $x_{i}$
\end_inset

 is large enough – namely,
 the equivalence class of 
\begin_inset Formula $x_{i}$
\end_inset

 must be of size 
\begin_inset Formula $n_{i}$
\end_inset

 or above,
 where 
\begin_inset Formula $n_{i}$
\end_inset

 is the number of distinct variables 
\begin_inset Formula $z$
\end_inset

 such that 
\begin_inset Formula $z\eqvrel x_{i}$
\end_inset

 is part of the information in 
\begin_inset Formula $q$
\end_inset

.
 As such,
 we set 
\begin_inset Formula $\chi_{q}(\vec{x})\equiv q_{0}(\vec{x})\land\bigwedge_{i}P_{\geq n_{i}}(x_{i})$
\end_inset

,
 where 
\begin_inset Formula $q_{0}(\vec{x})$
\end_inset

 is the information in 
\begin_inset Formula $q$
\end_inset

 that relates the elements of 
\begin_inset Formula $\vec{x}$
\end_inset

.
 It will satisfy the requirements about 
\begin_inset Formula $\chi$
\end_inset

 by construction.
\end_layout

\begin_layout Standard
Note that we are using the assumption that there exist infinitely many arbitrarily large equivalence classes to handle variables 
\begin_inset Formula $y_{i}$
\end_inset

 that are not equivalent to any 
\begin_inset Formula $x_{j}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
To construct 
\begin_inset Formula $\tau_{q\varphi}(\vec{x},y)$
\end_inset

:
 The domain of 
\begin_inset Formula $\tau$
\end_inset

 shall be the set of pairs 
\begin_inset Formula $(q,\top)$
\end_inset

.
 Given 
\begin_inset Formula $q(\vec{x},y,\vec{z})$
\end_inset

,
 set 
\begin_inset Formula $\tau_{q\top}(\vec{x},y)\equiv\chi_{q}(\vec{x},y)\land\left(P_{\geq\infty}(y)\lor\bigvee_{i}y\eqvrel x_{i}\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
To construct 
\begin_inset Formula $\etau_{q\varphi Q}(\vec{x})$
\end_inset

:
 Simply set 
\begin_inset Formula $\etau_{q\varphi Q}(\vec{x})\equiv\chi_{Q}(\vec{x})$
\end_inset

 in all circumstances.
\end_layout

\begin_layout Standard
It is a tedious but straight-forward exercise in model theory to verify that the above assignments serve as witnesses to the QETP.
 We use the fact that there are infinitely many infinite equivalence classes in an essential way when verifying Item 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:qetp1"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 of the QETP.
 By application of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 the proof is complete.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
There are a few properties of the above proof that will come up again,
 so we remark on them now.
\end_layout

\begin_layout Remark
We have used a very weak version of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
 For example:
 We used no infinitary formulas,
 our 
\begin_inset Formula $\tau$
\end_inset

 was computable with computable domain,
 instead of merely 
\begin_inset Formula $0'$
\end_inset

-computable with 
\begin_inset Formula $0'$
\end_inset

-c.e.
\begin_inset space \space{}
\end_inset

domain,
 etc.
 This reflects the fact that,
 as far as jump inversion theorems go,
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:eqvinf"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 is rather simple!
 We will see some other natural (though not necessarily much more complicated) examples that use more of the power of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
Even though 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 provides a 
\begin_inset Formula $0'$
\end_inset

-computable isomorphism between the reduct of the original structure and the resulting structure,
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:eqvinf"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 does not provide such a guarantee.
 Indeed,
 one can show that the best we can do in general is to find a 
\begin_inset Formula $0''$
\end_inset

-computable isomorphism between the original 
\begin_inset Formula $0'$
\end_inset

-computable equivalence relation – call it 
\begin_inset Formula $E_{0}$
\end_inset

 –,
 and the computable copy – call it 
\begin_inset Formula $E_{1}$
\end_inset

.
 This stems from the fact that we have built an intermediate auxilliary structure to apply 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 to – say 
\begin_inset Formula $E_{+}$
\end_inset

 – and even though 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 guarantees that there is a 
\begin_inset Formula $0'$
\end_inset

-computable isomorphism between 
\begin_inset Formula $E_{+}$
\end_inset

 and 
\begin_inset Formula $E_{1}$
\end_inset

,
 an isomorphism between 
\begin_inset Formula $E_{0}$
\end_inset

 and 
\begin_inset Formula $E_{+}$
\end_inset

 may be computably more complicated.
 The best that we can guarantee,
 and indeed the best that can be guaranteed,
 is that such an isomorphism is 
\begin_inset Formula $0''$
\end_inset

-computable,
 as 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:eqvcomplexiso"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 below shows.
\end_layout

\begin_layout Proposition
\begin_inset CommandInset label
LatexCommand label
name "prop:eqvcomplexiso"

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
is this anywhere in the literature?
\end_layout

\end_inset

There is a 
\begin_inset Formula $0'$
\end_inset

-computable equivalence relation 
\begin_inset Formula $(E_{0},\eqvrel,\{P_{\geq n}\}_{n\in\N})$
\end_inset

 with infinitely many infinite equivalence classes such that any isomorphism 
\begin_inset Formula $f$
\end_inset

 between 
\begin_inset Formula $E_{0}\upto\eqvrel$
\end_inset

 and a computable equivalence relation 
\begin_inset Formula $(E_{1},\eqvrel)$
\end_inset

 can be used to compute 
\begin_inset Formula $0''$
\end_inset

.
\end_layout

\begin_layout Proof
We shall build 
\begin_inset Formula $E_{0}=E_{00}\amalg E_{01}$
\end_inset

,
 where 
\begin_inset Formula $E_{00}$
\end_inset

 shall be used to encode 
\begin_inset Formula $0'$
\end_inset

 (into any isomorphism between 
\begin_inset Formula $E_{0}$
\end_inset

 and a computable equivalence relation),
 and 
\begin_inset Formula $E_{01}$
\end_inset

 shall be used to encode 
\begin_inset Formula $0''$
\end_inset

,
 via encoding the set of total Turing indices – though the decoding process will require the usage of 
\begin_inset Formula $0'$
\end_inset

,
 which is why 
\begin_inset Formula $E_{00}$
\end_inset

 is necessary.
\end_layout

\begin_layout Proof
To build 
\begin_inset Formula $E_{00}$
\end_inset

:
 Consider designated elements 
\begin_inset Formula $a_{0}$
\end_inset

,
 
\begin_inset Formula $a_{1}$
\end_inset

,
 
\begin_inset Formula $a_{2}$
\end_inset

,
 etc.
 where 
\begin_inset Formula $a_{2n}$
\end_inset

 is defined to be equivalent to 
\begin_inset Formula $a_{2n+1}$
\end_inset

 if,
 and only if,
 
\begin_inset Formula $n\in0'$
\end_inset

,
 and no other equivalences exist between any 
\begin_inset Formula $a_{i}$
\end_inset

and any other element of 
\begin_inset Formula $E_{0}$
\end_inset

.
 If we have an isomorphism 
\begin_inset Formula $f$
\end_inset

 between 
\begin_inset Formula $E_{0}$
\end_inset

 and a computable equivalence relation,
 we can therefore tell if 
\begin_inset Formula $n\in0'$
\end_inset

 by checking whether 
\begin_inset Formula $f(a_{2n})$
\end_inset

 is equivalent to 
\begin_inset Formula $f(a_{2n+1})$
\end_inset

.
\end_layout

\begin_layout Proof
To build 
\begin_inset Formula $E_{01}$
\end_inset

:
 Consider designated elements 
\begin_inset Formula $\{b_{nx}\}_{(n,x)\in\N^{2}}$
\end_inset

.
 For each 
\begin_inset Formula $n\in\N$
\end_inset

,
 iterate through the values of 
\begin_inset Formula $x\in\N$
\end_inset

 until such an 
\begin_inset Formula $x$
\end_inset

 is found with 
\begin_inset Formula $\varphi_{n}(x)\isnotwd$
\end_inset

.
 If no such 
\begin_inset Formula $x$
\end_inset

 is found,
 make 
\begin_inset Formula $b_{ni}\eqvrel b_{nj}$
\end_inset

 for all 
\begin_inset Formula $i$
\end_inset

,
 
\begin_inset Formula $j$
\end_inset

.
 Otherwise,
 suppose that 
\begin_inset Formula $x$
\end_inset

 is the first value for which 
\begin_inset Formula $\varphi_{n}(x)\isnotwd$
\end_inset

.
 Look through the first 
\begin_inset Formula $x$
\end_inset

 elements of the 
\begin_inset Formula $n$
\end_inset

 computable equivalence classes,
 and using 
\begin_inset Formula $0'$
\end_inset

 find a number 
\begin_inset Formula $k\geq x$
\end_inset

 such that none of these 
\begin_inset Formula $xn$
\end_inset

 elements are in an equivalence class of size exactly 
\begin_inset Formula $k$
\end_inset

.
 Then,
 make 
\begin_inset Formula $b_{n0}\eqvrel\dots\eqvrel b_{nk}$
\end_inset

,
 and no other 
\begin_inset Formula $b_{ni}$
\end_inset

 equivalent to any other.
 The essential part of this choice is that it ensures that no isomorphism between 
\begin_inset Formula $E_{0}$
\end_inset

 and one of these equivalence classes will take 
\begin_inset Formula $b_{n0}$
\end_inset

 to one of their first 
\begin_inset Formula $x$
\end_inset

 elements.
\end_layout

\begin_layout Proof
Now,
 let us show that any isomorphism 
\begin_inset Formula $f$
\end_inset

 between 
\begin_inset Formula $E_{0}$
\end_inset

 and a computable equivalence relation 
\begin_inset Formula $E_{1}$
\end_inset

 will compute 
\begin_inset Formula $0''$
\end_inset

.
 As argued before,
 
\begin_inset Formula $f$
\end_inset

 computes 
\begin_inset Formula $0'$
\end_inset

,
 so we use an oracle for 
\begin_inset Formula $0'$
\end_inset

 with impunity.
 Suppose we wish to know whether some 
\begin_inset Formula $n\in\N$
\end_inset

 is a total Turing index.
 Without loss of generality – because this happens all but finitely many times – assume that 
\begin_inset Formula $E_{1}$
\end_inset

 is one of the first 
\begin_inset Formula $n$
\end_inset

 computable equivalence classes.
 Then,
 find the index of 
\begin_inset Formula $f(b_{n0})$
\end_inset

 in the equivalence relation 
\begin_inset Formula $E_{1}$
\end_inset

 – say this index is 
\begin_inset Formula $t$
\end_inset

 – and check whether 
\begin_inset Formula $\varphi_{n}(0)$
\end_inset

 up to 
\begin_inset Formula $\varphi_{n}(t)$
\end_inset

 all terminate.
 If not,
 then clearly 
\begin_inset Formula $\varphi_{n}$
\end_inset

 is nontotal.
 On the other hand,
 if 
\begin_inset Formula $\varphi_{n}$
\end_inset

 is nontotal,
 with 
\begin_inset Formula $x$
\end_inset

 the first element with 
\begin_inset Formula $\varphi_{n}(x)\isnotwd$
\end_inset

,
 we know that 
\begin_inset Formula $f(b_{n0})$
\end_inset

 must have index 
\begin_inset Formula $t$
\end_inset

 greater than 
\begin_inset Formula $x$
\end_inset

,
 in which case one of the computations 
\begin_inset Formula $\varphi_{n}(0)$
\end_inset

 to 
\begin_inset Formula $\varphi_{n}(t)$
\end_inset

 will not have terminated.
 Thus,
 checking these first 
\begin_inset Formula $t$
\end_inset

 elements suffices to tell whether 
\begin_inset Formula $\varphi_{n}$
\end_inset

 is total.
\end_layout

\begin_layout Remark
Our choice of 
\begin_inset Formula $\tau_{q\varphi}$
\end_inset

 included 
\begin_inset Formula $\chi_{q}$
\end_inset

 in its definition,
 and our choice of 
\begin_inset Formula $\etau_{q\varphi Q}$
\end_inset

 included (and,
 in this case,
 was equal to) 
\begin_inset Formula $\chi_{Q}$
\end_inset

.
 Inspecting the definition of QETP,
 one finds that we can always do so – that is,
 if 
\begin_inset Formula $\chi_{q}$
\end_inset

,
 
\begin_inset Formula $\tau_{q\varphi}$
\end_inset

,
 and 
\begin_inset Formula $\etau_{q\varphi Q}$
\end_inset

 serve as witnesses to the QETP,
 so will 
\begin_inset Formula $\chi_{q}$
\end_inset

,
 
\begin_inset Formula $\tau_{q\varphi}\land\chi_{q}$
\end_inset

,
 and 
\begin_inset Formula $\etau_{q\varphi Q}\land\chi_{Q}$
\end_inset

,
 though the converse need not be true.
\end_layout

\begin_layout Remark
If we had wanted to,
 we could have modified the definition of QETP to make our formulas simpler in practice,
 by replacing e.g.
\begin_inset space \space{}
\end_inset

every instance of 
\begin_inset Formula $\tau$
\end_inset

 with 
\begin_inset Formula $\tau\land\chi$
\end_inset

,
 and likewise for 
\begin_inset Formula $\etau$
\end_inset

.
 For instance,
 Item 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:qetp3"

\end_inset

 currently requires
\begin_inset Formula 
\[
D\vDash\forall_{\vec{x},y}\left[\etau_{q\varphi Q}(\vec{x})\land\tau_{q\varphi}(\vec{x},y)\rightarrow\chi_{Q}(\vec{x},y)\right],
\]

\end_inset

and we might consider making the weaker requirement that
\begin_inset Formula 
\[
D\vDash\forall_{\vec{x},y}\left[\etau_{q\varphi Q}(\vec{x})\land\chi_{Q}(\vec{x})\land\tau_{q\varphi}(\vec{x},y)\land\chi_{q}(\vec{x},y)\rightarrow\chi_{Q}(\vec{x},y)\right].
\]

\end_inset


\end_layout

\begin_layout Remark
Such a change would not alter which structures satisfy the QETP,
 only what their witnessing formulas are,
 and if we were optimizing for the writing of applications,
 we could have used the weaker version instead.
 For example,
 in the case of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:eqvinf"

\end_inset

,
 we currently have
\begin_inset Formula 
\[
\tau_{q}(\vec{x},y)\equiv\chi_{q}(\vec{x},y)\land\left(P_{\geq\infty}(y)\lor\bigvee_{i}y\eqvrel x_{i}\right)\text{ and }\etau_{q\varphi Q}(\vec{x})\equiv\chi_{Q}(\vec{x}),
\]

\end_inset

and with the alternate version of the QETP this could be replaced by the simpler and arguably more elegant
\begin_inset Formula 
\[
\tau_{q}(\vec{x},y)\equiv P_{\geq\infty}(y)\lor\bigvee_{i}y\eqvrel x_{i}\text{ and }\etau_{q\varphi Q}(\vec{x})\equiv\top.
\]

\end_inset

We opted against using this sleeker version of the QETP because the definition was already technical and complicated enough as it is,
 and we gave priority to the understandability of the definition over a minor gain in characters in the proof of applications.
\end_layout

\begin_layout Subsection
Equivalence Relations of Finite Rank
\end_layout

\begin_layout Standard
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:eqvfin"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 below was one of the main motivators for the current form of the QETP.
 We need to state a couple of important definitions first.
\end_layout

\begin_layout Definition
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Khisamiev,
 
\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "cst_downey_melnikov"
posttextlist "cst_downey_melnikov Definition 9.1.3"
literal "false"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset

A set 
\begin_inset Formula $X\subseteq\N$
\end_inset

 is said to be 
\emph on
limitwise monotonic
\emph default
 if there is a total computable function 
\begin_inset Formula $f\colon\N\times\N\to\N$
\end_inset

 such that,
 for every 
\begin_inset Formula $x\in\N$
\end_inset

,
 the sequence 
\begin_inset Formula $\{f(x,y)\}_{y\in\N}$
\end_inset

 is increasing and bounded (and therefore convergent),
 and 
\begin_inset Formula $X$
\end_inset

 is the image of the pointwise limit function 
\begin_inset Formula $g(x)=\lim_{y}f(x,y)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "cst_downey_melnikov"
posttextlist "cst_downey_melnikov Definition 9.1.1"
literal "false"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset

Let 
\begin_inset Formula $(E,\eqvrel)$
\end_inset

 be an equivalence relation.
 The 
\emph on
characteristic set of 
\begin_inset Formula $E$
\end_inset


\emph default
 is the set
\begin_inset Formula 
\[
\#E=\{\,n\in\N\mid\text{\ensuremath{E} admits at least one equivalence class of size \ensuremath{n}}\,\}.
\]

\end_inset


\end_layout

\begin_layout Proposition
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Folklore,
 
\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "cst_downey_melnikov"
posttextlist "cst_downey_melnikov Theorem 9.1.4"
literal "false"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "prop:eqvfin"

\end_inset

Let 
\begin_inset Formula $(E,\eqvrel)$
\end_inset

 be an equivalence relation with finitely many equivalence classes,
 and assume that the structure 
\begin_inset Formula $(E,\eqvrel,\{P_{\geq n}\}_{n\in\N})$
\end_inset

 admits a 
\begin_inset Formula $0'$
\end_inset

-computable copy,
 where 
\begin_inset Formula $P_{\geq n}(x)$
\end_inset

 is the predicate 
\begin_inset Quotes eld
\end_inset

the equivalence class of 
\begin_inset Formula $x$
\end_inset

 has size at least 
\begin_inset Formula $n$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 Assume moreover that the characteristic set of 
\begin_inset Formula $E$
\end_inset

 is limitwise monotonic.
 Then,
 
\begin_inset Formula $(E,\eqvrel)$
\end_inset

 admits a computable copy.
\end_layout

\begin_layout Proof
Similarly but not exactly like in proof of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:eqvinf"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 our first step is to construct a 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed copy of 
\begin_inset Formula $(E,\eqvrel,\{P_{\geq n}\}_{n\in\N\cup\{\infty\}},\{P_{=n}\}_{n\in\N\cup\{\infty\}})$
\end_inset

,
 where 
\begin_inset Formula $P_{=n}(x)$
\end_inset

 denotes 
\begin_inset Quotes eld
\end_inset

the equivalence class of 
\begin_inset Formula $x$
\end_inset

 has size exactly 
\begin_inset Formula $n$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 The same construction as in the proof of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:eqvinf"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 can be used with very minor modifications.
 The added predicates are no issue,
 because when we add an element we already know its equivalence class size exactly,
 and instead of manually adding infinitely many equivalence classes,
 we add as many as 
\begin_inset Formula $E$
\end_inset

 has (a finite number which has to be obtained non-uniformly).
 It then remains to show that 
\begin_inset Formula $(E,\eqvrel,\{P_{\geq n}\}_{n\leq\infty},\{P_{=n}\}_{n\leq\infty})$
\end_inset

 has the QETP over the language containing only 
\begin_inset Formula $\eqvrel$
\end_inset

 (and its negation,
 and equality and its negation),
 though there are some added technicalities.
\end_layout

\begin_layout Proof
Throughout,
 we shall assume that 
\begin_inset Formula $E$
\end_inset

 admits arbitrarily large finite equivalence classes,
 or in other words that 
\begin_inset Formula $\#E$
\end_inset

 is an infinite set.
 The case where 
\begin_inset Formula $\#E$
\end_inset

 is finite is relatively trivial and is handled separately:
 If 
\begin_inset Formula $\#E$
\end_inset

 is finite,
 then it takes finitely much space to encode how many equivalence classes 
\begin_inset Formula $E$
\end_inset

 admits in each size,
 and we simply make a computable equivalence relation with this specification.
 We will see in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rmk:cardefinitehard"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 that this is necessary,
 and in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rmk:cardefinitewhy"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 the root cause and how to get around it.
\end_layout

\begin_deeper
\begin_layout Itemize
To construct 
\begin_inset Formula $\chi_{q}(\vec{x})$
\end_inset

 given 
\begin_inset Formula $q(\vec{x},\vec{y})$
\end_inset

:
 The same construction as in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:eqvinf"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 holds,
 so long as,
 as therein observed,
 
\begin_inset Formula $E$
\end_inset

 is assumed to have arbitrarily large finite equivalence classes.
\end_layout

\begin_layout Itemize
To construct 
\begin_inset Formula $\tau$
\end_inset

:
 Let 
\begin_inset Formula $q(\vec{x},y,\vec{z})$
\end_inset

 range over the quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

-types realized in 
\begin_inset Formula $E$
\end_inset

,
 and let 
\begin_inset Formula $\varphi(\vec{x})$
\end_inset

 range over the possible assignments of equivalence class sizes for the elements of the tuple 
\begin_inset Formula $\vec{x}$
\end_inset

.
 For such a pair 
\begin_inset Formula $(q,\varphi)$
\end_inset

,
 set 
\begin_inset Formula $N_{0}$
\end_inset

 to be the largest finite size of equivalence class imposed by 
\begin_inset Formula $\varphi(\vec{x})$
\end_inset

,
 set 
\begin_inset Formula $N_{1}$
\end_inset

 to be the smallest size of the equivalence class of a 
\begin_inset Formula $y$
\end_inset

 that satisfies 
\begin_inset Formula $\chi_{q}(\vec{x},y)$
\end_inset

,
 and find the smallest pair 
\begin_inset Formula $(i,j)$
\end_inset

 in some fixed well-ordering of 
\begin_inset Formula $\N^{2}$
\end_inset

 that satisfies 
\begin_inset Formula $f(i,j)>\max\{N_{0},N_{1}\}$
\end_inset

.
 Then,
 set 
\begin_inset Formula $M(i)=\lim_{k}f(i,k)$
\end_inset

.
 Finally,
 we set 
\begin_inset Formula 
\[
\tau_{q\varphi}(\vec{x},y)\equiv\chi_{q}(\vec{x},y)\land\left(P_{=M(i)}(y)\lor\bigvee_{i}y\eqvrel x_{i}\right).
\]

\end_inset

.
\end_layout

\begin_layout Itemize
To construct 
\begin_inset Formula $\etau_{q\varphi Q}(\vec{x})$
\end_inset

,
 let 
\begin_inset Formula $N$
\end_inset

 be the least equivalence class size that 
\begin_inset Formula $y$
\end_inset

 would need to have in order to satisfy 
\begin_inset Formula $\chi_{Q}(y)$
\end_inset

,
 and 
\begin_inset Formula $i$
\end_inset

 the value obtained from the previous bullet point,
 and set
\begin_inset Formula 
\[
\etau_{q\varphi Q}(\vec{x})\equiv\llor_{k\in\N}\chi_{Q}(\vec{x})\land\left(\left\llbracket f(i,k)\geq N\right\rrbracket \lor\bigvee_{i}y\eqvrel x_{i}\right),
\]

\end_inset

where 
\begin_inset Formula $\llbracket f(i,k)\geq N\rrbracket$
\end_inset

 denotes
\begin_inset Formula 
\[
\llbracket f(i,k)\geq N\rrbracket\equiv\begin{cases}
\top & \text{if \ensuremath{f(i,k)\geq N},}\\
\bot & \text{otherwise.}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
As in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:eqvinf"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 checking the QETP is a straight-forward,
 if tedious,
 affair.
 The most interesting part of the proof consists of noticing that 
\begin_inset Formula $\etau_{q\varphi Q}(\vec{x})$
\end_inset

 is logically equivalent to 
\begin_inset Formula $\chi_{Q}(\vec{x})\land\left(\llbracket M(i)\geq N\rrbracket\lor\bigvee_{i}y\eqvrel x_{i}\right)$
\end_inset

,
 which uses the fact that 
\begin_inset Formula $f(i,k)$
\end_inset

 is monotonic in 
\begin_inset Formula $k$
\end_inset

.
 By application of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 the proof is complete in the case where 
\begin_inset Formula $\#E$
\end_inset

 is infinite.
\end_layout

\end_deeper
\begin_layout Remark
Unlike in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:eqvinf"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 for 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:eqvfin"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 we can,
 in fact,
 guarantee the existence of a 
\begin_inset Formula $0'$
\end_inset

-computable isomorphism,
 albeit non-uniformly so.
 To do this,
 one picks one element of each infinite equivalence class of the original equivalence relation,
 say 
\begin_inset Formula $E_{0}$
\end_inset

,
 and hard-codes this collection of representatives into our algorithm (which is fine,
 because there are finitely many of them).
 Then,
 in the case where 
\begin_inset Formula $\#E$
\end_inset

 is infinite (the case where 
\begin_inset Formula $\#E$
\end_inset

 is finite is straightforward and left to the reader),
 one defines 
\begin_inset Formula $E_{+}$
\end_inset

 as outlined in the proof,
 and defines an isomorphism between 
\begin_inset Formula $E_{0}$
\end_inset

 and 
\begin_inset Formula $E_{+}$
\end_inset

 as follows:
 The elements of 
\begin_inset Formula $E_{0}$
\end_inset

 that belong to a finite equivalence class are mapped in an obvious way to the equivalence class they're responsible for creating,
 and the elements of 
\begin_inset Formula $E_{0}$
\end_inset

 that belong to an infinite class are detected (by checking against equivalence with one of the finitely many representatives),
 and to each infinite class of 
\begin_inset Formula $E_{0}$
\end_inset

 one remembers an infinite class of 
\begin_inset Formula $E_{+}$
\end_inset

 to biject it to,
 and does so.
 This isomorphism is 
\begin_inset Formula $0'$
\end_inset

-computable,
 and since there is also a 
\begin_inset Formula $0'$
\end_inset

-computable isomorphism between 
\begin_inset Formula $E_{+}$
\end_inset

 and the final computable equivalence relation 
\begin_inset Formula $E_{1}$
\end_inset

,
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:eqvfin"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 can in fact be made to guarantee the existence of a 
\begin_inset Formula $0'$
\end_inset

-computable isomorphism.
\end_layout

\begin_layout Remark
To show that this cannot be done uniformly,
 not even for the case where the equivalence relation 
\begin_inset Formula $E_{0}$
\end_inset

 is guaranteed to have equivalence classes of every finite size (which immediately makes 
\begin_inset Formula $\#E$
\end_inset

 uniformly limitwise monotonic) and have at most – or even exactly – one infinite equivalence class,
 one can piggyback on the proof of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:eqvcomplexiso"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 by noticing that the equivalence relation therein defined is a computable disjoint union 
\begin_inset Formula $\amalg_{i}E_{(i)}$
\end_inset

 of infinite equivalence relations with either zero or one infinite classes.
 These equivalence relations also do not have equivalence classes of every finite size,
 but since the factor that makes the isomorphism computably complicated is the designated elements of each 
\begin_inset Formula $E_{(i)}$
\end_inset

,
 we can simply append one equivalence class of each size to every 
\begin_inset Formula $E_{(i)}$
\end_inset

.
 We can also ensure that each 
\begin_inset Formula $E_{(i)}$
\end_inset

 has exactly one infinite class by,
 in the case of (in the language of the proof of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:eqvcomplexiso"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

) 
\begin_inset Formula $E_{00}$
\end_inset

,
 simply appending one infinite class,
 and in the case of each component of 
\begin_inset Formula $E_{01}$
\end_inset

,
 making all the 
\begin_inset Formula $\{b_{ni}\}_{i}$
\end_inset

 equivalent for large values of 
\begin_inset Formula $i$
\end_inset

 (instead of making them all singleton classes).
 This shows that 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:eqvfin"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 cannot be made to uniformly produce a 
\begin_inset Formula $0'$
\end_inset

-computable isomorphism,
 even restricted to the case where the equivalence relation has exactly one equivalence class of every size in 
\begin_inset Formula $\N\cup\{\infty\}$
\end_inset

.
\end_layout

\begin_layout Remark
On the flip side,
 if 
\begin_inset Formula $E_{0}$
\end_inset

 is guaranteed to have 
\emph on
no
\emph default
 infinite classes whilst still having 
\begin_inset Formula $\#E$
\end_inset

 infinite limitwise monotonic,
 we do in fact obtain uniformity
\emph on
 in 
\begin_inset Formula $E_{0}$
\end_inset

 together with a witness to the fact that 
\begin_inset Formula $\#E$
\end_inset

 is limitwise monotonic
\emph default
,
 and this is direct from the proof of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:eqvfin"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

:
 If 
\begin_inset Formula $E_{0}$
\end_inset

 has no equivalence classes,
 the isomorphism between 
\begin_inset Formula $E_{0}$
\end_inset

 and 
\begin_inset Formula $E_{+}$
\end_inset

 is easily and uniformly constructed,
 and we need the witness that 
\begin_inset Formula $\#E$
\end_inset

 is limitwise monotonic to construct 
\begin_inset Formula $\etau$
\end_inset

.
\end_layout

\begin_layout Remark
Finally,
 here is a sketch of proof that you really do need a witness to 
\begin_inset Formula $\#E$
\end_inset

 being limitwise monotonic as part of the input,
 to guarantee uniformity.
 Suppose there were a computable process 
\begin_inset Formula $F$
\end_inset

 that took as input a 
\begin_inset Formula $0'$
\end_inset

-index for an equivalence relation 
\begin_inset Formula $(E,\eqvrel,\{P_{\geq n}\}_{n\in\N})$
\end_inset

 with no infinite classes and with 
\begin_inset Formula $\#E$
\end_inset

 limitwise monotonic,
 and produced as output a computable index for 
\begin_inset Formula $(E,\eqvrel)$
\end_inset

.
 Then,
 using the Recursion Theorem relativized to 
\begin_inset Formula $0'$
\end_inset

,
 we may build an equivalence relation 
\begin_inset Formula $E$
\end_inset

 as follows:
 First,
 look at 
\begin_inset Formula $F(E)$
\end_inset

.
 We may assume WLOG that 
\begin_inset Formula $F(E)$
\end_inset

 is a well-defined index for a relational structure by appealing to 
\begin_inset Formula $0'$
\end_inset

,
 and we may assume that it represents a valid equivalence relation because there is a computable process that takes an index for a relational structure 
\begin_inset Formula $R$
\end_inset

 and outputs an index for an equivalence relation 
\begin_inset Formula $E(R)$
\end_inset

 such that,
 if 
\begin_inset Formula $R$
\end_inset

 was already an equivalence relation then 
\begin_inset Formula $E(R)\cong R$
\end_inset

.
 Now,
 using 
\begin_inset Formula $0'$
\end_inset

,
 ask whether 
\begin_inset Formula $F(E)$
\end_inset

 contains any elements.
 If not,
 set 
\begin_inset Formula $E$
\end_inset

 to consist of one equivalence class of every size.
 If yes,
 pick an element and repeatedly ask:
 Does the equivalence class of this element have size at least 
\begin_inset Formula $n+1$
\end_inset

?
 Whenever the answer is 
\begin_inset Quotes els
\end_inset

yes
\begin_inset Quotes ers
\end_inset

,
 add an equivalence class of size 
\begin_inset Formula $n$
\end_inset

 to 
\begin_inset Formula $E$
\end_inset

.
 If the answer is ever seen to be 
\begin_inset Quotes els
\end_inset

no
\begin_inset Quotes ers
\end_inset

,
 this implies that the equivalence class of this element has size exactly 
\begin_inset Formula $n$
\end_inset

,
 and so we 
\emph on
do not
\emph default
 add an equivalence class of this size,
 but add an equivalence class of every other size.
 It should be clear that this ensures that 
\begin_inset Formula $E$
\end_inset

 is not isomorphic to 
\begin_inset Formula $F(E)$
\end_inset

 despite the fact that 
\begin_inset Formula $E$
\end_inset

 admits no infinite equivalence classes and 
\begin_inset Formula $\#E$
\end_inset

 is either 
\begin_inset Formula $\N$
\end_inset

 or 
\begin_inset Formula $\N$
\end_inset

 minus a point,
 and hence limitwise monotonic.
 This is a contradiction,
 which shows that such a computable 
\begin_inset Formula $F$
\end_inset

 cannot exist.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rmk:cardefinitehard"

\end_inset

The fact that we have handled the 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\#E$
\end_inset

 is finite
\begin_inset Quotes erd
\end_inset

 case separately (and non-uniformly) is unavoidable,
 and here is why.
 We claim that there is no uniform way to turn an index for a 
\begin_inset Formula $0'$
\end_inset

-computable equivalence relation 
\begin_inset Formula $(E,\eqvrel,\{P_{\geq n}\}_{n\in\N})$
\end_inset

,
 even one with no infinite equivalence classes,
 into a computable index for 
\begin_inset Formula $(E,\eqvrel)$
\end_inset

.
 In fact,
 we prove the even stronger fact:
 Any oracle 
\begin_inset Formula $X$
\end_inset

 that is capable of uniformly turning a 
\begin_inset Formula $0'$
\end_inset

-computable equivalence relation 
\begin_inset Formula $(E,\eqvrel,\{P_{\geq n}\}_{n\in\N})$
\end_inset

 with infinitely many singleton classes,
 and either one or two size-two equivalence classes
\begin_inset Foot
status open

\begin_layout Plain Layout
Note that this means 
\begin_inset Formula $\#E=\{1,2\}$
\end_inset

,
 and in particular is uniformly limitwise monotonic.
\end_layout

\end_inset

,
 and no classes of any other size,
 into a computable index for 
\begin_inset Formula $(E,\eqvrel)$
\end_inset

,
 may be used to compute 
\begin_inset Formula $0''$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
Suppose we wish to determine if a computable function 
\begin_inset Formula $f(x)$
\end_inset

 is total.
 First,
 note that we can uniformly (and computably) create an index for a 
\begin_inset Formula $0'$
\end_inset

-computable equivalence relation 
\begin_inset Formula $(E,\eqvrel,\{P_{\geq n}\}_{n\in\N})$
\end_inset

 that is composed entirely of infinitely many singletons and one size-two class,
 unless a value of 
\begin_inset Formula $x$
\end_inset

 is exists for which 
\begin_inset Formula $f(x)\isnotwd$
\end_inset

,
 in which case we add a second equivalence class with two elements.
 Then,
 using the oracle 
\begin_inset Formula $X$
\end_inset

,
 we create a computable index for 
\begin_inset Formula $(E,\eqvrel)$
\end_inset

.
 Computably,
 we can search in 
\begin_inset Formula $E$
\end_inset

 for two distinct pairs of distinct but equivalent elements.
 We will find two if,
 and only if,
 
\begin_inset Formula $f$
\end_inset

 is nontotal.
 This shows that 
\begin_inset Formula $X$
\end_inset

 enumerates the set of nontotal indices,
 which straightforwardly implies 
\begin_inset Formula $X\geq0'$
\end_inset

.
 Thus,
 instead of computably searching in 
\begin_inset Formula $E$
\end_inset

 for two pairs of distinct elements,
 
\begin_inset Formula $X$
\end_inset

 can check in finite time if such a elements exist,
 and thus determine whether 
\begin_inset Formula $f$
\end_inset

 is total.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rmk:cardefinitewhy"

\end_inset

A way to understand what makes equivalence classes with finite characteristic set so computationally hard to handle is the following intuition:
 A computable copy of 
\begin_inset Formula $(E,\eqvrel)$
\end_inset

 contains more descriptive power,
 from the perspective of 
\begin_inset Formula $0'$
\end_inset

,
 than a 
\begin_inset Formula $0'$
\end_inset

-computable copy of 
\begin_inset Formula $(E,\eqvrel,\{P_{\geq n}\}_{n\in\N})$
\end_inset

.
 In other words,
 there is computational content that 
\begin_inset Formula $0'$
\end_inset

 can read off from a computable copy of 
\begin_inset Formula $(E,\eqvrel)$
\end_inset

 that it could not read off from a 
\begin_inset Formula $0'$
\end_inset

-computable copy of 
\begin_inset Formula $(E,\eqvrel,\{P_{\geq n}\}_{n})$
\end_inset

,
 and an example of such content is the answer to the questions:
 
\begin_inset Quotes eld
\end_inset

Is there an equivalence relation in 
\begin_inset Formula $E$
\end_inset

 of size greater than or equal to 
\begin_inset Formula $n$
\end_inset

?
\begin_inset Quotes erd
\end_inset

 or,
 more generally,
 
\begin_inset Quotes eld
\end_inset

Are there at least 
\begin_inset Formula $k$
\end_inset

 equivalence relations in 
\begin_inset Formula $E$
\end_inset

 of size 
\begin_inset Formula $\geq n$
\end_inset

?
\begin_inset Quotes erd
\end_inset

 As such,
 knowledge of the answer to these questions is a necessary condition to be able to turn a 
\begin_inset Formula $0'$
\end_inset

-computable copy of 
\begin_inset Formula $E$
\end_inset

 into a computable copy thereof,
 because the answer to these questions 
\emph on
can
\emph default
 be computed using 
\begin_inset Formula $0'$
\end_inset

 from the computable copy.
 This explains what makes the case with infinitely many equivalence relations,
 or with arbitrarily large finite equivalence classes,
 computationally easy to handle:
 The answer to these questions is always 
\begin_inset Quotes els
\end_inset

yes
\begin_inset Quotes ers
\end_inset

.
 Moreover,
 the answer to these questions is always simple enough that it can be encoded in finitely many bits of information,
 and hence could be non-uniformly hardcoded into an algorithm to obtain a computable copy of 
\begin_inset Formula $(E,\eqvrel)$
\end_inset

,
 but the fact that this cannot be done uniformly explains why 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:eqvfin"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 cannot be made uniform as it is.
\end_layout

\begin_layout Subsection
Khisamiev's Theorem
\end_layout

\begin_layout Standard
The following theorem is in the literature.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
put a reference
\end_layout

\end_inset

 We obtain it as a corollary of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
 It was the main motivator for the definition of 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed structure.
\end_layout

\begin_layout Standard
In the following,
 we interpret a c.e.
\begin_inset space \space{}
\end_inset

presentation of a group as being a description of the group as a list of generators and relations,
 such that there is a computer program that enumerates the list of generators and relations.
 In the present case,
 this is equivalent to the more general notion of c.e.
\begin_inset space \space{}
\end_inset

presentation of a structure in computability theory.
\end_layout

\begin_layout Theorem
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Khisamiev
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "thm:khisamiev"

\end_inset

Every c.e.
\begin_inset space \space{}
\end_inset

presented torsion-free abelian group is isomorphic to a computable group.
 Furthermore,
 if the group is non-trivial,
 then this computable copy can be built uniformly in the index of the c.e.
\begin_inset space \space{}
\end_inset

presentation.
\end_layout

\begin_layout Proof
Given a c.e.
\begin_inset space \space{}
\end_inset

presentation of a group 
\begin_inset Formula $G$
\end_inset

,
 we first build a 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed copy of 
\begin_inset Formula $G$
\end_inset

 over an appropriate signature 
\begin_inset Formula $\Lang'$
\end_inset

,
 and we will then show that any nontrivial torsion-free abelian group has the QETP (uniformly) over 
\begin_inset Formula $\Lang\subseteq\Lang'$
\end_inset

,
 where 
\begin_inset Formula $\Lang$
\end_inset

 is the signature containing only the ternary predicate 
\begin_inset Formula $S(x,y,z)\equiv\text{``\ensuremath{x+y=z}''}$
\end_inset

(and its negation,
 and equality and its negation).
\end_layout

\begin_layout Proof
The signature 
\begin_inset Formula $\Lang'$
\end_inset

 shall contain 
\begin_inset Formula $\Lang$
\end_inset

,
 plus:
\end_layout

\begin_deeper
\begin_layout Itemize
The countably many predicates 
\begin_inset Formula $Q_{n,\vec{c}}(\vec{x})$
\end_inset

,
 parametrized over 
\begin_inset Formula $n\in\N$
\end_inset

 and finite tuples 
\begin_inset Formula $c_{1},\dots,c_{k}\in\Z$
\end_inset

:
\begin_inset Formula 
\[
Q_{n,\vec{c}}(\vec{x})\equiv\text{``\ensuremath{n\mid c_{1}x_{1}+\dots+c_{k}x_{k}}''}.
\]

\end_inset

Note that we allow 
\begin_inset Formula $n$
\end_inset

 to equal zero,
 in which case (since 
\begin_inset Formula $0\mid y$
\end_inset

 iff 
\begin_inset Formula $y=0$
\end_inset

) 
\begin_inset Formula $Q_{0,\vec{c}}(\vec{x})$
\end_inset

 corresponds to the predicate 
\begin_inset Formula $\vec{c}\cdot\vec{x}=0$
\end_inset

.
\end_layout

\begin_layout Itemize
The countably many predicates 
\begin_inset Formula $\neg Q_{0,\vec{c}}(\vec{x})$
\end_inset

,
 parametrized over finite tuples 
\begin_inset Formula $c_{1},\dots,c_{k}\in\Z$
\end_inset

:
\begin_inset Formula 
\[
\neg Q_{0,\vec{c}}(\vec{x})\equiv\text{``\ensuremath{c_{1}x_{1}+\dots+c_{k}x_{k}\neq0}''}.
\]

\end_inset


\end_layout

\begin_layout Itemize
Countably many predicates 
\begin_inset Formula $\{n\Delta(x)\}_{n\in\Z}$
\end_inset

,
 whose meaning is as follows:
 We will carefully pick a single designated nonzero element of 
\begin_inset Formula $G$
\end_inset

,
 which we refer to as 
\begin_inset Formula $\delta$
\end_inset

,
 and 
\begin_inset Formula $n\Delta(x)$
\end_inset

 should be interpreted as 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $x=n\delta$
\end_inset


\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_deeper
\begin_layout Proof
We shall require some linear algebra of 
\begin_inset Formula $\Z$
\end_inset

-modules to show that,
 from a c.e.
\begin_inset space \space{}
\end_inset

presentation of 
\begin_inset Formula $G$
\end_inset

,
 we can uniformly obtain a 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed copy of 
\begin_inset Formula $G$
\end_inset

.
 Then,
 we will explain how we choose the element of 
\begin_inset Formula $G$
\end_inset

 that will be tagged with 
\begin_inset Formula $\Delta$
\end_inset

.
 To obtain the 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed copy of 
\begin_inset Formula $G$
\end_inset

,
 here is the basic idea:
 Consider the computable process that outputs all possible linear combinations of generators.
 We want to,
 with each new linear combination of generators,
 say 
\begin_inset Formula $d$
\end_inset

,
 first check if it is not equal to any of the combinations previously produced (this is an easy check with 
\begin_inset Formula $0'$
\end_inset

),
 and if it is not,
 we want to output a c.e.
\begin_inset space \space{}
\end_inset

index for its type relative to the elements previously output.
 This is easy for the positive predicates – to check if,
 for example,
 
\begin_inset Formula $5\mid4d+6c$
\end_inset

 (where 
\begin_inset Formula $c$
\end_inset

 is a previously output combination of generators),
 it suffices to check if there is a further combination of generators 
\begin_inset Formula $u$
\end_inset

 that satisfies the relation 
\begin_inset Formula $5u-4d-6c=0$
\end_inset

.
 This is a c.e.
\begin_inset space \space{}
\end_inset

check.
 The difficulty lies in the negative predicates,
 of which 
\begin_inset Formula $\neg Q_{0,\vec{c}}(\vec{x})$
\end_inset

 is the general case.
 In other words,
 we need to encode 
\emph on
into a single c.e.
\begin_inset space \space{}
\end_inset

index
\emph default
 the full information about what linear combinations of elements-output-thus-far equal zero.
\end_layout

\begin_layout Proof
Here is a fact from commutative algebra,
 whose proof can be found in any standard book that covers modules over principal ideal domains (e.g.
\begin_inset space \space{}
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "dummit_foote"
literal "false"

\end_inset

):
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

label={Fact 
\backslash
Alph*}
\end_layout

\end_inset


\end_layout

\end_inset

Any submodule 
\begin_inset Formula $M$
\end_inset

 of 
\begin_inset Formula $\Z^{k}$
\end_inset

 admits a finite basis.
\end_layout

\begin_layout Standard
We will need an effective version of this fact.
 A stepping stone,
 which we will not directly use but displays the main idea,
 is the following:
\end_layout

\begin_layout Enumerate-Resume
\begin_inset CommandInset label
LatexCommand label
name "enu:gauss"

\end_inset

Given a finite set 
\begin_inset Formula $X\subseteq\Z^{k}$
\end_inset

,
 we can effectively find a basis for the submodule of 
\begin_inset Formula $\Z^{k}$
\end_inset

 generated by 
\begin_inset Formula $X$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
Proof idea:
 A slight modification of the usual Gaussian elimination algorithm,
 applied to the matrix whose rows are the elements of 
\begin_inset Formula $X$
\end_inset

.
 To zero out entries below a pivot,
 instead of dividing to turn the pivot element into 
\begin_inset Formula $1$
\end_inset

,
 use the Euclidean algorithm to turn the pivot into the GCD of itself with all elements beneath it,
 whereupon all elements beneath it may be zeroed out.
\end_layout

\end_deeper
\begin_layout Standard
Now we are ready to state and prove the version we will use:
\end_layout

\begin_layout Enumerate-Resume
\begin_inset CommandInset label
LatexCommand label
name "enu:cemodulebasis"

\end_inset

Given a c.e.
\begin_inset space \space{}
\end_inset

index for a submodule 
\begin_inset Formula $M$
\end_inset

 of 
\begin_inset Formula $\Z^{k}$
\end_inset

,
 we may 
\begin_inset Formula $0'$
\end_inset

-effectively find a basis of 
\begin_inset Formula $M$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
Proof idea:
 Consider the 
\begin_inset Formula $k$
\end_inset

-width and possibly-infinite-height matrix whose rows are the elements of 
\begin_inset Formula $M$
\end_inset

.
 Use 
\begin_inset Formula $0'$
\end_inset

 to find the GCD of the elements of the first column,
 call it 
\begin_inset Formula $d$
\end_inset

.
 If 
\begin_inset Formula $d=0$
\end_inset

 (i.e.
\begin_inset space \space{}
\end_inset

all elements of the first column are zero),
 skip to the next step.
 If 
\begin_inset Formula $d\neq0$
\end_inset

,
 find a combination of rows of 
\begin_inset Formula $M$
\end_inset

 that has 
\begin_inset Formula $d$
\end_inset

 in its first coordinate,
 and add this combination to the basis.
 Then,
 if 
\begin_inset Formula $k\geq1$
\end_inset

,
 recursively apply this algorithm to the 
\begin_inset Formula $(k-1)$
\end_inset

-width and possibly-infinite-height matrix whose elements consist of the rows of the previous matrix that have a 
\begin_inset Formula $0$
\end_inset

 as a first entry.
 Upon finding a combination of rows that has the new GCD as its first coordinates,
 add the corresponding combination of the rows of the original matrix to the basis.
 After 
\begin_inset Formula $k$
\end_inset

 steps,
 one shall have a basis of 
\begin_inset Formula $M$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
Returning to our original problem:
 We have a collection of combinations of generators,
 say 
\begin_inset Formula $d_{0}$
\end_inset

,
 
\begin_inset Formula $d_{1}$
\end_inset

,
 
\begin_inset Formula $\dots$
\end_inset

,
 
\begin_inset Formula $d_{k}$
\end_inset

,
 and we wish to encode all possible linear combinations of these elements that yield zero.
 We do this by applying 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:cemodulebasis"

\end_inset

 to the c.e.
\begin_inset space \space{}
\end_inset

submodule of 
\begin_inset Formula $\Z^{k+1}$
\end_inset

 given by
\begin_inset Formula 
\[
M=\{\,\vec{c}\in\Z^{k+1}\mid\vec{c}\cdot\vec{d}=0\,\}.
\]

\end_inset

With access to a basis of 
\begin_inset Formula $M$
\end_inset

,
 say 
\begin_inset Formula $b_{1},\dots,b_{\ell}$
\end_inset

 (encoded into the columns of a matrix 
\begin_inset Formula $B$
\end_inset

),
 we can tell whether any set of coefficients 
\begin_inset Formula $\vec{c}$
\end_inset

 is in 
\begin_inset Formula $M$
\end_inset

 (and hence,
 whether we should say yes or no to 
\begin_inset Formula $Q_{0,\vec{c}}(\vec{d})$
\end_inset

) by using standard algorithms to solve the linear equation 
\begin_inset Formula $B\vec{x}=\vec{c}$
\end_inset

 over 
\begin_inset Formula $\Q$
\end_inset

,
 and conclude 
\begin_inset Formula $\vec{c}\in M$
\end_inset

 if and only if a solution exists and its coefficients are all integers.
 By hardcoding this basis into a c.e.
\begin_inset space \space{}
\end_inset

index,
 we can therefore obtain a c.e.
\begin_inset space \space{}
\end_inset

index for the atomic 
\begin_inset Formula $\Lang'$
\end_inset

-type of a tuple 
\begin_inset Formula $\vec{d}$
\end_inset

 of linear combinations of generators.
\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
Now,
 let us explain how to choose the element 
\begin_inset Formula $\delta$
\end_inset

,
 which we shall use to decide the predicates 
\begin_inset Formula $n\Delta$
\end_inset

.
 Of course,
 this has to have been done in advance,
 so that we can hardcode the combination of generators corresponding to 
\begin_inset Formula $\delta$
\end_inset

 into the c.e.
\begin_inset space \space{}
\end_inset

indices of the types of the elements of 
\begin_inset Formula $G$
\end_inset

 in advance.
\end_layout

\begin_layout Standard
There is an easy way and a hard way to choose 
\begin_inset Formula $\delta$
\end_inset

.
 The easy way is simply to pick an arbitrary nonzero element of 
\begin_inset Formula $G$
\end_inset

.
 The issue is that to make this choice requires the usage of an oracle for 
\begin_inset Formula $0'$
\end_inset

,
 which will lead to a non-uniform presentation.
 Nevertheless,
 if one is not interested in uniformity,
 one may move on and ignore the difficult but uniform way to choose the element that we will now propose.
\end_layout

\begin_layout Standard
Consider the following schema:
 Let 
\begin_inset Formula $\{C_{i}\}_{i\in\N}$
\end_inset

 enumerate all possible combinations of generators.
 To start,
 we will guess 
\begin_inset Formula $\delta=C_{0}$
\end_inset

,
 and look through the relations until (if ever) we see enough relations to conclude 
\begin_inset Formula $C_{0}=0$
\end_inset

.
 When this happens,
 we will guess 
\begin_inset Formula $\delta=N_{1}C_{1}$
\end_inset

,
 where 
\begin_inset Formula $N_{1}$
\end_inset

 is a nonzero number divisible by enough integers.
 This choice is made so that,
 for every number 
\begin_inset Formula $k$
\end_inset

 for which we'd been able to conclude 
\begin_inset Formula $k\mid C_{0}$
\end_inset

 before we found that 
\begin_inset Formula $C_{0}=0$
\end_inset

,
 we have 
\begin_inset Formula $k\mid N_{1}$
\end_inset

 and so 
\begin_inset Formula $k\mid N_{1}C_{1}$
\end_inset

.
 We proceed in this manner,
 enumerating relations until we are able to conclude that 
\begin_inset Formula $N_{1}C_{1}=0$
\end_inset

,
 or equivalently that 
\begin_inset Formula $C_{1}=0$
\end_inset

.
 If this happens,
 we change our mind to guess 
\begin_inset Formula $\delta=N_{2}C_{2}$
\end_inset

,
 where 
\begin_inset Formula $N_{2}$
\end_inset

 has enough divisibilities that,
 again,
 every divisibility we'd already concluded about 
\begin_inset Formula $N_{1}C_{1}$
\end_inset

 also holds for 
\begin_inset Formula $N_{2}$
\end_inset

 and hence 
\begin_inset Formula $N_{2}C_{2}$
\end_inset

.
 Since,
 by assumption,
 
\begin_inset Formula $G$
\end_inset

 is a nontrivial group,
 eventually this procedure will run into a nonzero combination of generators,
 and 
\begin_inset Formula $0'$
\end_inset

 is able to figure out which element is 
\begin_inset Formula $\delta$
\end_inset

 in advance.
\end_layout

\begin_layout Standard
The reader may be wondering in what respect this procedure is more uniform.
 After all,
 the limiting combination of generators 
\begin_inset Formula $N_{M}C_{M}$
\end_inset

 cannot be computed uniformly,
 only 
\begin_inset Formula $0'$
\end_inset

-uniformly.
 However,
 and crucially,
 we can uniformly compute a c.e.
\begin_inset space \space{}
\end_inset

index for the type of the limiting combination of generators 
\begin_inset Formula $\delta$
\end_inset

 as follows:
 follow along the procedure used to find 
\begin_inset Formula $\delta$
\end_inset

,
 and every time we conclude a new divisibility for (the current guess for) 
\begin_inset Formula $\delta$
\end_inset

,
 we add this divisibility to its type.
 We took care so that any divisibility we add never needs to be removed.
 The predicates 
\begin_inset Formula $\neg Q_{0,c}(x)$
\end_inset

 are all true except for 
\begin_inset Formula $\neg Q_{0,0}(x)$
\end_inset

 because the group is torsion-free,
 and thus,
 adding those to the type,
 we obtain an enumeration of the type of 
\begin_inset Formula $\delta$
\end_inset

.
\end_layout

\begin_layout Standard
Below,
 we shall be using the type of 
\begin_inset Formula $\delta$
\end_inset

 in an essential way (namely,
 to compute 
\begin_inset Formula $\etau$
\end_inset

),
 which is why having a uniform way to compute this type is essential.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset

Now that we have a 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed copy of our group over the signature 
\begin_inset Formula $\Lang'$
\end_inset

,
 we shall show that every nontrivial torsion-free abelian group with a designated nonzero element with c.e.
\begin_inset space \space{}
\end_inset

atomic type satisfies the QETP.
\end_layout

\begin_layout Itemize
First,
 we construct 
\begin_inset Formula $\chi_{q}$
\end_inset

.
 This is an adaptation of the standard proof that the theory of torsion-free abelian groups with divisibility-by-integer predicates admits quantifier elimination,
 which can be found e.g.
\begin_inset space \space{}
\end_inset

in 
\begin_inset Note Note
status open

\begin_layout Plain Layout
cite hodges
\end_layout

\end_inset

.
 Very briefly:
\end_layout

\begin_deeper
\begin_layout Itemize
Assume without loss of generality that 
\begin_inset Formula $q(\vec{x},\vec{y})$
\end_inset

 is a disjunction of atomic formulas,
 and hence can be expressed as a system of integer coefficient equations and inequations
\begin_inset Formula 
\[
q(\vec{x},\vec{y})\equiv\left\{ \begin{array}{l}
M\vec{x}=N\vec{y},\\
K\vec{x}\neq L\vec{y}.
\end{array}\right.
\]

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Important:

\series default
 The notation 
\begin_inset Formula $K\vec{x}\neq L\vec{y}$
\end_inset

 is 
\emph on
not
\emph default
 being used two mean 
\begin_inset Quotes eld
\end_inset

the vectors 
\begin_inset Formula $K\vec{x}$
\end_inset

 and 
\begin_inset Formula $L\vec{y}$
\end_inset


\begin_inset Quotes erd
\end_inset

 are distinct,
 but rather the stronger fact:
 
\begin_inset Quotes eld
\end_inset

every entry of the vector 
\begin_inset Formula $K\vec{x}$
\end_inset

 is distinct from the corresponding entry in 
\begin_inset Formula $L\vec{y}$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 This means that one must not be careless in handling these inequalities – one cannot,
 for example,
 apply any kind of Gaussian elimination thereto.
\end_layout

\end_deeper
\begin_layout Itemize
Now,
 write 
\begin_inset Formula $N=ADB$
\end_inset

,
 where 
\begin_inset Formula $D$
\end_inset

 is diagonal and 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 are invertible,
 all over the integers – the fact that this can always be done can be obtained using a strategy like the one from 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:gauss"

\end_inset

,
 and a reference is 
\begin_inset Note Note
status open

\begin_layout Plain Layout
cite the guy that hodges cites
\end_layout

\end_inset

.
 Then,
 
\begin_inset Formula $q(\vec{x},\vec{y})$
\end_inset

 is logically equivalent to a new system of equations and inequations
\begin_inset Formula 
\[
q(\vec{x},\vec{y})\Leftrightarrow\left\{ \begin{array}{l}
M'\vec{x}=DB\vec{y},\\
K'\vec{x}\neq LB^{-1}B\vec{y}.
\end{array}\right.
\]

\end_inset


\end_layout

\begin_layout Itemize
The existence of a solution to this system is,
 since 
\begin_inset Formula $B$
\end_inset

 is invertible,
 equivalent to the existence of a solution to the following other system
\begin_inset Formula 
\[
\exists_{\vec{y}}q(\vec{x},\vec{y})\Leftrightarrow\exists_{\vec{z}}\left\{ \begin{array}{l}
M'\vec{x}=D\vec{z},\\
K'\vec{x}\neq L'\vec{z}.
\end{array}\right.
\]

\end_inset


\end_layout

\begin_layout Itemize
The rows of the equation 
\begin_inset Formula $M'\vec{x}=D\vec{z}$
\end_inset

 that correspond to nonzero entries of 
\begin_inset Formula $D$
\end_inset

 yield equations of the type 
\begin_inset Formula $nz_{i}=\vec{a}\cdot\vec{x}$
\end_inset

.
 This allows us to remove (whilst preserving logical equivalence) every instance of 
\begin_inset Formula $z_{i}$
\end_inset

 from every other (in)equation:
 Any other (in)equation can be multiplied by 
\begin_inset Formula $n$
\end_inset

 preserving logical equivalence (this uses 
\begin_inset Formula $n\neq0$
\end_inset

 and the fact that we're working with torsion-free groups),
 resulting in an instance of 
\begin_inset Formula $\text{(coefficient)\ensuremath{\times}}nz_{i}$
\end_inset

,
 which can be substituted for 
\begin_inset Formula $\text{(coefficient)}\times(\sum a_{i}x_{i})$
\end_inset

.
 Thus,
 we may eliminate all 
\begin_inset Formula $z$
\end_inset

 variables corresponding to nonzero rows of 
\begin_inset Formula $D$
\end_inset

,
 and our system now becomes
\begin_inset Formula 
\[
\exists_{\vec{y}}q(\vec{x},\vec{y})\Leftrightarrow\exists_{\vec{z}}\exists_{\vec{w}}\left\{ \begin{array}{l}
M_{0}\vec{x}=0,\\
n_{1}z_{1}=\vec{c}_{1}\cdot\vec{x},\\
\vdots\\
n_{\ell}z_{\ell}=\vec{c}_{\ell}\cdot\vec{x},\\
K'\vec{x}\neq L'\vec{w}.
\end{array}\right.
\]

\end_inset


\end_layout

\begin_layout Itemize
The equations including the 
\begin_inset Formula $z$
\end_inset

 variables become divisibility statements,
 i.e.
\begin_inset space \space{}
\end_inset


\begin_inset Formula $\exists_{z_{i}}nz_{i}=\vec{c}\cdot\vec{x}\Leftrightarrow n\mid\vec{c}\cdot\vec{x}\equiv Q_{n,\vec{c}}(\vec{x})$
\end_inset

,
 so we now need only deal with the inequations 
\begin_inset Formula $K'\vec{x}\neq L'\vec{w}$
\end_inset

.
\end_layout

\begin_layout Itemize
Now,
 let us stratify the equations 
\begin_inset Formula $K'\vec{x}\neq L'\vec{w}$
\end_inset

 as follows:
 First,
 consider the equations that use no 
\begin_inset Formula $w$
\end_inset

-variable.
 Then,
 consider the ones that use 
\begin_inset Formula $w_{1}$
\end_inset

 and no other.
 Then,
 consider the ones that use only 
\begin_inset Formula $w_{1}$
\end_inset

 and 
\begin_inset Formula $w_{2}$
\end_inset

,
 and so on.
 The equations that use no 
\begin_inset Formula $w$
\end_inset

-variable are important – keep them.
 These are are a requirement on 
\begin_inset Formula $\vec{x}$
\end_inset

 that we cannot get rid of.
 Let us refer to these equations as 
\begin_inset Formula $K_{0}\vec{x}\neq0$
\end_inset

.
 On the other hand,
 at every new stage of the strata,
 the resulting equations will doubtlessly be satisfied by some 
\begin_inset Formula $w_{i}$
\end_inset

.
 For example,
 if the first stratum has 
\begin_inset Formula $e$
\end_inset

 equations,
 this is forbidding at most 
\begin_inset Formula $e$
\end_inset

 possible values of 
\begin_inset Formula $w_{1}$
\end_inset

.
 But the group is nontrivial and hence infinite,
 whereby there is at least one valid choice for 
\begin_inset Formula $w_{1}$
\end_inset

.
 Then,
 in the next strata,
 contingent on this choice of 
\begin_inset Formula $w_{1}$
\end_inset

,
 there are once again at most (number of equations) forbidden values for 
\begin_inset Formula $w_{2}$
\end_inset

.
 Simply choose 
\begin_inset Formula $w_{2}$
\end_inset

 to not be one of those.
 Continuing in this manner,
 we see that we can ensure that all equations that include a 
\begin_inset Formula $w$
\end_inset

 variable can be automatically satisfied and are therefore adding no information.
\end_layout

\begin_layout Itemize
In conclusion,
 we've shown that any existential statement is equivalent to a system of the type
\begin_inset Formula 
\begin{equation}
\exists_{\vec{y}}q(\vec{x},\vec{y})\Leftrightarrow\left\{ \begin{array}{l}
M_{0}\vec{x}=0,\\
n_{1}\mid\vec{c}_{1}\cdot\vec{x},\\
\vdots\\
n_{\ell}\mid\vec{c}_{\ell}\cdot\vec{x},\\
K_{0}\vec{x}\neq0,
\end{array}\right.\label{eq:syseqchi}
\end{equation}

\end_inset

with the system found effectively,
 and thus it is in this manner that we define 
\begin_inset Formula $\chi_{q}(\vec{x})$
\end_inset

.
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $q$
\end_inset

 were not a disjunction of atomic formulas,
 as initially assumed,
 write it in conjunctive normal form as 
\begin_inset Formula $q\equiv q_{1}\lor\dots\lor q_{k}$
\end_inset

 and set 
\begin_inset Formula $\chi_{q}\equiv\chi_{q_{1}}\lor\dots\lor\chi_{q_{k}}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
Next,
 we construct 
\begin_inset Formula $\tau$
\end_inset

.
 Intuitively,
 given 
\begin_inset Formula $q(\vec{x},y,\vec{z})$
\end_inset

,
 we consider all possible assignments of 
\begin_inset Formula $y$
\end_inset

 of the form 
\begin_inset Formula $y=\frac{1}{a}\vec{c}\cdot\vec{x}$
\end_inset

 (if such an element exists).
 We will prove below,
 when establishing the QETP,
 that assuming not every element of 
\begin_inset Formula $\vec{x}$
\end_inset

 is null there is such a combination that satisfies 
\begin_inset Formula $\chi_{q}(\vec{x},\frac{1}{a}\vec{c}\cdot\vec{x})$
\end_inset

.
 We will choose one such combination,
 and set 
\begin_inset Formula $\tau_{q\varphi}(\vec{x},y)\equiv(ay=\vec{c}\cdot\vec{x}$
\end_inset

).
 We also need to handle the case where every element of the tuple 
\begin_inset Formula $\vec{x}$
\end_inset

 is zero (which will generally happen if the tuple is empty,
 or if it contains a single element that happens to be zero),
 which is why we have the designated element 
\begin_inset Formula $\delta$
\end_inset

 – if every element of 
\begin_inset Formula $\vec{x}$
\end_inset

 is null,
 we set 
\begin_inset Formula $\tau(\vec{x},y)\equiv N\Delta(y)$
\end_inset

 where 
\begin_inset Formula $N$
\end_inset

 is large enough to encompass all divisibilities demanded by the tuple of elements 
\begin_inset Formula $\vec{z}$
\end_inset

 (e.g.
\begin_inset space \space{}
\end_inset

if 
\begin_inset Formula $q(y,z)\equiv(z+z=y)$
\end_inset

,
 we would set 
\begin_inset Formula $y=2\delta$
\end_inset

).
\end_layout

\begin_deeper
\begin_layout Standard
Let's discuss this process more formally.
 Given 
\begin_inset Formula $q(\vec{x},y,\vec{z})$
\end_inset

:
\end_layout

\begin_layout Itemize
Set 
\begin_inset Formula $\varphi_{0}(\vec{x})\equiv\land_{i}(x_{i}=0)$
\end_inset

 (or,
 if we are being unnecessarily precise,
 
\begin_inset Formula $\varphi_{0}(\vec{x})\equiv\land_{i}Q_{0,1}(x_{i})$
\end_inset

),
 and set 
\begin_inset Formula $\tau_{q\varphi_{0}}(\vec{x},y)\equiv\varphi_{0}(\vec{x})\land N\Delta(y)$
\end_inset

,
 where 
\begin_inset Formula $N$
\end_inset

 is large enough to ensure 
\begin_inset Formula $\forall_{d}\chi_{q}(\vec{0},Nd)$
\end_inset

.
\end_layout

\begin_layout Itemize
For every nonzero integer 
\begin_inset Formula $a$
\end_inset

 and tuple of integers 
\begin_inset Formula $\vec{c}$
\end_inset

,
 set 
\begin_inset Formula $\varphi_{a\vec{c}}(\vec{x})\equiv\text{``\ensuremath{\chi_{q}(\vec{x},\frac{1}{a}\vec{c}\cdot\vec{x})}''}$
\end_inset

 and 
\begin_inset Formula $\tau_{q\varphi_{a\vec{c}}}(\vec{x},y)\equiv(ay=\vec{c}\cdot\vec{x})$
\end_inset

.
 It remains to explain what we mean by 
\begin_inset Formula $\chi_{q}(\vec{x},\frac{1}{a}\vec{c}\cdot\vec{x})$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
Since 
\begin_inset Formula $q$
\end_inset

 is assumed to be a type,
 we have by definition that 
\begin_inset Formula $\chi_{q}(\vec{x},y)$
\end_inset

 is a system of equations as in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:syseqchi"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
 By multiplying all equations by 
\begin_inset Formula $a$
\end_inset

,
 we obtain an equivalent system of equations where every instance of 
\begin_inset Formula $y$
\end_inset

 is being multiplied by 
\begin_inset Formula $a$
\end_inset

.
 In other words,
 we can rewrite 
\begin_inset Formula $\chi_{q}(\vec{x},y)\Leftrightarrow\psi(\vec{x},ay)$
\end_inset

,
 and thus the formula 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\chi_{q}(\vec{x},\frac{1}{a}\vec{c}\cdot\vec{x})$
\end_inset


\begin_inset Quotes erd
\end_inset

 may be taken to mean
\begin_inset Formula 
\[
\text{``\ensuremath{\chi_{q}(\vec{x},\frac{1}{a}\vec{c}\cdot\vec{x})}''}\equiv(a\mid\vec{c}\cdot\vec{x})\land\psi(\vec{x},\vec{c}\cdot\vec{x}).
\]

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Finally,
 we construct 
\begin_inset Formula $\etau$
\end_inset

.
 Given 
\begin_inset Formula $q(\vec{x},y,\vec{z})$
\end_inset

 and 
\begin_inset Formula $\varphi(\vec{x})$
\end_inset

 as one of the above cases,
 as well as 
\begin_inset Formula $Q(\vec{x},y,\vec{z},\vec{w})$
\end_inset

 extending 
\begin_inset Formula $q$
\end_inset

,
 we wish to find a quantifier-free expression that is equivalent to 
\begin_inset Formula $\exists_{y}\left[\chi_{Q}(\vec{x},y)\land\tau_{q\varphi}(\vec{x},y)\right]$
\end_inset

.
 Intuitively,
 the idea is that in either case our formula 
\begin_inset Formula $\tau$
\end_inset

 determines 
\begin_inset Formula $y$
\end_inset

 exactly (as a function of 
\begin_inset Formula $\vec{x}$
\end_inset

),
 so we can just 
\begin_inset Quotes eld
\end_inset

plug that 
\begin_inset Formula $y$
\end_inset

 into 
\begin_inset Formula $\chi_{Q}(\vec{x},y)$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 To do this more precisely,
 we split into cases:
\end_layout

\begin_deeper
\begin_layout Itemize
If 
\begin_inset Formula $\tau_{q\varphi}(\vec{x},y)\equiv(ay=\vec{c}\cdot\vec{x})$
\end_inset

,
 we apply the same 
\begin_inset Quotes eld
\end_inset

multiply every equation by 
\begin_inset Formula $a$
\end_inset


\begin_inset Quotes erd
\end_inset

 trick to write a formula that corresponds to 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\left(a\mid\vec{c}\cdot\vec{x}\right)\land\chi_{Q}(\vec{x},\frac{1}{a}\vec{c}\cdot\vec{x})$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 The resulting formula is the desired 
\begin_inset Formula $\etau$
\end_inset

.
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $\tau_{q\varphi}(\vec{x},y)\equiv\varphi_{0}(\vec{x})\land N\Delta(y)$
\end_inset

,
 then,
 intuitively,
 we know for a tuple satisfying 
\begin_inset Formula $\tau$
\end_inset

 we have that all 
\begin_inset Formula $x_{i}$
\end_inset

 are zero,
 and that 
\begin_inset Formula $y=N\delta$
\end_inset

.
 Thus,
 the existential quantifier may be eliminated,
 and we wish to determine whether 
\begin_inset Formula $\chi_{Q}(\vec{0},N\delta)$
\end_inset

.
 This is where it is important that we have a c.e.
\begin_inset space \space{}
\end_inset

index for the type of 
\begin_inset Formula $\delta$
\end_inset

 – and,
 if we desire a uniform result,
 that we have this index without recourse to any oracle.
 Knowing the c.e.
\begin_inset space \space{}
\end_inset

index for the type of 
\begin_inset Formula $\delta$
\end_inset

,
 we can just consult whether 
\begin_inset Formula $\chi_{Q}(\vec{0},N\delta)$
\end_inset

 holds – more precisely,
 there is a computable sequence 
\begin_inset Formula $\{B_{n}\}_{n\in\N}$
\end_inset

 such that
\begin_inset Formula 
\[
\left\{ \begin{aligned} & G\nvDash\chi_{Q}(\vec{0},N\delta) & \Rightarrow & B_{n}=\bot\text{ for all \ensuremath{n},}\\
 & G\vDash\chi_{Q}(\vec{0},N\delta) & \Rightarrow & B_{n}=\top\text{ for all but finitely many \ensuremath{n}.}
\end{aligned}
\right.
\]

\end_inset

Thus,
 in this scenario,
 we set 
\begin_inset Formula 
\[
\etau_{q\varphi Q}(\vec{x})\equiv\llor_{n}B_{n}.
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Now we verify that the above definitions are witnesses to the QETP.
\end_layout

\begin_layout Enumerate
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

label=(
\backslash
alph*)
\end_layout

\end_inset


\end_layout

\end_inset

(
\begin_inset Formula $\Lang$
\end_inset

 is finite and closed under negation) Obvious.
\end_layout

\begin_layout Enumerate
(
\begin_inset Formula $G\vDash\chi_{q}(\vec{x})\leftrightarrow\exists_{\vec{y}}q(\vec{x},\vec{y})$
\end_inset

) By construction.
\end_layout

\begin_layout Enumerate
There are two bullet points here.
 In reverse order:
\end_layout

\begin_deeper
\begin_layout Itemize
(
\begin_inset Formula $G\vDash\chi_{q}(\vec{x})\land\varphi(\vec{x})\rightarrow\exists_{y}\tau_{q\varphi}(\vec{x},y)$
\end_inset

) Direct from construction.
\end_layout

\begin_layout Itemize
(Every tuple 
\begin_inset Formula $\vec{b}$
\end_inset

 of elements of 
\begin_inset Formula $G$
\end_inset

 that satisfies 
\begin_inset Formula $\chi_{q}(\vec{b})$
\end_inset

 satisfies some 
\begin_inset Formula $\varphi(\vec{b})$
\end_inset

 with 
\begin_inset Formula $(q,\varphi)$
\end_inset

 in domain of 
\begin_inset Formula $\tau$
\end_inset

)
\end_layout

\begin_deeper
\begin_layout Itemize
If 
\begin_inset Formula $\vec{b}=\vec{0}$
\end_inset

 this is obvious.
\end_layout

\begin_layout Itemize
If some 
\series bold

\begin_inset Formula $b_{i}\neq0$
\end_inset


\series default
:
 We wish to show that there are 
\begin_inset Formula $a\in\Z_{\neq0}$
\end_inset

 and 
\begin_inset Formula $\vec{c}\subseteq\Z$
\end_inset

 such that 
\begin_inset Formula $a\mid\vec{c}\cdot\vec{b}$
\end_inset

 and 
\begin_inset Formula $\chi_{q}(\vec{b},\frac{1}{a}\vec{c}\cdot\vec{b})$
\end_inset

.
 To this effect,
 we prove the following related lemma,
 which obviously implies the desired claim:
\end_layout

\begin_deeper
\begin_layout Lemma
If 
\begin_inset Formula $q(\vec{x},\vec{y})$
\end_inset

 is a quantifier-free type in the smaller language 
\begin_inset Formula $\Lang$
\end_inset

,
 and 
\begin_inset Formula $\vec{b}$
\end_inset

 is a tuple in 
\begin_inset Formula $G$
\end_inset

 such that 
\begin_inset Formula $G\vDash\exists_{\vec{y}}q(\vec{b},\vec{y})$
\end_inset

,
 and some element of 
\begin_inset Formula $\vec{b}$
\end_inset

 is nonzero,
 then there exist integer vectors 
\begin_inset Formula $\vec{c}_{1},\dots,\vec{c}_{\ell}$
\end_inset

 and nonzero integers 
\begin_inset Formula $a_{1},\dots,a_{\ell}$
\end_inset

 such that,
 for every 
\begin_inset Formula $i$
\end_inset

,
 
\begin_inset Formula $a_{i}\mid\vec{c}_{i}\cdot\vec{b}$
\end_inset

,
 and 
\begin_inset Formula $G\vDash q(\vec{b},\frac{1}{a_{1}}\vec{c}_{1}\cdot\vec{b},\dots,\frac{1}{a_{\ell}}\vec{c}_{\ell}\cdot\vec{b})$
\end_inset

.
\end_layout

\begin_layout Standard

\shape italic
Proof of lemma:

\shape default
 We start by writing 
\begin_inset Formula $q(\vec{b},\vec{y})$
\end_inset

 as a linear system of equations
\begin_inset Formula 
\[
q(\vec{x},\vec{y})\equiv\left\{ \begin{aligned}M\vec{b} & =N\vec{y},\\
K\vec{b} & \neq L\vec{y}.
\end{aligned}
\right.
\]

\end_inset

Then,
 as in the construction of 
\begin_inset Formula $\chi_{q}$
\end_inset

,
 we rewrite this system in terms of alternate variables 
\begin_inset Formula $\vec{z}$
\end_inset

,
 which are related to the variables 
\begin_inset Formula $\vec{y}$
\end_inset

 by the relation 
\begin_inset Formula $\vec{z}=B\vec{y}$
\end_inset

 for an invertible matrix 
\begin_inset Formula $B$
\end_inset

:
\begin_inset Formula 
\[
\left\{ \begin{aligned} & M'\vec{b}=D\vec{z},\\
 & K'\vec{b}\neq L'\vec{z},
\end{aligned}
\right.
\]

\end_inset

with 
\begin_inset Formula $D$
\end_inset

 a diagonal matrix.
 Now,
 let us look at the rows of the equation 
\begin_inset Formula $M'\vec{b}=D\vec{z}$
\end_inset

.
 Some rows correspond to a zero element in the diagonal of 
\begin_inset Formula $D$
\end_inset

,
 i.e.
\begin_inset space \space{}
\end_inset

are of the form 
\begin_inset Formula $\vec{m}\cdot\vec{b}=0$
\end_inset

.
 These can be ignored – since it is known that 
\begin_inset Formula $\exists_{y}q(\vec{b},\vec{y})$
\end_inset

,
 these rows simply consist of true linear relations between the 
\begin_inset Formula $\vec{b}$
\end_inset

,
 and the corresponding 
\begin_inset Formula $z$
\end_inset

-variables are free.
 Let us call them 
\begin_inset Formula $\vec{z}_{\mathrm{free}}$
\end_inset

.
 The remaining 
\begin_inset Formula $z$
\end_inset

-variables are determined,
 corresponding to equations of the form 
\begin_inset Formula $\vec{c}_{i}\cdot\vec{b}=a_{i}z_{i}$
\end_inset

.
 As in the construction of 
\begin_inset Formula $\chi_{q}$
\end_inset

,
 this means that the corresponding 
\begin_inset Formula $z$
\end_inset

 variables are determined as 
\begin_inset Formula $z_{i}=\frac{1}{a_{i}}\vec{c}_{i}\cdot\vec{b}$
\end_inset

 (which in particular precludes the fact that 
\begin_inset Formula $a_{i}\mid\vec{c}_{i}\cdot\vec{b}$
\end_inset

).
 Without loss of generality,
 we substitute the determined variables by their corresponding expansion in terms of 
\begin_inset Formula $\vec{b}$
\end_inset

 (which may require clearing denominators),
 leaving us only to satisfy the relation 
\begin_inset Formula $K''\vec{b}\neq L''\vec{z}_{\mathrm{free}}$
\end_inset

.
 Here,
 one again applies a similar reasoning to the one used in the construction of 
\begin_inset Formula $\chi_{q}$
\end_inset

,
 with a minor twist.
 Stratifying the equations so that we first determine 
\begin_inset Formula $z_{1}$
\end_inset

,
 then 
\begin_inset Formula $z_{2}$
\end_inset

,
 and so on,
 we see that at each step 
\begin_inset Formula $z_{i}$
\end_inset

 is only forbidden to take a finite number of values.
 Then,
 we take some 
\emph on
nonzero
\emph default
 
\begin_inset Formula $b_{j}$
\end_inset

,
 and set 
\begin_inset Formula $z_{i}=kb_{j}$
\end_inset

 for some large enough coefficient 
\begin_inset Formula $k$
\end_inset

.
\end_layout

\begin_layout Standard
In the end,
 one concludes that there is a solution to the system of equations 
\begin_inset Formula $q(\vec{b},B\vec{z})$
\end_inset

 whereby every entry of 
\begin_inset Formula $\vec{z}$
\end_inset

 is a valid rational combination of the entries of 
\begin_inset Formula $\vec{b}$
\end_inset

.
 Multiplying this by the integer matrix 
\begin_inset Formula $B$
\end_inset

 yields the desired vector 
\begin_inset Formula $\vec{y}$
\end_inset

,
 also consisting solely of valid rational combinations,
 which serves a solution to 
\begin_inset Formula $q(\vec{b},\vec{y})$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset space \hfill{}
\end_inset


\shape italic
(End proof of lemma.)
\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset

This completes the proof of Item 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:qetp2"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Enumerate
(
\begin_inset Formula $G\vDash\exists_{y}\left[\chi_{Q}(\vec{x},y)\land\tau_{q\varphi}(\vec{x},y)\right]\leftrightarrow\etau_{q\varphi Q}(\vec{x})$
\end_inset

) True by construction.
\end_layout

\begin_layout Enumerate
(
\begin_inset Formula $G\vDash\etau_{q\varphi Q}(\vec{x})\land\tau_{q\varphi}(\vec{x},y)\rightarrow\chi_{Q}(\vec{x},y)$
\end_inset

) Essentially,
 this is true because 
\begin_inset Formula $\tau_{q\varphi}(\vec{x},y)$
\end_inset

 
\emph on
always
\emph default
 determines 
\begin_inset Formula $y$
\end_inset

 uniquely in terms of 
\begin_inset Formula $\vec{x}$
\end_inset

.
 As such,
 if it is the case that there is some 
\begin_inset Formula $y_{0}$
\end_inset

 that satisfies 
\begin_inset Formula $\chi_{Q}(\vec{x},y_{0})\land\tau_{q\varphi}(\vec{x},y_{0})$
\end_inset

 (that is,
 
\begin_inset Formula $\etau_{q\varphi Q}(\vec{x})$
\end_inset

 holds),
 and it is the case that some specific 
\begin_inset Formula $y$
\end_inset

 satisfies 
\begin_inset Formula $\tau_{q\varphi}(\vec{x},y)$
\end_inset

,
 then it must be the case that 
\begin_inset Formula $y=y_{0}$
\end_inset

 and therefore 
\begin_inset Formula $\chi_{Q}(\vec{x},y)$
\end_inset

.
\end_layout

\begin_layout Standard
Thus,
 we are in condition to apply 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 to the 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed copy of 
\begin_inset Formula $G$
\end_inset

 (plus designated element).
 Since this copy was obtained uniformly from the original presentation
\end_layout

\end_deeper
\begin_layout Remark
A useful trick came up in the course of the prior proof:
 If,
 perchance,
 
\begin_inset Formula $\tau_{q\varphi}(\vec{x},y)$
\end_inset

 has the property that 
\begin_inset Formula $y$
\end_inset

 is determined uniquely in terms of 
\begin_inset Formula $\vec{x}$
\end_inset

,
 then Item 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:qetp3"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 of the QETP comes for free.
 This will not apply to any of the other examples present in this article,
 but it does point at something noteworthy:
 It is the job of 
\begin_inset Formula $\tau$
\end_inset

 to determine 
\begin_inset Formula $y$
\end_inset

 as uniquely as possible,
 so that 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 
\begin_inset Quotes eld
\end_inset

knows
\begin_inset Quotes erd
\end_inset

 what is OK to match 
\begin_inset Formula $y$
\end_inset

 with and what is not.
 The case where there is a single well-determined element it can be matched with is optimal,
 but even in other cases,
 we want 
\begin_inset Formula $\tau$
\end_inset

 to pin down the 
\begin_inset Formula $\Lang'$
\end_inset

-type of 
\begin_inset Formula $y$
\end_inset

 as much as possible (and,
 indeed,
 this is in some sense the essence of Item 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

).
\end_layout

\begin_layout Subsection
Linear Orders with Successors and Predecessors
\end_layout

\begin_layout Theorem
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "montalban_cst"
posttextlist "montalban_cst VII.26"
literal "false"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "thm:JIlinear-1"

\end_inset

Suppose that 
\begin_inset Formula $L$
\end_inset

 is a linear order for which every element admits a successor and predecessor,
 and suppose that the structure 
\begin_inset Formula $(L,<,S)$
\end_inset

 admits a 
\begin_inset Formula $0'$
\end_inset

-computable copy,
 where 
\begin_inset Formula $S(x,y)$
\end_inset

 is the successor relation.
 Then,
 the structure 
\begin_inset Formula $(L,<)$
\end_inset

 admits a computable copy.
\end_layout

\begin_layout Proof
The most important step is to make a 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed copy of 
\begin_inset Formula $(L,<,\not<,=,\neq,\{D_{\geq i}\}_{i\in\N})$
\end_inset

,
 where 
\begin_inset Formula $D_{\geq i}(x,y)$
\end_inset

 is the relation 
\begin_inset Quotes eld
\end_inset

there exist 
\begin_inset Formula $x=x_{0}<x_{1}<\dots<x_{i}=y$
\end_inset


\begin_inset Quotes erd
\end_inset

,
 as this is the bare minimum language necessary for quantifier elimination.
 The main difficulty in doing so is that 
\begin_inset Formula $0'$
\end_inset

 does not know enough about two arbitrary elements to create,
 in finite time,
 a c.e.
\begin_inset space \space{}
\end_inset

index for which distance relations hold true of them.
 Thus,
 we shall need to create an intermediary structure in which some sort of distance relations are uniformly c.e.
\end_layout

\begin_layout Proof
We know that 
\begin_inset Formula $(L,<,S)$
\end_inset

 is 
\begin_inset Formula $0'$
\end_inset

-computable,
 and hence there is a computable process that produces a 
\begin_inset Formula $(<,S)$
\end_inset

-structure,
 and is allowed to delete previously added elements,
 such that the set of elements that are never deleted make up an isomorphic copy of 
\begin_inset Formula $(L,<,S)$
\end_inset

.
 We create an auxiliary computable linear order which shall act as a computable shadow of 
\begin_inset Formula $(L,<,S)$
\end_inset

,
 from which we will create a 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed copy of 
\begin_inset Formula $L$
\end_inset

.
\end_layout

\begin_layout Proof
Assume without loss of generality that,
 whenever a real element (i.e.
\begin_inset space \space{}
\end_inset

one that will never be deleted) is added to 
\begin_inset Formula $L$
\end_inset

,
 all elements of 
\begin_inset Formula $L$
\end_inset

 at that moment are themselves real.
 We create a new computable linear order,
 
\begin_inset Formula $(L_{+},<)$
\end_inset

,
 whose elements consist of,
 for some (but not all) elements 
\begin_inset Formula $x$
\end_inset

 that were ever added to 
\begin_inset Formula $L$
\end_inset

 (even if later removed),
 a corresponding element 
\begin_inset Formula $x_{+}$
\end_inset

 in 
\begin_inset Formula $L_{+}$
\end_inset

,
 in such a way that if 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 both coexist in 
\begin_inset Formula $L$
\end_inset

 at the same time,
 
\begin_inset Formula $x<y$
\end_inset

 iff 
\begin_inset Formula $x_{+}<y_{+}$
\end_inset

.
 Here is the process for the creation of 
\begin_inset Formula $L_{+}$
\end_inset

:
 Each time an element 
\begin_inset Formula $x$
\end_inset

 is added to 
\begin_inset Formula $L$
\end_inset

,
 we imagine an element 
\begin_inset Formula $x_{+}$
\end_inset

in 
\begin_inset Formula $L_{+}$
\end_inset

 such that,
 for every 
\begin_inset Formula $y$
\end_inset

 in 
\begin_inset Formula $L$
\end_inset

 at this moment,
 
\begin_inset Formula $x_{+}$
\end_inset

 compares to 
\begin_inset Formula $y_{+}$
\end_inset

 as 
\begin_inset Formula $x$
\end_inset

 compares to 
\begin_inset Formula $y$
\end_inset

.
 Then,
 we need to determine how 
\begin_inset Formula $x_{+}$
\end_inset

 compares to the current elements of 
\begin_inset Formula $L$
\end_inset

 that are not of this form.
 Transitivity will force some comparisons.
 The ones that are not forced can be decided arbitrarily,
 e.g.
\begin_inset space \space{}
\end_inset

say that 
\begin_inset Formula $x_{+}<z$
\end_inset

 for every element with which the comparison is not forced.
 Finally,
 check whether adding this element will break the requirement that 
\begin_inset Formula $(L_{+},<)$
\end_inset

 is a linear order (e.g.
\begin_inset space \space{}
\end_inset

because 
\begin_inset Formula $x$
\end_inset

 is actually a fake element of 
\begin_inset Formula $L$
\end_inset

 that compares to the remaining elements of 
\begin_inset Formula $L$
\end_inset

 in an obviously stupid way),
 and importantly,
 whether it stands between the image of two elements of 
\begin_inset Formula $L$
\end_inset

 that are currently thought to be successors.
 If it does not break these requirement,
 we add 
\begin_inset Formula $x_{+}$
\end_inset

 to 
\begin_inset Formula $L_{+}$
\end_inset

.
 Otherwise,
 proceed with the next element added to 
\begin_inset Formula $L$
\end_inset

.
\end_layout

\begin_layout Proof
We make a few observations:
\end_layout

\begin_deeper
\begin_layout Itemize
Note that 
\begin_inset Formula $L$
\end_inset

 embeds into 
\begin_inset Formula $L_{+}$
\end_inset

 via the map 
\begin_inset Formula $x\mapsto x_{+}$
\end_inset

.
 The main content of this statement is that for every real 
\begin_inset Formula $x$
\end_inset

 we do add 
\begin_inset Formula $x_{+}$
\end_inset

 to 
\begin_inset Formula $L_{+}$
\end_inset

.
 This requires our assumption that,
 every time a real element 
\begin_inset Formula $x$
\end_inset

 is added to 
\begin_inset Formula $L$
\end_inset

,
 all elements currently in 
\begin_inset Formula $L$
\end_inset

 are also real:
 This ensures that 
\begin_inset Formula $x_{+}$
\end_inset

 compares to all other elements of the form 
\begin_inset Formula $y_{+}$
\end_inset

 in a coherent way,
 and it is a standard fact about linear orders (amalgamation property) that we can then add 
\begin_inset Formula $x_{+}$
\end_inset

 to 
\begin_inset Formula $L_{+}$
\end_inset

 in such a way that the resulting order is a linear order,
 and indeed the rule 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $x_{+}$
\end_inset

 is added as the leftmost element of the interval it's forced to be in
\begin_inset Quotes erd
\end_inset

 is a uniform way to do so.
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $xSy$
\end_inset

 are elements of 
\begin_inset Formula $L$
\end_inset

,
 there are finitely many elements of 
\begin_inset Formula $L_{+}$
\end_inset

 between 
\begin_inset Formula $x_{+}$
\end_inset

 and 
\begin_inset Formula $y_{+}$
\end_inset

.
 This is because no element is added to 
\begin_inset Formula $L_{+}$
\end_inset

 after these two are.
\end_layout

\begin_layout Itemize
In any computable linear order (such as 
\begin_inset Formula $L_{+}$
\end_inset

),
 the distance relations 
\begin_inset Formula $\{D_{\geq i}\}_{i\in\N}$
\end_inset

 are uniformly c.e.
 as they are 
\begin_inset Formula $\Sigma_{1}$
\end_inset

-defined.
 As such,
 there is a procedure that takes as input a finite tuple of elements from the order 
\begin_inset Formula $L_{+}$
\end_inset

 and outputs a c.e.
\begin_inset space \space{}
\end_inset

index for their atomic type in the signature 
\begin_inset Formula $(<,\not<,=,\neq,\{D_{\geq i}\}_{i\in\N})$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Proof
We are now ready to create the 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed copy of 
\begin_inset Formula $L$
\end_inset

.
 First,
 we define the 
\begin_inset Formula $0'$
\end_inset

-c.e.
 subset 
\begin_inset Formula $L_{+-}\subseteq L_{+}$
\end_inset

 as
\begin_inset Formula 
\[
L_{+-}=\{\,z\in L_{+}\mid\text{there exist real elements \ensuremath{xSy\in L} such that \ensuremath{x_{+}\leq z\leq y_{+}}}\,\}.
\]

\end_inset

Then,
 we 
\begin_inset Formula $0'$
\end_inset

-enumerate the elements of 
\begin_inset Formula $L_{+-}$
\end_inset

,
 and with each new element we also produce a c.e.
\begin_inset space \space{}
\end_inset

index for the tuple of elements enumerated up to now,
 
\emph on
from the order 
\begin_inset Formula $(L_{+},<)$
\end_inset

.

\emph default
 We claim that the resulting order is isomorphic (as a linear order) to 
\begin_inset Formula $L$
\end_inset

 and that the predicates 
\begin_inset Formula $D_{\geq i}$
\end_inset

 are interpreted in the correct way.
\end_layout

\begin_deeper
\begin_layout Itemize
(The resulting order is isomorphic to 
\begin_inset Formula $L$
\end_inset

):
 Consider the embedding 
\begin_inset Formula $f\colon L\to L_{+-}$
\end_inset

 given by 
\begin_inset Formula $x\mapsto x_{+}$
\end_inset

.
 (We've already seen that this map is well-defined and embeds 
\begin_inset Formula $L$
\end_inset

 into 
\begin_inset Formula $L_{+}$
\end_inset

,
 and from the definition of 
\begin_inset Formula $L_{+-}$
\end_inset

 and the fact that every element of 
\begin_inset Formula $L$
\end_inset

 admits a successor (or a predecessor) it is clear that for every 
\begin_inset Formula $x\in L$
\end_inset

 we have 
\begin_inset Formula $x_{+}\in L_{+-}$
\end_inset

.) This is an order-preserving map with the properties:
\end_layout

\begin_deeper
\begin_layout Itemize
If 
\begin_inset Formula $xSy$
\end_inset

 then there are finitely many elements between 
\begin_inset Formula $f(x)$
\end_inset

 and 
\begin_inset Formula $f(y)$
\end_inset

,
\end_layout

\begin_layout Itemize
Every element of 
\begin_inset Formula $L_{+-}$
\end_inset

 is a finite distance away from an element in the image of 
\begin_inset Formula $f$
\end_inset

.
\end_layout

\begin_layout Standard
One can argue (and indeed,
 the standard proof of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:JIlinear-1"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 also goes through this fact) that in this case 
\begin_inset Formula $(L,<)$
\end_inset

 and 
\begin_inset Formula $(L_{+-},<)$
\end_inset

 are isomorphic:
 Pick one representative 
\begin_inset Formula $x$
\end_inset

 from every finite-distance block from 
\begin_inset Formula $L$
\end_inset

,
 and map 
\begin_inset Formula $S^{i}x$
\end_inset

 (
\begin_inset Formula $i\in\Z)$
\end_inset

 to 
\begin_inset Formula $S^{i}(f(x))$
\end_inset

.
 The fact that this map – call it 
\begin_inset Formula $g$
\end_inset

 – is well-defined requires some details
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
One must verify that every element of 
\begin_inset Formula $L_{+-}$
\end_inset

 has a successor and a predecessor.
 This is because every element 
\begin_inset Formula $z$
\end_inset

 of 
\begin_inset Formula $L_{+-}$
\end_inset

 satisfies 
\begin_inset Formula $\exists_{x}x_{+}<z<(S^{3}x)_{+}$
\end_inset

,
 and there are finitely many elements between 
\begin_inset Formula $x_{+}$
\end_inset

 and 
\begin_inset Formula $(S^{3}x)_{+}$
\end_inset

,
 whereby there must be a smallest element greater (resp.
 smaller) than 
\begin_inset Formula $z$
\end_inset

 as it suffices to take the least (resp.
 greatest) element in the finite interval 
\begin_inset Formula $\left]z,(S^{3}x)_{+}\right]$
\end_inset

 (resp.
 
\begin_inset Formula $\left[x_{+},z\right[$
\end_inset

).
\end_layout

\end_inset

,
 the fact that 
\begin_inset Formula $g$
\end_inset

 is an embedding is obvious,
 and the fact that 
\begin_inset Formula $g$
\end_inset

 is surjective consists of:
 Every element 
\begin_inset Formula $z$
\end_inset

 of 
\begin_inset Formula $L_{+-}$
\end_inset

 is a finite distance away from some 
\begin_inset Formula $y_{+}$
\end_inset

,
 and if 
\begin_inset Formula $x$
\end_inset

 is the representative of the block of 
\begin_inset Formula $y$
\end_inset

 in 
\begin_inset Formula $L$
\end_inset

,
 we must have that 
\begin_inset Formula $z$
\end_inset

 is a finite distance away from 
\begin_inset Formula $x_{+}$
\end_inset

.
 If 
\begin_inset Formula $i$
\end_inset

 is the signed distance between 
\begin_inset Formula $z$
\end_inset

 and 
\begin_inset Formula $x_{+}$
\end_inset

,
 we have 
\begin_inset Formula $z=g(S^{i}x)$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
(The predicates 
\begin_inset Formula $D_{\geq i}$
\end_inset

 are correctly interpreted):
 For the sake of this argument,
 let us denote the predicates induced from 
\begin_inset Formula $L_{+}$
\end_inset

 (and thus the ones we have a c.e.
\begin_inset space \space{}
\end_inset

index for) by 
\begin_inset Formula $\{D_{\geq i}^{\mathrm{ind}}\}_{i\in\N}$
\end_inset

 and the 
\begin_inset Quotes eld
\end_inset

true
\begin_inset Quotes erd
\end_inset

 predicates by 
\begin_inset Formula $\{D_{\geq i}\}_{i\in\N}.$
\end_inset

We would like to show that 
\begin_inset Formula $L_{+-}\vDash D_{\geq i}^{\mathrm{ind}}(x,y)\leftrightarrow D_{\geq i}(x,y)$
\end_inset

.
 The implication 
\begin_inset Formula $\leftarrow$
\end_inset

 is obvious,
 so we focus on the implication 
\begin_inset Formula $\rightarrow$
\end_inset

,
 which we prove by contrapositive.
 Suppose that 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 are elements of 
\begin_inset Formula $L_{+-}$
\end_inset

 such that 
\begin_inset Formula $\neg D_{\geq i}(x,y)$
\end_inset

.
 Let 
\begin_inset Formula $x^{\leftarrow}$
\end_inset

 be an element of 
\begin_inset Formula $L$
\end_inset

 such that 
\begin_inset Formula $(x^{\leftarrow})_{+}\leq x\leq(Sx^{\leftarrow})_{+}$
\end_inset

,
 and likewise define 
\begin_inset Formula $y^{\rightarrow}$
\end_inset

 such that 
\begin_inset Formula $(S^{-1}y^{\rightarrow})_{+}\leq y\leq(y^{\rightarrow})_{+}$
\end_inset

.
 Then,
 all of the elements in the open interval 
\begin_inset Formula $\left]x^{\leftarrow},y^{\rightarrow}\right[$
\end_inset

 are taken to (distinct) real elements between 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

,
 whence there must be finitely (and indeed,
 less than 
\begin_inset Formula $i$
\end_inset

 many) of them.
 Thus,
 the entirety of the interval 
\begin_inset Formula $\left](x^{\leftarrow})_{+},(y^{\rightarrow})_{+}\right[\subseteq L_{+}$
\end_inset

 actually lies in 
\begin_inset Formula $L_{+-}$
\end_inset

,
 and thus distances are preserved between any two elements thereof when considering only elements of 
\begin_inset Formula $L_{+-}$
\end_inset

.
 Since the distance between 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 is less than 
\begin_inset Formula $i$
\end_inset

 in 
\begin_inset Formula $L_{+-}$
\end_inset

,
 it must also be so in 
\begin_inset Formula $L_{+}$
\end_inset

,
 i.e.
\begin_inset space \space{}
\end_inset


\begin_inset Formula $\neg D_{\geq i}^{\mathrm{ind}}(x,y)$
\end_inset

.
\end_layout

\begin_layout Standard
Now that we have a 
\begin_inset Formula $0'$
\end_inset

-computable c.e.-typed copy of 
\begin_inset Formula $(L,<,\not<,=,\neq,\{D_{\geq i}\}_{i\in\N})$
\end_inset

,
 it suffices to establish that it has the QETP,
 whereby 
\begin_inset Formula $(L,<)$
\end_inset

 has a computable copy by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

:
\end_layout

\begin_layout Itemize
To construct 
\begin_inset Formula $\chi_{q}$
\end_inset

:
 Given a type 
\begin_inset Formula $q(\vec{x},\vec{y})$
\end_inset

,
 the demand that 
\begin_inset Formula $\exists_{\vec{y}}q(\vec{x},\vec{y})$
\end_inset

 corresponds to requiring that (the ordering on variables induced by 
\begin_inset Formula $q$
\end_inset

 is coherent,
 and that) the 
\begin_inset Formula $x_{i}$
\end_inset

 are in a specific order,
 and that the adjacent (in this order) 
\begin_inset Formula $x_{i}$
\end_inset

 admit enough space between them to add the necessary 
\begin_inset Formula $y_{j}$
\end_inset

.
 This can obviously be (computably) written as a positive combination of 
\begin_inset Formula $D_{\geq n_{i}}(x_{i},x_{j})$
\end_inset

.
\end_layout

\begin_layout Itemize
To construct 
\begin_inset Formula $\tau$
\end_inset

:
 Given a type 
\begin_inset Formula $q(\vec{x},y,\vec{z})$
\end_inset

,
 we define 
\begin_inset Formula $\tau_{q\top}(\vec{x},y)$
\end_inset

 as follows.
 Consider the linear order induced on the variables 
\begin_inset Formula $\vec{x}$
\end_inset

,
 
\begin_inset Formula $y$
\end_inset

,
 and 
\begin_inset Formula $\vec{z}$
\end_inset

 by 
\begin_inset Formula $q$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Itemize
If,
 in this order,
 there is 
\begin_inset Formula $i$
\end_inset

 such that 
\begin_inset Formula $x_{i}<y$
\end_inset

,
 let 
\begin_inset Formula $i$
\end_inset

 be the largest such WLOG,
 and let 
\begin_inset Formula $k$
\end_inset

 be the number of variables 
\begin_inset Formula $z_{j}$
\end_inset

 such that 
\begin_inset Formula $x_{i}<z_{j}<y$
\end_inset

.
 Then,
 set
\begin_inset Formula 
\[
\tau_{q\top}(\vec{x},y)\equiv D_{\geq k}(x_{i},y)\land\neg D_{\geq(k+1)}(x_{i},y)\text{ (which is to say \ensuremath{S^{k}(x_{i},y)})}.
\]

\end_inset


\end_layout

\begin_layout Itemize
If there is no such 
\begin_inset Formula $i$
\end_inset

,
 but there is at least one 
\begin_inset Formula $x$
\end_inset

-variable,
 let 
\begin_inset Formula $x_{i}$
\end_inset

 be the least 
\begin_inset Formula $x$
\end_inset

-variable,
 let 
\begin_inset Formula $k$
\end_inset

 be the number of 
\begin_inset Formula $z_{j}$
\end_inset

 such that 
\begin_inset Formula $y<z_{j}<x_{i}$
\end_inset

,
 and set
\begin_inset Formula 
\[
\tau_{q\top}(\vec{x},y)\equiv D_{\geq k}(y,x_{i})\land\neg D_{\geq(k+1)}(y,x_{i})\text{ (which is to say \ensuremath{S^{k}(y,x_{i})})}.
\]

\end_inset


\end_layout

\begin_layout Itemize
If there are no 
\begin_inset Formula $x$
\end_inset

-variables,
 set 
\begin_inset Formula $\tau_{q\top}(y)\equiv\top$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
To construct 
\begin_inset Formula $\etau_{q\top Q}$
\end_inset

:
 Depending on the case of the definition of 
\begin_inset Formula $\tau_{q\top}$
\end_inset

,
 respectively,
 and using the notation therein,
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\etau_{q\top Q}(\vec{x})$
\end_inset

 says 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\chi_{Q}(\vec{x})$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 didn't add any new variable between 
\begin_inset Formula $y$
\end_inset

 and 
\begin_inset Formula $x_{i}$
\end_inset


\begin_inset Quotes erd
\end_inset

,
\end_layout

\begin_layout Itemize
Likewise,
\end_layout

\begin_layout Itemize
\begin_inset Formula $\etau_{q\top Q}\equiv\chi_{Q}$
\end_inset

 (applied to the empty tuple).
\end_layout

\end_deeper
\begin_layout Standard
The verification of all the relevant properties is straight-forward and left to the reader.
\begin_inset Separator plain
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
maybe trees?
 but low priority
\end_layout

\end_inset


\end_layout

\begin_layout Section
Escaping Tennenbaum's Theorem with More Truths
\end_layout

\begin_layout Standard
In this section,
 we answer the question posed by Pakhomov in 
\begin_inset CommandInset citation
LatexCommand cite
key "pakhomov"
literal "false"

\end_inset

 that was outlined in the introduction:
 Do there exist theories definitionally equivalent to 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\mathsf{PA}$
\end_inset

 + all 
\begin_inset Formula $\Pi_{n}$
\end_inset

 truths
\begin_inset Quotes erd
\end_inset

 that admit computable nonstandard models?
 The answer is yes,
 but in order to motivate our construction,
 we will first briefly sketch Pakhomov's original construction,
 so as to highlight the ways in which our construction builds upon it.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:pakhomov_original"

\end_inset

Pakhomov's Original Construction
\end_layout

\begin_layout Standard
As explained in the introduction,
 Pakhomov defined in 
\begin_inset Formula $\ZFniptc$
\end_inset

 a ternary predicate 
\begin_inset Formula $S(x,y,z)$
\end_inset

 by transfinite recursion on the von
\begin_inset space ~
\end_inset

Neumann hierarchy,
 which provably satisfies the rule 
\begin_inset Formula $x\in y\leftrightarrow\forall_{z}S(x,y,z)$
\end_inset

,
 whence the theory of 
\begin_inset Formula $S$
\end_inset

 is definitionally equivalent to 
\begin_inset Formula $\ZFniptc$
\end_inset

,
 and which satisfies certain properties that make the theory of 
\begin_inset Formula $(\in,S)$
\end_inset

 amenable to a jump-inversion-type result,
 whereby a computable nonstandard model of the theory of 
\begin_inset Formula $S$
\end_inset

 follows.
 Let us briefly sketch Pakhomov's definition of 
\begin_inset Formula $S$
\end_inset

 within 
\begin_inset Formula $\ZFniptc$
\end_inset

.
 Our definition is not exactly the same as Pakhomov's,
 but differs only in inessential ways.
\end_layout

\begin_layout Standard
We define an ascending sequence of relations 
\begin_inset Formula $S_{\alpha}$
\end_inset

 on 
\begin_inset Formula $V_{q\alpha}$
\end_inset

,
\begin_inset Foot
status open

\begin_layout Plain Layout
Using the convention on ordinal multiplication that satisfies 
\begin_inset Formula $\beta\sup\alpha_{i}=\sup(\beta\alpha_{i})$
\end_inset

.
\end_layout

\end_inset

 where 
\begin_inset Formula $q$
\end_inset

 is a large enough finite ordinal to be determined shortly (Pakhomov's construction sets 
\begin_inset Formula $q=6$
\end_inset

,
 while our choice of construction,
 which is slightly more inefficient in an attempt to make it easier to parse,
 shall set 
\begin_inset Formula $q=10$
\end_inset

),
 in such a way that each 
\begin_inset Formula $S_{\alpha}$
\end_inset

 agrees with every other 
\begin_inset Formula $S_{\beta}$
\end_inset

 where mutually defined.
 This relation is uniquely determined on limit ordinals,
 as 
\begin_inset Formula $V_{q\sup\alpha_{i}}=\cup V_{q\alpha_{i}}$
\end_inset

,
 so it suffices to describe the successor step.
 As such,
 let us define 
\begin_inset Formula $S_{\alpha+1}$
\end_inset

 in terms of 
\begin_inset Formula $S_{\alpha}$
\end_inset

.
\end_layout

\begin_layout Standard
Given 
\begin_inset Formula $\alpha$
\end_inset

,
 a set 
\begin_inset Formula $A\subseteq V_{q\alpha}$
\end_inset

,
 and 
\begin_inset Formula $SA\subseteq(A\cup\{q\alpha\})^{3}$
\end_inset

,
 define an element 
\begin_inset Formula $w(\alpha,A,SA)$
\end_inset

 satisfying the following conditions:
\end_layout

\begin_layout Itemize
\begin_inset Formula $w(\alpha,A,SA)\in V_{q(\alpha+1)}\setminus V_{q\alpha}$
\end_inset

,
\end_layout

\begin_layout Itemize
The operation 
\begin_inset Formula $(\alpha,A,SA)\mapsto w(\alpha,A,SA)$
\end_inset

 is injective as a class function 
\begin_inset Formula $V\times V\times V\to V$
\end_inset

,
 and
\end_layout

\begin_layout Itemize
\begin_inset Formula $w(\alpha,A,SA)$
\end_inset

 is not 
\begin_inset Formula $\in$
\end_inset

-related to any element of 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Standard
An example of such a function is 
\begin_inset Formula $w(\alpha,A,SA):=(q\alpha,(A,SA))$
\end_inset

,
 assuming the usage of Kuratowski pairs 
\begin_inset Formula $(x,y):=\{\{x\},\{x,y\}\}$
\end_inset

,
 which will immediately satisfy the second and third bullet points.
 To ensure the first bullet point is where we are compelled to choose 
\begin_inset Formula $q=10$
\end_inset

,
 as follows:
\end_layout

\begin_layout Itemize
Suppose 
\begin_inset Formula $A\subseteq V_{q\alpha}$
\end_inset

.
 Then,
 
\begin_inset Formula $A\in V_{q\alpha+1}$
\end_inset

.
\end_layout

\begin_layout Itemize
Thus,
 
\begin_inset Formula $A\cup\{q\alpha\}\subseteq V_{q\alpha+1}$
\end_inset

,
 and any pair of its elements is thereby in 
\begin_inset Formula $V_{q\alpha+3}$
\end_inset

,
 whence any triplet is in 
\begin_inset Formula $V_{q\alpha+5}$
\end_inset

.
\end_layout

\begin_layout Itemize
As a consequence,
 we have 
\begin_inset Formula $SA\subseteq V_{q\alpha+5}$
\end_inset

,
 and so 
\begin_inset Formula $SA\in V_{q\alpha+6}$
\end_inset

.
 Thus,
 we conclude 
\begin_inset Formula $w(\alpha,A,SA)\in V_{q\alpha+10}$
\end_inset

,
 and so we set 
\begin_inset Formula $q=10$
\end_inset

 as to obtain 
\begin_inset Formula $w(\alpha,A,SA)\in V_{q(\alpha+1)}$
\end_inset

.
\end_layout

\begin_layout Itemize
We also have that 
\begin_inset Formula $w=w(\alpha,A,SA)$
\end_inset

 is not in 
\begin_inset Formula $V_{q\alpha}$
\end_inset

 because 
\begin_inset Formula $V_{q\alpha}$
\end_inset

 is transitive and does not contain 
\begin_inset Formula $q\alpha$
\end_inset

,
 while 
\begin_inset Formula $w$
\end_inset

 does.
\end_layout

\begin_layout Standard
The motivation for defining 
\begin_inset Formula $w(\alpha,A,SA)$
\end_inset

 is as follows:
 In the course of constructing a computable nonstandard model of the theory of 
\begin_inset Formula $S$
\end_inset

,
 one could consider starting with a 
\begin_inset Formula $0'$
\end_inset

-computable – or equivalently,
 limit-computable in the sense of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "def:limitcomputablestructure"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 – nonstandard model 
\begin_inset Formula $D$
\end_inset

 of 
\begin_inset Formula $(\in,S)$
\end_inset

,
 and,
 when made to remove an element that was added by mistake,
 we instead change our mind about which element of 
\begin_inset Formula $D$
\end_inset

 it represents.
 This requires that any commitments we've already made about 
\begin_inset Formula $S$
\end_inset

 be preserved,
 and since we have no 
\shape italic
a priori
\shape default
 control about what those wrong commitments look like,
 we need to ensure:
 Given a few elements 
\begin_inset Formula $a_{1},\dots,a_{n}$
\end_inset

 of 
\begin_inset Formula $D$
\end_inset

,
 and given a hypothetical element which is 
\begin_inset Formula $S$
\end_inset

-related to those elements in some hard-to-control manner,
 there exists a true element within 
\begin_inset Formula $D$
\end_inset

 that has those relations.
 This element is precisely the one obtained from the 
\begin_inset Formula $w$
\end_inset

 function,
 where 
\begin_inset Formula $A$
\end_inset

 is the set 
\begin_inset Formula $\{a_{1,}\dots,a_{n}\}$
\end_inset

,
 and 
\begin_inset Formula $SA$
\end_inset

 encodes the 
\begin_inset Formula $S$
\end_inset

-relations between our hypothetical element and the elements of 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Standard
Now,
 we could not simply allow any and all possible 
\begin_inset Formula $S$
\end_inset

-relations to hold,
 or otherwise the theory of 
\begin_inset Formula $S$
\end_inset

 would simply be the theory of the random 
\begin_inset Formula $3$
\end_inset

-hypergraph,
 which is far too homogeneous to be definitionally equivalent to set theory.
 This is where the following definition (which takes place inside 
\begin_inset Formula $\ZFniptc$
\end_inset

) comes in.
\end_layout

\begin_layout Standard
We say that a pair 
\begin_inset Formula $(A,SA)$
\end_inset

 is 
\emph on
good
\emph default
 (for the ordinal 
\begin_inset Formula $\alpha$
\end_inset

) if 
\begin_inset Formula $SA$
\end_inset

 is a set of triples of elements from 
\begin_inset Formula $A\cup\{q\alpha\}$
\end_inset

 and the following two conditions hold:
\end_layout

\begin_layout Itemize
\begin_inset Formula $SA$
\end_inset

 agrees with 
\begin_inset Formula $S_{\alpha}$
\end_inset

 on 
\begin_inset Formula $A$
\end_inset

,
 in the sense that 
\begin_inset Formula $SA\cap A^{3}=\{(a,b,c)\in A^{3}\mid S_{\alpha}(a,b,c)\}$
\end_inset

,
 and
\end_layout

\begin_layout Itemize
For every 
\begin_inset Formula $a,b\in A$
\end_inset

 with 
\begin_inset Formula $a\in b$
\end_inset

,
 we have 
\begin_inset Formula $(a,b,q\alpha)\in SA$
\end_inset

.
 By induction on 
\begin_inset Formula $\alpha$
\end_inset

,
 this turns out to be equivalent to the stronger demand that 
\begin_inset Formula $\forall_{a,b\in A}a\in b\rightarrow\forall_{z\in A\cup\{q\alpha\}}(a,b,z)\in SA$
\end_inset

.
\end_layout

\begin_layout Standard
We are now ready to define 
\begin_inset Formula $S_{\alpha+1}$
\end_inset

.
 Given a triplet 
\begin_inset Formula $(a,b,c)\in V_{q(\alpha+1)}^{3}$
\end_inset

,
\end_layout

\begin_layout Itemize
If all elements of the triplet are in 
\begin_inset Formula $V_{q\alpha}$
\end_inset

,
 set 
\begin_inset Formula $S_{\alpha+1}(a,b,c)\equiv S_{\alpha}(a,b,c)$
\end_inset

,
\end_layout

\begin_layout Itemize
If,
 for some choice of 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $SA$
\end_inset

 that is good for 
\begin_inset Formula $\alpha$
\end_inset

,
 every element of the triplet is either in 
\begin_inset Formula $A$
\end_inset

 or is equal to 
\begin_inset Formula $w=w(\alpha,A,SA)$
\end_inset

,
 set 
\begin_inset Formula $S_{\alpha+1}(a,b,c)$
\end_inset

 to hold true if,
 and only if,
 upon replacing every instance of 
\begin_inset Formula $w$
\end_inset

 in the triplet 
\begin_inset Formula $(a,b,c)$
\end_inset

 by 
\begin_inset Formula $q\alpha$
\end_inset

,
 the resulting triplet is in 
\begin_inset Formula $SA$
\end_inset

.
 For example,
 if 
\begin_inset Formula $a,b\in A$
\end_inset

 and 
\begin_inset Formula $c=w(\alpha,A,SA)$
\end_inset

,
 set 
\begin_inset Formula $S_{\alpha+1}(a,b,c)\equiv[(a,b,q\alpha)\in SA]$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
In the sequence,
 when such a choice of 
\begin_inset Formula $\alpha$
\end_inset

,
 
\begin_inset Formula $A$
\end_inset

,
 and 
\begin_inset Formula $SA$
\end_inset

 is clear from context,
 denote by 
\begin_inset Formula $a^{*}$
\end_inset

 the operation of replacing 
\begin_inset Formula $q\alpha$
\end_inset

 by 
\begin_inset Formula $w(\alpha,A,SA)$
\end_inset

,
 and 
\begin_inset Formula $a_{*}$
\end_inset

 the inverse operation.
 Thus,
 the definition of 
\begin_inset Formula $S_{\alpha+1}$
\end_inset

 in this case can be reworded as:
 
\begin_inset Formula $S_{\alpha+1}(a,b,c)\equiv[(a_{*},b_{*},c_{*})\in SA]$
\end_inset

 or,
 equivalently,
 
\begin_inset Formula $S_{\alpha+1}(a^{*},b^{*},c^{*})\equiv[(a,b,c)\in SA]$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
For every other triplet from 
\begin_inset Formula $V_{q(\alpha+1)}$
\end_inset

,
 set 
\begin_inset Formula $S_{\alpha+1}(a,b,c)$
\end_inset

 to hold true.
\end_layout

\begin_layout Standard
With this,
 we define the 
\begin_inset Formula $S$
\end_inset

 relation within 
\begin_inset Formula $\ZFniptc$
\end_inset

 as follows:
 Given 
\begin_inset Formula $a$
\end_inset

,
 
\begin_inset Formula $b$
\end_inset

,
 and 
\begin_inset Formula $c$
\end_inset

,
 it holds by the axiom of transitive closure that all three lie in some common 
\begin_inset Formula $V_{\alpha}$
\end_inset

.
 Then,
 evaluate 
\begin_inset Formula $S(a,b,c)\equiv S_{\alpha}(a,b,c)$
\end_inset

.
\end_layout

\begin_layout Standard
As originally pointed out by Pakhomov,
 the main defining properties of the relation 
\begin_inset Formula $S$
\end_inset

 are following two lemmas:
\end_layout

\begin_layout Lemma
Provably in 
\begin_inset Formula $\ZFniptc$
\end_inset

:
 Given sets 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

,
 
\begin_inset Formula $x\in y$
\end_inset

 iff 
\begin_inset Formula $\forall_{z}S(x,y,z)$
\end_inset

.
\end_layout

\begin_layout Proof
Suppose 
\begin_inset Formula $x\in y$
\end_inset

,
 but also that there is 
\begin_inset Formula $z$
\end_inset

 such that 
\begin_inset Formula $\neg S(x,y,z)$
\end_inset

.
 Let 
\begin_inset Formula $\alpha$
\end_inset

 be the least ordinal for which there exist 
\begin_inset Formula $x,y,z\in V_{q\alpha}$
\end_inset

 with 
\begin_inset Formula $x\in y$
\end_inset

 and 
\begin_inset Formula $\neg S_{\alpha}(x,y,z)$
\end_inset

.
 The only way for this to happen is if,
 for this value of 
\begin_inset Formula $\alpha$
\end_inset

,
 there is a good choice of 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $SA$
\end_inset

 for which 
\begin_inset Formula $(x_{*},y_{*},z_{*})\notin SA$
\end_inset

.
 Because 
\begin_inset Formula $\alpha$
\end_inset

 is minimal,
 at least one of 
\begin_inset Formula $x_{*}$
\end_inset

,
 
\begin_inset Formula $y_{*}$
\end_inset

,
 or 
\begin_inset Formula $z_{*}$
\end_inset

 must be 
\begin_inset Formula $q\alpha$
\end_inset

,
 and since 
\begin_inset Formula $x\in y$
\end_inset

 it cannot be 
\begin_inset Formula $x_{*}$
\end_inset

 nor 
\begin_inset Formula $y_{*}$
\end_inset

.
 However,
 since 
\begin_inset Formula $x_{*}\in y_{*}$
\end_inset

 and 
\begin_inset Formula $z_{*}=q\alpha$
\end_inset

 we must then have 
\begin_inset Formula $(x_{*},y_{*},z_{*})\in SA$
\end_inset

,
 a contradiction.
 This proves that 
\begin_inset Formula $x\in y$
\end_inset

 implies 
\begin_inset Formula $\forall_{z}S(x,y,z)$
\end_inset

.
\end_layout

\begin_layout Proof
For the other direction,
 assume 
\begin_inset Formula $x\notin y$
\end_inset

.
 Pick a large enough value of 
\begin_inset Formula $\alpha$
\end_inset

 such that 
\begin_inset Formula $A=\{x,y\}$
\end_inset

 is contained in 
\begin_inset Formula $V_{q\alpha}$
\end_inset

,
 and consider the set 
\begin_inset Formula $SA=\{(y,x,q\alpha)\}\cup(S_{\alpha}\cap A^{3})$
\end_inset

.
 It can be checked that the pair 
\begin_inset Formula $(A,SA)$
\end_inset

 is good (in fact,
 if 
\begin_inset Formula $y\notin x$
\end_inset

 we could even set 
\begin_inset Formula $SA=S_{\alpha}\cap A^{3}$
\end_inset

).
 As such,
 for 
\begin_inset Formula $w=w(\alpha,A,SA)$
\end_inset

,
 we shall have 
\begin_inset Formula $S_{\alpha+1}(x,y,w)$
\end_inset

 iff 
\begin_inset Formula $(x,y,q\alpha)\in SA$
\end_inset

,
 which is not the case.
 Thus,
 
\begin_inset Formula $\neg S_{\alpha}(x,y,w)$
\end_inset

,
 and so 
\begin_inset Formula $\exists_{z}\neg S(x,y,z)$
\end_inset

 as desired.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:sflex"

\end_inset

Let 
\begin_inset Formula $M$
\end_inset

 be a model of 
\begin_inset Formula $\ZFniptc$
\end_inset

.
 Let 
\begin_inset Formula $A$
\end_inset

 be a finite
\begin_inset Foot
status open

\begin_layout Plain Layout
Here we mean finite from the perspective of the metatheory,
 but indeed this result holds also from within the theory,
 basically by definition.
\end_layout

\end_inset

 subset of 
\begin_inset Formula $M$
\end_inset

,
 and suppose that we wish to find an element 
\begin_inset Formula $w$
\end_inset

 that 
\begin_inset Formula $S$
\end_inset

-relates to all elements of 
\begin_inset Formula $A$
\end_inset

 in a prescribed manner.
 So long as the prescription satisfies the rule:
 
\begin_inset Quotes eld
\end_inset

For all 
\begin_inset Formula $a,b\in A$
\end_inset

 with 
\begin_inset Formula $a\in b$
\end_inset

,
 we have 
\begin_inset Formula $S(a,b,w)$
\end_inset


\begin_inset Quotes erd
\end_inset

,
 there is in fact some 
\begin_inset Formula $w\in M\setminus A$
\end_inset

,
 not 
\begin_inset Formula $\in$
\end_inset

-related to any element of 
\begin_inset Formula $A$
\end_inset

,
 satisfying this prescription.
\end_layout

\begin_layout Proof
This follows basically from the definition of the 
\begin_inset Formula $S$
\end_inset

 relation,
 together with the fact that every finite set (from the perspective of the metatheory) is represented in 
\begin_inset Formula $M$
\end_inset

.
\end_layout

\begin_layout Standard
The above two properties suffice to establish the following jump inversion theorem,
 though we'll forego the proof,
 as 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:gen_pakhomov_jump_inversion"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 completely subsumes it.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:basic_pakhomov_jump_inversion"

\end_inset

If 
\begin_inset Formula $D$
\end_inset

 is a 
\begin_inset Formula $0'$
\end_inset

-computable model of the theory of 
\begin_inset Formula $(\in,S)$
\end_inset

 in 
\begin_inset Formula $\ZFniptc$
\end_inset

,
 the reduct 
\begin_inset Formula $D\upto S$
\end_inset

 admits a computable copy.
\end_layout

\begin_layout Standard
This is enough to establish the following results of Pakhomov's original paper:
\end_layout

\begin_layout Corollary
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Pakhomov 
\begin_inset CommandInset citation
LatexCommand cite
key "pakhomov"
literal "false"

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "cor:cet0"

\end_inset

Every consistent c.e.
\begin_inset space \space{}
\end_inset

 extension 
\begin_inset Formula $T$
\end_inset

 of the theory of 
\begin_inset Formula $S$
\end_inset

 in 
\begin_inset Formula $\ZFniptc$
\end_inset

 admits a computable model.
\end_layout

\begin_layout Proof
The theory 
\begin_inset Formula $\ZFniptc$
\end_inset

 is c.e.,
 and so the theory 
\begin_inset Formula $T'$
\end_inset

 consisting of 
\begin_inset Formula $T$
\end_inset

,
 
\begin_inset Formula $\ZFniptc$
\end_inset

,
 and the definition of 
\begin_inset Formula $S$
\end_inset

 in terms of 
\begin_inset Formula $\in$
\end_inset

,
 is also c.e.
 Thus,
 there is a 
\begin_inset Formula $0'$
\end_inset

-computable complete and consistent extension 
\begin_inset Formula $T''$
\end_inset

 of 
\begin_inset Formula $T'$
\end_inset

,
 and by applying the relativized computable completeness theorem (see 
\begin_inset CommandInset citation
LatexCommand cite
key "harizanov"
literal "false"

\end_inset

),
 there is a 
\begin_inset Formula $0'$
\end_inset

-computable model of 
\begin_inset Formula $T''$
\end_inset

 and hence of the theory of 
\begin_inset Formula $(\in,S)$
\end_inset

.
 We then apply 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:basic_pakhomov_jump_inversion"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 to this model to obtain a computable copy of its reduct to 
\begin_inset Formula $S$
\end_inset

,
 which is a model of 
\begin_inset Formula $T$
\end_inset

.
\end_layout

\begin_layout Corollary
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Pakhomov 
\begin_inset CommandInset citation
LatexCommand cite
key "pakhomov"
literal "false"

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "cor:nonstd"

\end_inset

There is a computable nonstandard model of a theory definitionally equivalent to 
\begin_inset Formula $\mathsf{PA}$
\end_inset

.
\end_layout

\begin_layout Proof
Recall that 
\begin_inset Formula $\ZFfinptc$
\end_inset

 is definitionally equivalent to 
\begin_inset Formula $\mathsf{PA}$
\end_inset

 (see 
\begin_inset CommandInset citation
LatexCommand cite
key "kaye_wong"
literal "false"

\end_inset

 for details),
 and hence the theory of 
\begin_inset Formula $S$
\end_inset

 in 
\begin_inset Formula $\ZFniptc$
\end_inset

 is as well.
 Thus,
 let 
\begin_inset Formula $T$
\end_inset

 be a theory containing the theory of 
\begin_inset Formula $S$
\end_inset

,
 plus the translation to the 
\begin_inset Formula $S$
\end_inset

-language of a statement consistent with 
\begin_inset Formula $\mathsf{PA}$
\end_inset

 not in true arithmetic.
 By 
\begin_inset CommandInset ref
LatexCommand formatted
reference "cor:cet0"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 there is a computable model of 
\begin_inset Formula $T$
\end_inset

.
\end_layout

\begin_layout Standard
The proof of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "cor:nonstd"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 presented above is very close to Pakhomov's original proof.
 We present an alternate proof,
 which is not directly possible as stated using only Pakhomov's results.
\end_layout

\begin_layout Proof
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand formatted
reference "cor:nonstd"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset


\end_layout

\end_inset

Let 
\begin_inset Formula $T$
\end_inset

 be the theory in the language of arithmetic,
 plus an added constant 
\begin_inset Formula $c$
\end_inset

,
 containing the theory of 
\begin_inset Formula $\mathsf{PA}$
\end_inset

,
 plus sentences saying that 
\begin_inset Formula $c$
\end_inset

 is nonstandard:
 
\begin_inset Formula $c\neq0$
\end_inset

,
 
\begin_inset Formula $c\neq S0$
\end_inset

,
 
\begin_inset Formula $c\neq SS0$
\end_inset

,
 and so on.
 Let 
\begin_inset Formula $T'$
\end_inset

 be the theory 
\begin_inset Formula $T$
\end_inset

,
 plus predicates 
\begin_inset Formula $S$
\end_inset

 and 
\begin_inset Formula $\in$
\end_inset

,
 and axioms defining 
\begin_inset Formula $S$
\end_inset

 and 
\begin_inset Formula $\in$
\end_inset

 in terms of the arithmetical symbols.
 Since 
\begin_inset Formula $T'$
\end_inset

 is a c.e.
\begin_inset space \space{}
\end_inset

theory,
 it admits a 
\begin_inset Formula $0'$
\end_inset

-computable model 
\begin_inset Formula $M$
\end_inset

,
 whose reduct to 
\begin_inset Formula $(\mathord{\in},S)$
\end_inset

 satisfies the assumptions of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "cor:cet0"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 and so its reduct to 
\begin_inset Formula $S$
\end_inset

 admits a computable copy.
\end_layout

\begin_layout Subsection
Generalizing Pakhomov's Construction
\end_layout

\begin_layout Standard
In Pakhomov's original construction,
 as explained in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:pakhomov_original"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 the predicate 
\begin_inset Formula $\in$
\end_inset

 is performing two distinct tasks.
 On the one hand,
 
\begin_inset Formula $S$
\end_inset

 is defined to mean 
\begin_inset Quotes eld
\end_inset

set inclusion,
 with a third argument that represents a witness in the case where inclusion does not hold
\begin_inset Quotes erd
\end_inset

,
 with the 
\begin_inset Quotes els
\end_inset

witness
\begin_inset Quotes ers
\end_inset

 part playing a crucial role by being flexible enough to turn 
\begin_inset Formula $0'$
\end_inset

-computable models into computable models.
 On the other hand,
 the predicate 
\begin_inset Formula $\in$
\end_inset

 is providing the 
\begin_inset Quotes eld
\end_inset

definitional flexibility
\begin_inset Quotes erd
\end_inset

 required to allow the entire construction of 
\begin_inset Formula $S$
\end_inset

 to take place,
 as we need the theory we're working in to be powerful enough to quantify over possible prescriptions of 
\begin_inset Formula $S$
\end_inset

 for a hypothetical extra element,
 in order to ensure that an element satisfying this prescription does exist.
 Upon understanding these roles as separate,
 one gets the idea that the construction could be applied to other predicates,
 or even applied to itself recursively.
\end_layout

\begin_layout Standard
There are a few technical hitches in the way of this idea,
 most notably the fact that an implicit ingredient in the construction of 
\begin_inset Formula $S$
\end_inset

 is that the 
\begin_inset Formula $\in$
\end_inset

-relation is 
\begin_inset Quotes eld
\end_inset

rare
\begin_inset Quotes erd
\end_inset

,
 making it easy to construct elements that are 
\begin_inset Formula $\in$
\end_inset

-incomparable to previous elements,
 while conversely the 
\begin_inset Formula $S$
\end_inset

 relation is 
\begin_inset Quotes eld
\end_inset

common
\begin_inset Quotes erd
\end_inset

.
 This foreshadows the idea that,
 in order to generalize to higher-order 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $S$
\end_inset

 relations
\begin_inset Quotes erd
\end_inset

,
 we will need to introduce a few negations.
\end_layout

\begin_layout Standard
Another technical matter regards the coefficient 
\begin_inset Formula $q$
\end_inset

 described in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:pakhomov_original"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
 If we adopt the same exact strategy described therein,
 we would need to increase our coefficient 
\begin_inset Formula $q$
\end_inset

 the more 
\begin_inset Quotes eld
\end_inset

iterations of 
\begin_inset Formula $S$
\end_inset


\begin_inset Quotes erd
\end_inset

 we would like to introduce.
 By itself,
 this is not necessarily an issue,
 but we've found that it simplifies the definition to adopt a slightly different perspective.
 In Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:pakhomov_original"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 we imagine that,
 for a given stage 
\begin_inset Formula $q\alpha$
\end_inset

 of the von
\begin_inset space ~
\end_inset

Neumann hierarchy,
 we look at all possible ways that a new element relates via 
\begin_inset Formula $S$
\end_inset

 to the elements of 
\begin_inset Formula $V_{q\alpha}$
\end_inset

,
 and designate someone realizing these possible relations in 
\begin_inset Formula $V_{q(\alpha+1)}$
\end_inset

.
 If,
 instead,
 we exercise some patience,
 we can instead consider that at every stage 
\begin_inset Formula $V_{\alpha}$
\end_inset

 of the von
\begin_inset space ~
\end_inset

Neumann hierarchy,
 for every possible way for an element to 
\begin_inset Formula $S$
\end_inset

-relate to the elements of 
\begin_inset Formula $V_{\alpha}$
\end_inset

 we 
\begin_inset Quotes eld
\end_inset

schedule
\begin_inset Quotes erd
\end_inset

 an element to relate to them in this manner,
 though this element might only be actually added,
 say,
 in 
\begin_inset Formula $V_{\alpha+100}$
\end_inset

.
 In our view,
 this adds some versatility and simplifies the construction.
\end_layout

\begin_layout Standard
We are now ready to state and prove:
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:nestedpakhomov"

\end_inset

There is a nested sequence of consistent c.e.
\begin_inset space \space{}
\end_inset

theories 
\begin_inset Formula $\ZFniptc\subseteq T^{0}\subseteq T^{1}\subseteq T^{2}\subseteq\cdots$
\end_inset

 satisfying the following properties:
\end_layout

\begin_deeper
\begin_layout Itemize
Each 
\begin_inset Formula $T^{n}$
\end_inset

 is in the language containing 
\begin_inset Formula $\in$
\end_inset

 and predicates 
\begin_inset Formula $S^{0}$
\end_inset

,
 
\begin_inset Formula $\dots$
\end_inset

,
 
\begin_inset Formula $S^{n}$
\end_inset

,
 with each 
\begin_inset Formula $S^{i}$
\end_inset

 being an 
\begin_inset Formula $(i+2)$
\end_inset

-ary predicate symbol,
\end_layout

\begin_layout Itemize
All of these extensions are conservative,
 in the sense that they contain no additional theorems in the predicate 
\begin_inset Formula $\in$
\end_inset

,
\end_layout

\begin_layout Itemize
The predicates 
\begin_inset Formula $\in$
\end_inset

 and 
\begin_inset Formula $S^{n}$
\end_inset

 are definable in terms of the other within 
\begin_inset Formula $T^{n}$
\end_inset

,
 and
\end_layout

\begin_layout Itemize
Given a 
\begin_inset Formula $0'$
\end_inset

-computable model 
\begin_inset Formula $D$
\end_inset

 of 
\begin_inset Formula $T^{n}$
\end_inset

 restricted to the language containing 
\begin_inset Formula $S^{i}$
\end_inset

,
 
\begin_inset Formula $\dots$
\end_inset

,
 and 
\begin_inset Formula $S^{n}$
\end_inset

,
 there is a computable copy 
\begin_inset Formula $M$
\end_inset

 of 
\begin_inset Formula $D\upto(S^{i+1},\dots,S^{n})$
\end_inset

.
\end_layout

\begin_layout Standard
The last item relativizes:
 Given an 
\begin_inset Formula $X'$
\end_inset

-computable model of 
\begin_inset Formula $T^{n}$
\end_inset

 in the last 
\begin_inset Formula $k$
\end_inset

 predicates,
 there is an 
\begin_inset Formula $X$
\end_inset

-computable copy of its reduct to the last 
\begin_inset Formula $k-1$
\end_inset

 predicates.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
We dedicate the remainder of this section to the proof of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:nestedpakhomov"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
 We start by defining the sequence 
\begin_inset Formula $\{T_{n}\}_{n\in\N}$
\end_inset

 inductively.
 For the base case,
 we set 
\begin_inset Formula $T^{0}$
\end_inset

 to be 
\begin_inset Formula $\ZFniptc$
\end_inset

,
 plus the axiom 
\begin_inset Formula $\forall_{x,y}[S^{0}(x,y)\leftrightarrow(x\notin y)]$
\end_inset

.
 It trivially (and,
 in the case of the last bullet point,
 almost vacuously) satisfies all required conditions.
 Now,
 we suppose that 
\begin_inset Formula $T^{n}$
\end_inset

 has already been defined,
 and set out to define 
\begin_inset Formula $T^{n+1}$
\end_inset

.
\end_layout

\begin_layout Standard
Within 
\begin_inset Formula $T^{n}$
\end_inset

,
 we define the ordinal-indexed sequence of predicates 
\begin_inset Formula $S_{\alpha}^{n+1}(\vec{x},y)$
\end_inset

,
 where 
\begin_inset Formula $\vec{x}$
\end_inset

 is an 
\begin_inset Formula $(n+1)$
\end_inset

-uple
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
is there precedent for this?
 upl.
 Future duarte here:
 yes...
 in portuguese and french....
 but there is a small amount of precedent on stack exchange.
 i guess.
\end_layout

\end_inset

 of variables,
 in a way similar to the definition of 
\begin_inset Formula $S_{\alpha}(x,y,z)$
\end_inset

 in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:pakhomov_original"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
 The big picture is the same:
 We define 
\begin_inset Formula $S_{\alpha}^{n+1}$
\end_inset

 inductively as a compatible sequence of relations on 
\begin_inset Formula $V_{\alpha}$
\end_inset

 (note the absence of the constant 
\begin_inset Formula $q$
\end_inset

) with 
\begin_inset Formula $S_{\lambda}^{n+1}$
\end_inset

 having an obvious definition for limit ordinals 
\begin_inset Formula $\lambda$
\end_inset

,
 so it suffices to describe the successor step.
 To assist us in that regard,
 we define the following sequence of class functions:
\end_layout

\begin_layout Standard
Given sets 
\begin_inset Formula $A$
\end_inset

,
 
\begin_inset Formula $mA$
\end_inset

,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The set 
\begin_inset Formula $mA$
\end_inset

 is not present in the original construction of 
\begin_inset Formula $S$
\end_inset

,
 and it is technically not necessary here,
 but it will save us trouble.
 It should be seen as encoding some 
\begin_inset Quotes eld
\end_inset

metadata
\begin_inset Quotes erd
\end_inset

 on the element 
\begin_inset Formula $w$
\end_inset

 we are about to define,
 which is essentially used inductively to give flexibility to higher-order 
\begin_inset Formula $S^{N}$
\end_inset

 predicates.
\end_layout

\end_inset

 an ordinal 
\begin_inset Formula $\alpha$
\end_inset

,
 and sets 
\begin_inset Formula $S^{i}A\subseteq(A\cup\{\alpha\})^{i+2}$
\end_inset

 for 
\begin_inset Formula $i=0,\dots,n+1$
\end_inset

,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Here,
 the expression 
\begin_inset Formula $S^{i}A$
\end_inset

 is merely notation (where 
\begin_inset Formula $i$
\end_inset

 is a finite ordinal and 
\begin_inset Formula $A$
\end_inset

 is a set),
 intended to evoke the idea that 
\begin_inset Formula $S^{i}A$
\end_inset

 is defining the relation 
\begin_inset Formula $S^{i}$
\end_inset

 between the elements of 
\begin_inset Formula $A$
\end_inset

 and a new element.
 Note that 
\begin_inset Formula $S^{0}A$
\end_inset

 is not the same as 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\end_inset

 define an element 
\begin_inset Formula $w^{n}(\alpha,mA,A,SA,\dots,S^{n}A)$
\end_inset

 inductively in 
\begin_inset Formula $n$
\end_inset

 as follows.
 We assume the usage of Kuratowski pairs throughout.
\end_layout

\begin_layout Itemize
\begin_inset Formula $w^{0}(\alpha,mA,A)=(\alpha,(A,mA))$
\end_inset

,
 and
\end_layout

\begin_layout Itemize
\begin_inset Formula $w^{n+1}(\alpha,mA,A,S^{0}A,S^{1}A,\dots,S^{n}A,S^{n+1}A)=w^{n}(\alpha,(S^{n+1}A,mA),A,S^{0}A,\dots,S^{n}A)$
\end_inset

.
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
The main defining features of this sequence of class functions are:
\end_layout

\begin_layout Itemize
For every 
\begin_inset Formula $n$
\end_inset

,
 
\begin_inset Formula $(\alpha,mA,A,S^{0}A,\dots,S^{n}A)\mapsto w^{n}(\alpha,mA,A,S^{0}A,\dots,S^{n}A)$
\end_inset

 is an injective definable class function,
 and
\end_layout

\begin_layout Itemize
\begin_inset Formula $w^{n}(\alpha,mA,A,S^{0}A,\dots,S^{n}A)$
\end_inset

 is 
\emph on
not
\emph default
 in 
\begin_inset Formula $V_{\alpha}$
\end_inset

.
\end_layout

\begin_layout Standard
Let us go back to defining 
\begin_inset Formula $S^{n+1}$
\end_inset

 inductively,
 assuming that we have already defined 
\begin_inset Formula $S^{0}$
\end_inset

 up to 
\begin_inset Formula $S^{n}$
\end_inset

,
 for 
\begin_inset Formula $n\geq0$
\end_inset

.
 Assuming that 
\begin_inset Formula $S_{\alpha}^{n+1}$
\end_inset

 is already defined on tuples of elements of 
\begin_inset Formula $V_{\alpha}$
\end_inset

,
 we define a 
\begin_inset Quotes eld
\end_inset

good sequence
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $(\alpha,mA,A,S^{0}A,\dots,S^{n+1}A)$
\end_inset

 as one that satisfies the following properties:
\end_layout

\begin_layout Itemize
\begin_inset Formula $A$
\end_inset

 is a subset of 
\begin_inset Formula $V_{\alpha}$
\end_inset

,
\end_layout

\begin_layout Itemize
For 
\begin_inset Formula $i=0,\dots,n+1$
\end_inset

,
 the set 
\begin_inset Formula $S^{i}A$
\end_inset

 is a subset of 
\begin_inset Formula $(A\cup\{\alpha\})^{i+2}$
\end_inset

,
\end_layout

\begin_layout Itemize
For 
\begin_inset Formula $i=0,\dots,n$
\end_inset

,
 the set 
\begin_inset Formula $S^{i}A\cap A^{i+2}$
\end_inset

 coincides with the relation 
\begin_inset Formula $S^{i}$
\end_inset

 on 
\begin_inset Formula $A$
\end_inset

,
\end_layout

\begin_layout Itemize
The set 
\begin_inset Formula $S^{n+1}A\cap A^{n+2}$
\end_inset

 coincides with the relation 
\begin_inset Formula $S_{\alpha}^{n+1}$
\end_inset

 on 
\begin_inset Formula $A$
\end_inset

,
\end_layout

\begin_layout Itemize
The set 
\begin_inset Formula $S^{0}A$
\end_inset

 contains all pairs 
\begin_inset Formula $(a,\alpha)$
\end_inset

,
 
\begin_inset Formula $(\alpha,a)$
\end_inset

,
 and 
\begin_inset Formula $(\alpha,\alpha$
\end_inset

).
\end_layout

\begin_layout Itemize
For 
\begin_inset Formula $i=0,\dots,n$
\end_inset

,
 the following condition holds:
 For every 
\begin_inset Formula $(i+3)$
\end_inset

-uple 
\begin_inset Formula $(\vec{a},b)$
\end_inset

 of elements of 
\begin_inset Formula $A\cup\{\alpha\}$
\end_inset

,
 if 
\begin_inset Formula $\vec{a}\notin S^{i}A$
\end_inset

,
 then 
\begin_inset Formula $(\vec{a},b)\in S^{i+1}A$
\end_inset

.
\end_layout

\begin_layout Standard
We are now ready to define 
\begin_inset Formula $S_{\alpha+1}^{n+1}$
\end_inset

.
 Given an 
\begin_inset Formula $(n+3)$
\end_inset

-uple 
\begin_inset Formula $\vec{x}$
\end_inset

 of elements in 
\begin_inset Formula $V_{\alpha+1}$
\end_inset

,
\end_layout

\begin_layout Itemize
If all elements of the tuple are in 
\begin_inset Formula $V_{\alpha}$
\end_inset

,
 set 
\begin_inset Formula $S_{\alpha+1}^{n+1}(\vec{x})\equiv S_{\alpha}^{n+1}(\vec{x})$
\end_inset

,
\end_layout

\begin_layout Itemize
If there is a good sequence 
\begin_inset Formula $(\beta,mA,A,S^{0}A,\dots,S^{n+1}A)$
\end_inset

,
 for some 
\begin_inset Formula $\beta\leq\alpha$
\end_inset

,
 such that the element 
\begin_inset Formula $w=w^{n+1}(\beta,mA,A,S^{0}A,\dots,S^{n+1}A)$
\end_inset

 is in 
\begin_inset Formula $V_{\alpha+1}$
\end_inset

,
 and every entry of 
\begin_inset Formula $\vec{x}$
\end_inset

 is an element of 
\begin_inset Formula $A\cup\{w\}$
\end_inset

,
 set 
\begin_inset Formula $S_{\alpha+1}^{n+1}(\vec{x})$
\end_inset

 to hold true if,
 and only if,
 upon replacing every instance of 
\begin_inset Formula $w$
\end_inset

 in the tuple 
\begin_inset Formula $\vec{x}$
\end_inset

 by 
\begin_inset Formula $\beta$
\end_inset

,
 the resulting tuple is in 
\begin_inset Formula $S^{n+1}A$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
In the sequence,
 when such a choice of good sequence is clear from context,
 denote by 
\begin_inset Formula $\vec{x}^{*}$
\end_inset

 the operation of replacing every entry of 
\begin_inset Formula $\vec{x}$
\end_inset

 that equals 
\begin_inset Formula $\beta$
\end_inset

 by 
\begin_inset Formula $w$
\end_inset

,
 and let 
\begin_inset Formula $\vec{x}_{*}$
\end_inset

 denote the inverse operation.
 Thus,
 the definition of 
\begin_inset Formula $S_{\alpha+1}^{n+1}$
\end_inset

 in this case can be reworded as:
 
\begin_inset Formula $S_{\alpha+1}^{n+1}(\vec{x})\equiv[\vec{x}^{*}\in S^{n+1}A]$
\end_inset

.
\end_layout

\begin_layout Standard
Remark:
 Note that,
 by definition,
 if 
\begin_inset Formula $(\beta,mA,A,S^{0}A,\dots,S^{n+1}A)$
\end_inset

 is a good sequence and 
\begin_inset Formula $n\geq0$
\end_inset

,
 we also have that 
\begin_inset Formula $(\beta,(S^{n+1}A,mA),A,S^{0}A,\dots,S^{n}A)$
\end_inset

 is also a good sequence (for a smaller value of 
\begin_inset Formula $n$
\end_inset

),
 and thus the element 
\begin_inset Formula $w=w^{n+1}(\beta,mA,A,S^{0}A,\dots,S^{n+1})=w^{n}(\beta,(S^{n+1}A,mA),A,S^{0}A,\dots,S^{n}A)$
\end_inset

 will also satisfy:
 
\begin_inset Formula $S^{n}(\vec{x})\equiv[\vec{x}^{*}\in S^{n}A]$
\end_inset

 for all tuples of elements of 
\begin_inset Formula $A\cup\{w\}$
\end_inset

,
 and inductively for lower indices.
 The case of 
\begin_inset Formula $S^{0}$
\end_inset

 is an edge case,
 but the definition of good sequence still ensures that 
\begin_inset Formula $S^{0}(x,y)\equiv[(x,y)^{*}\in S^{0}A]$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
For every other triplet of elements from 
\begin_inset Formula $V_{\alpha+1}$
\end_inset

,
 set 
\begin_inset Formula $S_{\alpha+1}^{n+1}(\vec{x})$
\end_inset

 to hold true.
\end_layout

\begin_layout Standard
Note that the first and second item in the definition do not contradict each other:
 If a tuple 
\begin_inset Formula $\vec{x}$
\end_inset

 fits both bullet points,
 then either all its elements are in 
\begin_inset Formula $A$
\end_inset

,
 in which case the definition of good sequence ensures that there is agreement between both possible definitions of 
\begin_inset Formula $S_{\alpha+1}^{n+1}(\vec{x})$
\end_inset

,
 or one of its elements is 
\begin_inset Formula $w=w^{n+1}(\beta,mA,A,\dots,S^{n+1}A)$
\end_inset

,
 in which case 
\begin_inset Formula $S_{\gamma}^{n+1}(\vec{x})$
\end_inset

 would have been defined to agree with the second bullet point for 
\begin_inset Formula $\gamma$
\end_inset

 the smallest ordinal such that 
\begin_inset Formula $w\in V_{\gamma}$
\end_inset

.
\end_layout

\begin_layout Standard
This induces a well-defined relation 
\begin_inset Formula $S^{n+1}$
\end_inset

,
 whose main defining properties are as follows:
\end_layout

\begin_layout Lemma
Provably in 
\begin_inset Formula $\ZFniptc$
\end_inset

,
 
\begin_inset Formula $\neg S^{n}(\vec{x})$
\end_inset

 iff 
\begin_inset Formula $\forall_{y}S^{n+1}(\vec{x},y)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:sflex_general"

\end_inset

Let 
\begin_inset Formula $M$
\end_inset

 be a model of 
\begin_inset Formula $\ZFniptc$
\end_inset

.
 Let 
\begin_inset Formula $A$
\end_inset

 be a finite subset of 
\begin_inset Formula $M$
\end_inset

,
 and suppose that we wish to find an element 
\begin_inset Formula $w$
\end_inset

 that relates to all elements of 
\begin_inset Formula $A$
\end_inset

 with regard to the predicates 
\begin_inset Formula $S^{0},\dots,S^{n+1}$
\end_inset

 in a prescribed manner.
 The following is a sufficient condition for there to exist an element 
\begin_inset Formula $w$
\end_inset

 of 
\begin_inset Formula $M$
\end_inset

 satisfying this prescription:
 For every 
\begin_inset Formula $0\leq i\leq n$
\end_inset

,
 the prescription satisfies the rules
\end_layout

\begin_deeper
\begin_layout Itemize
The prescription agrees with the pre-existing relations on tuples that don't contain any instance of 
\begin_inset Formula $w$
\end_inset

,
\end_layout

\begin_layout Itemize
For all 
\begin_inset Formula $x\in A\cup\{w\}$
\end_inset

,
 its is prescribed that 
\begin_inset Formula $S^{0}(x,w)$
\end_inset

 and 
\begin_inset Formula $S^{0}(w,x)$
\end_inset

.
\end_layout

\begin_layout Itemize
For all 
\begin_inset Formula $(\vec{x},y)\in(A\cup\{w\})^{i+2}$
\end_inset

 such that 
\begin_inset Formula $\neg S^{i}(\vec{x})$
\end_inset

 is prescribed,
 it is also prescribed that 
\begin_inset Formula $S^{i+1}(\vec{x},y)$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Lemma
These two properties are enough to establish:
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:gen_pakhomov_jump_inversion"

\end_inset

Let 
\begin_inset Formula $D$
\end_inset

 be an 
\begin_inset Formula $X'$
\end_inset

-computable model of 
\begin_inset Formula $T^{(n)}$
\end_inset

 in the predicates 
\begin_inset Formula $S^{i},\dots,S^{n}$
\end_inset

,
 with 
\begin_inset Formula $i<n$
\end_inset

.
 Then,
 the reduct 
\begin_inset Formula $D\upto(S^{i+1},\dots,S^{n})$
\end_inset

 admits an 
\begin_inset Formula $X$
\end_inset

-computable copy.
\end_layout

\begin_layout Proof
We will apply 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 to 
\begin_inset Formula $D$
\end_inset

 which,
 as an 
\begin_inset Formula $X'$
\end_inset

-computable model over a finite language,
 is also an 
\begin_inset Formula $X'$
\end_inset

-computable 
\begin_inset Formula $X$
\end_inset

-c.e.-typed model.
 We need only establish that 
\begin_inset Formula $D$
\end_inset

 has the QETP over 
\begin_inset Formula $\Lang=(S^{i+1},\dots,S^{n})$
\end_inset

 (plus negations) and 
\begin_inset Formula $\Lang'=(S^{i},\dots,S^{n})$
\end_inset

 (plus negations).
\begin_inset FormulaMacro
\newcommand{\abs}[1]{\left|#1\right|}
\end_inset


\end_layout

\begin_layout Proof
We construct 
\begin_inset Formula $\chi$
\end_inset

,
 
\begin_inset Formula $\tau$
\end_inset

,
 and 
\begin_inset Formula $\etau$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize
First,
 we construct 
\begin_inset Formula $\chi_{q}$
\end_inset

.
 We assume without loss of generality that 
\begin_inset Formula $q$
\end_inset

 includes the data that all variables represent distinct elements.
\end_layout

\begin_deeper
\begin_layout Standard
We start by considering the case where 
\begin_inset Formula $q(\vec{x},y)$
\end_inset

 only has one 
\begin_inset Formula $y$
\end_inset

-variable.
 In this case,
 the formula 
\begin_inset Formula $\exists_{y}q(\vec{x},y)$
\end_inset

 is true if,
 and only if,
 there exists an element 
\begin_inset Formula $y$
\end_inset

 satisfying a certain prescription of predicates 
\begin_inset Formula $S^{i+1},\dots,S^{n}$
\end_inset

.
 We show that the following three statements are equivalent:
\end_layout

\begin_layout Itemize
\begin_inset Formula $P(\vec{x})\equiv\exists_{y}q(\vec{x},y)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $Q(\vec{x})$
\end_inset

:
 For every instance of 
\begin_inset Formula $\neg S^{j+1}(\vec{z}_{0},z_{1})$
\end_inset

 in 
\begin_inset Formula $q(\vec{x},y)$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize
If 
\begin_inset Formula $j>i$
\end_inset

,
 we require that 
\begin_inset Formula $S^{j}(\vec{z}_{0})$
\end_inset

 be in 
\begin_inset Formula $q$
\end_inset

,
 and
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Note:
 This demand is happening outside of first-order logic.
 Rather,
 it's a check that we metatheoretically make of 
\begin_inset Formula $q(\vec{x},y)$
\end_inset

,
 and if this check is failed,
 we set 
\begin_inset Formula $Q(\vec{x})\equiv\bot$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $j=i$
\end_inset

,
 
\begin_inset Formula $z_{1}\equiv y$
\end_inset

,
 and 
\begin_inset Formula $\vec{z}_{0}$
\end_inset

 is a subtuple of 
\begin_inset Formula $\vec{x}$
\end_inset

,
 we require 
\begin_inset Formula $S^{i}(\vec{z}_{0})$
\end_inset

,
\end_layout

\begin_layout Standard
Moreover,
 we also demand 
\begin_inset Formula $(q\upto\vec{x})(\vec{x})$
\end_inset

,
 i.e.
\begin_inset space \space{}
\end_inset

whatever demand 
\begin_inset Formula $q$
\end_inset

 makes of the tuple 
\begin_inset Formula $\vec{x}$
\end_inset

,
 we also demand it.
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $R(\vec{x})\equiv$
\end_inset

 There is a 
\begin_inset Formula $y$
\end_inset

 such that 
\begin_inset Formula $q(\vec{x},y)$
\end_inset

 and the relations 
\begin_inset Formula $S^{0}$
\end_inset

 to 
\begin_inset Formula $S^{i}$
\end_inset

hold for all tuples including elements from 
\begin_inset Formula $(\vec{x},y)$
\end_inset

 and at least one instance of 
\begin_inset Formula $y$
\end_inset


\begin_inset Formula $)$
\end_inset

.
\end_layout

\begin_layout Standard
Here is the proof.
 First,
 
\begin_inset Formula $P(\vec{x})\rightarrow Q(\vec{x})$
\end_inset

 follows from the fact that 
\begin_inset Formula $\forall_{\vec{z}_{0}}(\exists_{z_{1}}\neg S^{j+1}(\vec{z}_{0},z_{1}))\rightarrow S^{j}(\vec{z}_{0})$
\end_inset

 (and the assumption that 
\begin_inset Formula $q$
\end_inset

 is a type).
 Second,
 
\begin_inset Formula $Q(\vec{x})\rightarrow R(\vec{x})$
\end_inset

 follows by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:sflex_general"

\end_inset

 as follows:
 
\begin_inset Formula $R(\vec{x})$
\end_inset

 is true if we can find an element 
\begin_inset Formula $w$
\end_inset

 that relates to the elements of 
\begin_inset Formula $\vec{x}$
\end_inset

 in a certain manner.
 This manner consists of using 
\begin_inset Formula $q$
\end_inset

 to dictate 
\begin_inset Formula $S^{i+1}$
\end_inset

 to 
\begin_inset Formula $S^{n}$
\end_inset

,
 and setting all 
\begin_inset Formula $S^{0}$
\end_inset

 to 
\begin_inset Formula $S^{i}$
\end_inset

 as true for tuples containing 
\begin_inset Formula $w$
\end_inset

 and whatever-it-already-is for tuples that do not.
 Finally,
 
\begin_inset Formula $R(\vec{x})$
\end_inset

 obviously implies 
\begin_inset Formula $P(\vec{x})$
\end_inset

.
\end_layout

\begin_layout Standard
Now,
 still in the case where there is only one 
\begin_inset Formula $y$
\end_inset

-variable,
 we set 
\begin_inset Formula $\chi_{q}(\vec{x})\equiv Q(\vec{x})$
\end_inset

 as above.
 We will now handle the case where there are two 
\begin_inset Formula $y$
\end_inset

-variables,
 say 
\begin_inset Formula $y_{1}$
\end_inset

 and 
\begin_inset Formula $y_{2}$
\end_inset

,
 and an obvious induction will handle the general case.
 We will use the formulas 
\begin_inset Formula $P$
\end_inset

,
 
\begin_inset Formula $Q$
\end_inset

,
 and 
\begin_inset Formula $R$
\end_inset

 constructed above for different formulas 
\begin_inset Formula $q$
\end_inset

.
 We will use a subscript to indicate which formula 
\begin_inset Formula $q$
\end_inset

 is being used.
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $q(\vec{x},y_{1},y_{2})$
\end_inset

 be a quantifier-free 
\begin_inset Formula $\Lang$
\end_inset

-type.
 Then,
 let us look at 
\begin_inset Formula $\chi_{q}(\vec{x},y_{1})$
\end_inset

.
 As above,
 it's either 
\begin_inset Formula $\bot$
\end_inset

 (if the first bullet point of the definition of 
\begin_inset Formula $Q_{q}(\vec{x},y_{1})$
\end_inset

 fails),
 in which case the quantifier elimination is trivial,
 or otherwise it consists of 
\begin_inset Formula $q\upto(\vec{x},y_{1})$
\end_inset

,
 together with a few 
\emph on
positive
\emph default
 requirements of type 
\begin_inset Formula $S^{i}(\vec{z}_{0})$
\end_inset

 with 
\begin_inset Formula $\vec{z}_{0}$
\end_inset

 a subtuple of 
\begin_inset Formula $(\vec{x},y_{1})$
\end_inset

.
 Let 
\begin_inset Formula $q'(\vec{x},y_{1})$
\end_inset

 be 
\begin_inset Formula $q\upto(\vec{x},y_{1})$
\end_inset

 together with those requirements that include 
\begin_inset Formula $y_{1}$
\end_inset

,
 and 
\begin_inset Formula $q^{*}(\vec{x})$
\end_inset

 be the remainder of these requirements.
 Note that
\begin_inset Formula 
\[
\exists_{y_{1}}\exists_{y_{2}}q(\vec{x},y_{1},y_{2})\leftrightarrow\exists_{y_{1}}\chi_{q}(\vec{x},y_{1})\leftrightarrow q^{*}(\vec{x})\land\exists_{y_{1}}q'(\vec{x},y_{1}),
\]

\end_inset

and crucially that,
 since all 
\begin_inset Formula $S^{i}$
\end_inset

-requirements made by 
\begin_inset Formula $q'$
\end_inset

 are positive,
 
\begin_inset Formula $\exists_{y_{1}}q'(\vec{x},y_{1})$
\end_inset

 is logically between 
\begin_inset Formula $P_{q'}(\vec{x})$
\end_inset

 and 
\begin_inset Formula $R_{q'}(\vec{x})$
\end_inset

,
 and hence equivalent to both,
 and hence equivalent to 
\begin_inset Formula $Q_{q'}(\vec{x})$
\end_inset

.
 Thus,
 we conclude 
\begin_inset Formula $\exists_{\vec{y}}q(\vec{x},\vec{y})\leftrightarrow q^{*}(\vec{x})\land Q_{q'}(\vec{x})$
\end_inset

,
 and so we define the latter as 
\begin_inset Formula $\chi_{q}$
\end_inset

 in this scenario.
 The induction continues in a similar fashion,
 in the event that there are more 
\begin_inset Formula $y$
\end_inset

-variables,
 with the essential point being that every 
\begin_inset Formula $S^{i}$
\end_inset

-demand being made at any step is positive.
\end_layout

\end_deeper
\begin_layout Itemize
Now,
 we construct 
\begin_inset Formula $\tau$
\end_inset

.
 Given 
\begin_inset Formula $q(\vec{x},y,\vec{z})$
\end_inset

,
 we set 
\begin_inset Formula $\tau_{q\top}(\vec{x},y)$
\end_inset

 to be the demand that every 
\begin_inset Formula $S^{i}$
\end_inset

-relation including 
\begin_inset Formula $y$
\end_inset

 at least once holds,
 and that 
\begin_inset Formula $\chi_{q}(\vec{x})$
\end_inset

 holds.
\end_layout

\begin_layout Itemize
Finally,
 
\begin_inset Formula $\etau_{q\top Q}(\vec{x})$
\end_inset

 is simply 
\begin_inset Formula $\chi_{Q}(\vec{x})$
\end_inset

.
\end_layout

\begin_layout Standard
The proof that these formulas are witnesses to the QETP is simple and follows the same 
\begin_inset Formula $P$
\end_inset

,
 
\begin_inset Formula $Q$
\end_inset

,
 
\begin_inset Formula $R$
\end_inset

 reasoning used to establish that 
\begin_inset Formula $\chi_{q}(\vec{x})\leftrightarrow\exists_{y}q(\vec{x},y)$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:nestedpakhomov"

\end_inset

 immediately follows.
\end_layout

\begin_layout Standard
As explained in the introduction,
 we obtain as a corollary:
\end_layout

\begin_layout Theorem
For every 
\begin_inset Formula $n$
\end_inset

,
 there is a theory definitionally equivalent to 
\begin_inset Formula $\mathsf{PA}$
\end_inset

 plus 
\begin_inset Quotes eld
\end_inset

all true 
\begin_inset Formula $\Pi_{n}$
\end_inset

 sentences
\begin_inset Quotes erd
\end_inset

 that admits a computable non-standard model.
\end_layout

\begin_layout Section
Further Questions
\end_layout

\begin_layout Standard
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:gen_pakhomov_jump_inversion"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 we were able to get the complexity of models down by 
\begin_inset Quotes eld
\end_inset

one jump
\begin_inset Quotes erd
\end_inset

,
 turning a 
\begin_inset Formula $0'$
\end_inset

-computable model of a c.e.
\begin_inset space \space{}
\end_inset

theory into a computable model.
 However,
 a c.e.
\begin_inset space \space{}
\end_inset

theory admits models with complexity far below 
\begin_inset Formula $0'$
\end_inset

.
 We wonder if this could be exploited to obtain stronger results.
\end_layout

\begin_layout Question*
Is there something else that can be said beyond 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:gen_pakhomov_jump_inversion"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main_final"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 in the assumption that we are given,
 say,
 a low model instead of a merely 
\begin_inset Formula $0'$
\end_inset

-computable model?
\end_layout

\begin_layout Question*
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
As always with this kind of work,
 one may wonder whether there exist less artificial theories or predicates that could have filled the role of our predicates 
\begin_inset Formula $S^{1}$
\end_inset

,
 
\begin_inset Formula $S^{2}$
\end_inset

,
 etc.
 In keeping with 
\begin_inset CommandInset citation
LatexCommand cite
key "lutz_walsh_tennenbaum"
literal "false"

\end_inset

,
 we define a 
\begin_inset Quotes els
\end_inset

natural
\begin_inset Quotes ers
\end_inset

 theory or predicate as one that has been studied by mathematicians who are not logicians.
\end_layout

\begin_layout Question*
Does there exist a natural theory that is definitionally equivalent to 
\begin_inset Formula $\mathsf{PA}$
\end_inset

 which admits a non-standard computable model?
\end_layout

\begin_layout Standard
As a dual to this question,
 once one has been made aware of the role of the signature in Tennenbaum's theorem,
 one may think to study more deeply the impact that the signature has on the complexity of nonstandard models of 
\begin_inset Formula $\mathsf{PA}$
\end_inset

.
 For example:
 It is a standard theorem (or definition) that a 
\begin_inset Formula $\mathrm{PA}$
\end_inset

 degree is the same as one which computes a nonstandard model of 
\begin_inset Formula $\mathsf{PA}$
\end_inset

.
 On the other hand,
 we saw that there is a computable nonstandard model of the definitionally equivalent theory 
\begin_inset Formula $T_{0}$
\end_inset

 constructed by Pakhomov – and hence,
 by a theorem of Knight 
\begin_inset CommandInset citation
LatexCommand cite
key "knight_degrees_coded_in_jumps"
literal "false"

\end_inset

,
 there exists one in every degree.
 Let us define,
 for a theory 
\begin_inset Formula $T$
\end_inset

 that is definitionally equivalent to 
\begin_inset Formula $\mathsf{PA}$
\end_inset

,
 its 
\emph on
nonstandard spectrum
\emph default
 as the set of degrees of nonstandard models of 
\begin_inset Formula $T$
\end_inset

.
\end_layout

\begin_layout Question*
If 
\begin_inset Formula $T$
\end_inset

 is a c.e.
\begin_inset space \space{}
\end_inset

theory that is definitionally equivalent to 
\begin_inset Formula $\mathsf{PA}$
\end_inset

,
 we can see that its nonstandard spectrum is at most the set of all Turing degrees,
 and at least the set of all 
\begin_inset Formula $\mathrm{PA}$
\end_inset

 degrees.
 Does there exist such a theory whose nonstandard spectrum is strictly in-between these two cases?
 More generally,
 what can the nonstandard spectrum of a c.e.
\begin_inset space \space{}
\end_inset

theory definitionally equivalent to 
\begin_inset Formula $\mathsf{PA}$
\end_inset

 look like?
\end_layout

\begin_layout Standard
The methods used in this paper are too coarse to address this question;
 they would have to be cleverly modified to stop the nonstandard spectrum from including 
\begin_inset Formula $0$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
In the statement 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:nestedpakhomov"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 the arity of the predicate used to replace set inclusion increased by 
\begin_inset Formula $1$
\end_inset

 for every jump in complexity.
 We wonder if this is a logical necessity or merely an artifact of our construction.
\end_layout

\begin_layout Question*
For a given value of 
\begin_inset Formula $n$
\end_inset

,
 does there exist a theory 
\begin_inset Formula $T_{Q}^{n}$
\end_inset

,
 axiomatizing a single ternary predicate 
\begin_inset Formula $Q(x,y,z)$
\end_inset

,
 such that 
\begin_inset Formula $T_{Q}^{n}$
\end_inset

 is definitionally equivalent to 
\begin_inset Formula $\mathsf{PA}$
\end_inset

 plus 
\begin_inset Quotes els
\end_inset

all 
\begin_inset Formula $\Pi_{n}$
\end_inset

 truths
\begin_inset Quotes ers
\end_inset

 which admits a computable nonstandard model?
 What if we require the predicate to be binary,
 instead?
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "bibliography"
options "plain"
encoding "default"

\end_inset


\end_layout

\end_body
\end_document
