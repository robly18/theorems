#LyX 2.4 created this file. For more info see https://www.lyx.org/
\lyxformat 620
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble

\usepackage{listings}
\lstset{
basicstyle=\ttfamily\footnotesize,
keepspaces=true,
tabsize=4,
breaklines=true,
columns=fullflexible,
mathescape=true
}
\usepackage{fullpage}
\usepackage{braket}

\setlist[enumerate,2]{ref=\theenumi.\theenumii}
\setlist[enumerate,3]{ref=\theenumi.\theenumii.\theenumiii}
\setlist[enumerate,4]{ref=\theenumi.\theenumii.\theenumiii.\theenumiv}


\newref{sec}{refcmd={Section \ref{#1}}}
\end_preamble
\use_default_options true
\begin_modules
duarte_theorems
enumitem
InStar
\end_modules
\maintain_unincluded_children no
\language english
\language_package default
\inputencoding auto-legacy
\fontencoding auto
\font_roman "lmodern" "default"
\font_sans "lmss" "default"
\font_typewriter "lmtt" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_roman_osf false
\font_sans_osf false
\font_typewriter_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\float_alignment class
\paperfontsize default
\spacing single
\use_hyperref false
\papersize letter
\use_geometry false
\use_package amsmath 2
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_formatted_ref 1
\use_minted 0
\use_lineno 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tablestyle default
\tracking_changes false
\output_changes false
\change_bars false
\postpone_fragile_content false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\docbook_table_output 0
\docbook_mathml_prefix 1
\end_header

\begin_body

\begin_layout Title
Escaping Tennenbaum's Theorem with Some More Truths
\end_layout

\begin_layout Author
Duarte Maia
\end_layout

\begin_layout In Preamble
\begin_inset FormulaMacro
\newcommand{\N}{\mathbb{N}}
\end_inset


\end_layout

\begin_layout In Preamble
\begin_inset FormulaMacro
\newcommand{\Lang}{\mathcal{L}}
\end_inset


\end_layout

\begin_layout In Preamble
\begin_inset FormulaMacro
\newcommand{\iswd}{\mathord{\downarrow}}
\end_inset


\end_layout

\begin_layout In Preamble
\begin_inset FormulaMacro
\newcommand{\isnotwd}{\mathord{\uparrow}}
\end_inset


\end_layout

\begin_layout In Preamble
\begin_inset FormulaMacro
\newcommand{\turing}{\mathrm{T}}
\end_inset


\end_layout

\begin_layout In Preamble
\begin_inset FormulaMacro
\newcommand{\upto}{\mathord{\upharpoonright}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\ZFniptc}{\mathsf{ZF}\mathord{-}\mathsf{inf}\mathord{+}\mathsf{TC}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\ZFfinptc}{\mathsf{ZFfin}\mathord{+}\mathsf{TC}}
\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
This document is based on Pakhomov's paper 
\begin_inset Quotes eld
\end_inset

How to Escape Tennenbaum's Theorem
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "pakhomov"
literal "false"

\end_inset

,
 in which a theory 
\begin_inset Formula $T_{0}$
\end_inset

 is defined which is definitonally equivalent to a specific collection of axioms of set theory,
 notably 
\begin_inset Formula $\ZFniptc$
\end_inset

:
 Zermelo-Fraenkel set theory,
 minus the axiom of infinity,
 plus the so-called axiom of transitive closure,
 which in this context is equivalent to assuming the validity of 
\begin_inset Formula $\in$
\end_inset

-induction.
 Pakhomov's theory 
\begin_inset Formula $T_{0}$
\end_inset

 axiomatizes a certain ternary predicate,
 which Pakhomov calls 
\begin_inset Formula $S$
\end_inset

,
 which can be defined in 
\begin_inset Formula $\ZFniptc$
\end_inset

 via ordinal recursion,
 and which therein satisfies the rule
\begin_inset Formula 
\[
\ZFniptc\vdash\forall_{x,y}(x\in y\leftrightarrow\forall_{z}S(x,y,z)).
\]

\end_inset


\end_layout

\begin_layout Standard
The main property of this predicate 
\begin_inset Formula $S$
\end_inset

 is that it is endowed with a certain 
\begin_inset Quotes eld
\end_inset

flexibility
\begin_inset Quotes erd
\end_inset

.
 In a precise sense,
 if we are attempting to build a model of 
\begin_inset Formula $T_{0}$
\end_inset

 and make some mistakes along the way,
 any extra 
\begin_inset Quotes eld
\end_inset

garbage
\begin_inset Quotes erd
\end_inset

 elements we might have added on accident can still be reused as 
\begin_inset Quotes eld
\end_inset

real
\begin_inset Quotes erd
\end_inset

 elements added later on.
 Pakhomov exploits this flexibility to prove:
\end_layout

\begin_layout Theorem
If 
\begin_inset Formula $T$
\end_inset

 is a c.e.
\begin_inset space \space{}
\end_inset

theory extending 
\begin_inset Formula $T_{0}$
\end_inset

 (in the language containing only 
\begin_inset Formula $S$
\end_inset

),
 then 
\begin_inset Formula $T$
\end_inset

 admits a computable model.
\end_layout

\begin_layout Standard
Pakhomov proves this using an explicit 
\begin_inset Quotes eld
\end_inset

Henkin construction
\begin_inset Quotes erd
\end_inset

 type of argument.
 In Sections 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Preliminaries"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:main"

\end_inset

 of this document,
 we provide a slightly improved version of Pakhomov's proof,
 which yields the following stronger result:
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:main"

\end_inset

If 
\begin_inset Formula $M$
\end_inset

 is a 
\begin_inset Formula $0'$
\end_inset

-computable model of 
\begin_inset Formula $T_{1}$
\end_inset

 (that is,
 
\begin_inset Formula $\ZFniptc$
\end_inset

 with the definition of 
\begin_inset Formula $S$
\end_inset

,
 or equivalently 
\begin_inset Formula $T_{0}$
\end_inset

 with the added axiom 
\begin_inset Formula $\forall_{x,y}(x\in y\leftrightarrow\forall_{z}S(x,y,z))$
\end_inset

),
 then 
\begin_inset Formula $M$
\end_inset

 admits a computable copy.
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:additional"

\end_inset

,
 we iterate on the method to answer a question posed by Pakhomov in the affirmative:
\end_layout

\begin_layout Question*
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Pakhomov 
\begin_inset CommandInset citation
LatexCommand cite
key "pakhomov"
literal "false"

\end_inset


\end_layout

\end_inset

Are there theories definitionally equivalent to 
\begin_inset Formula $\mathsf{PA}$
\end_inset

 plus 
\begin_inset Quotes eld
\end_inset

all true 
\begin_inset Formula $\Pi_{n}$
\end_inset

 sentences
\begin_inset Quotes erd
\end_inset

 that have computable non-standard models?
\end_layout

\begin_layout Standard
We answer this question by proving the following improvement on the construction of Pakhomov's theory 
\begin_inset Formula $T_{0}$
\end_inset

:
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:main2"

\end_inset

There is a nested sequence of consistent c.e.
\begin_inset space \space{}
\end_inset

theories 
\begin_inset Formula $\ZFniptc\subseteq T^{0}\subseteq T^{1}\subseteq T^{2}\subseteq\dots$
\end_inset

 satisfying the following properties:
\end_layout

\begin_deeper
\begin_layout Itemize
Each 
\begin_inset Formula $T^{n}$
\end_inset

 is in the language containing 
\begin_inset Formula $\in$
\end_inset

 and predicates 
\begin_inset Formula $S^{0}$
\end_inset

,
 
\begin_inset Formula $\dots$
\end_inset

,
 
\begin_inset Formula $S^{n}$
\end_inset

,
 with each 
\begin_inset Formula $S^{i}$
\end_inset

 being an 
\begin_inset Formula $(i+2)$
\end_inset

-ary predicate symbol,
\end_layout

\begin_layout Itemize
The predicates 
\begin_inset Formula $\in$
\end_inset

 and 
\begin_inset Formula $S^{n}$
\end_inset

 are definable in terms of the other within 
\begin_inset Formula $T^{n}$
\end_inset

,
 and
\end_layout

\begin_layout Itemize
Given a 
\begin_inset Formula $0'$
\end_inset

-computable model 
\begin_inset Formula $D$
\end_inset

 of 
\begin_inset Formula $T^{n}$
\end_inset

 restricted to the language containing 
\begin_inset Formula $S^{i}$
\end_inset

,
 
\begin_inset Formula $\dots$
\end_inset

,
 and 
\begin_inset Formula $S^{n}$
\end_inset

,
 there is a computable copy 
\begin_inset Formula $M$
\end_inset

 of 
\begin_inset Formula $D\upto(S^{i+1},\dots,S^{n})$
\end_inset

.
\end_layout

\begin_layout Standard
The last item relativizes:
 Given a 
\begin_inset Formula $X'$
\end_inset

-computable model of 
\begin_inset Formula $T^{0}\cup\dots\cup T^{n}$
\end_inset

 in the last 
\begin_inset Formula $k$
\end_inset

 predicates,
 there is an 
\begin_inset Formula $X$
\end_inset

-computable copy of its reduct to the last 
\begin_inset Formula $k-1$
\end_inset

 predicates.
\end_layout

\end_deeper
\begin_layout Corollary
\begin_inset CommandInset label
LatexCommand label
name "cor:nonstdpin"

\end_inset

For every 
\begin_inset Formula $n$
\end_inset

,
 there is a theory definitionally equivalent to 
\begin_inset Formula $\mathsf{PA}$
\end_inset

 plus 
\begin_inset Quotes eld
\end_inset

all true 
\begin_inset Formula $\Pi_{n}$
\end_inset

 sentences
\begin_inset Quotes erd
\end_inset

 that admits a computable non-standard model.
\end_layout

\begin_layout Proof
First,
 note that the theory 
\begin_inset Formula $T$
\end_inset

 containing 
\begin_inset Formula $\mathsf{PA}$
\end_inset

 plus all true 
\begin_inset Formula $\Pi_{n}$
\end_inset

 sentences is a 
\begin_inset Formula $0^{(n)}$
\end_inset

-c.e.
\begin_inset space \space{}
\end_inset

theory.
 Moreover,
 by results of Kaye and Wong 
\begin_inset CommandInset citation
LatexCommand cite
key "kaye_wong"
literal "false"

\end_inset

,
 
\begin_inset Formula $\mathsf{PA}$
\end_inset

 is definitionally equivalent to 
\begin_inset Formula $\ZFniptc$
\end_inset

 plus the negation of the axiom of infinity,
 and therefore 
\begin_inset Formula $T$
\end_inset

 is definitionally equivalent to a 
\begin_inset Formula $0^{(n)}$
\end_inset

-c.e.
\begin_inset space \space{}
\end_inset

extension of the theory 
\begin_inset Formula $T^{n+1}$
\end_inset

 from 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main2"

\end_inset

.
 Say 
\begin_inset Formula $\bar{T}$
\end_inset

 is this theory,
 and let 
\begin_inset Formula $\bar{T}^{+}$
\end_inset

 be the same with an added constant 
\begin_inset Formula $c$
\end_inset

 and an axiom schema ensuring that 
\begin_inset Formula $c$
\end_inset

 is a nonstandard element.
 Let 
\begin_inset Formula $D$
\end_inset

 be a 
\begin_inset Formula $0^{(n+1)}$
\end_inset

-computable model of 
\begin_inset Formula $\bar{T}^{+}$
\end_inset

,
 in the language containing the 
\begin_inset Formula $n+2$
\end_inset

 predicates 
\begin_inset Formula $S^{0}$
\end_inset

 to 
\begin_inset Formula $S^{n+1}$
\end_inset

,
 which exists by the computable completeness theorem (see 
\begin_inset CommandInset citation
LatexCommand cite
key "harizanov"
literal "false"

\end_inset

).
 Then,
 apply the relativized version of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main2"

\end_inset

 
\begin_inset Formula $n+1$
\end_inset

 times,
 obtaining a computable model of 
\begin_inset Formula $\bar{T}\upto S^{n+1}$
\end_inset

.
 This shows that 
\begin_inset Formula $\bar{T}\upto S^{n+1}$
\end_inset

 is the theory we sought:
 It is definitionally equivalent to 
\begin_inset Formula $\mathsf{PA}$
\end_inset

,
 and it admits a computable nonstandard model.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Preliminaries"

\end_inset

Preliminaries
\end_layout

\begin_layout Standard
For the sake of concreteness,
 we provide a definition for the ternary predicate 
\begin_inset Formula $S$
\end_inset

 within 
\begin_inset Formula $\ZFniptc$
\end_inset

.
 Our definition is not exactly equal to Pakhomov's,
 but differs only in inessential ways.
\end_layout

\begin_layout Standard
We define an ascending sequence of relations 
\begin_inset Formula $S_{\alpha}$
\end_inset

 on 
\begin_inset Formula $V_{q\alpha}$
\end_inset

,
\begin_inset Foot
status open

\begin_layout Plain Layout
Using the convention on ordinal multiplication that satisfies 
\begin_inset Formula $\beta\sup\alpha_{i}=\sup(\beta\alpha_{i})$
\end_inset

.
\end_layout

\end_inset

 where 
\begin_inset Formula $q$
\end_inset

 is a large enough finite ordinal to be determined (Pakhomov's construction sets 
\begin_inset Formula $q=6$
\end_inset

,
 while we shall set 
\begin_inset Formula $q=9$
\end_inset

),
 in such a way that each 
\begin_inset Formula $S_{\alpha}$
\end_inset

 agrees with every other 
\begin_inset Formula $S_{\beta}$
\end_inset

where mutually defined.
 This relation is uniquely defined on limit ordinals,
 as 
\begin_inset Formula $V_{q\sup\alpha_{i}}=\cup V_{q\alpha_{i}}$
\end_inset

,
 so it suffices to describe the successor step.
 As such,
 let us define 
\begin_inset Formula $S_{\alpha+1}$
\end_inset

 in terms of 
\begin_inset Formula $S_{\alpha}$
\end_inset

.
\end_layout

\begin_layout Standard
Given 
\begin_inset Formula $\alpha$
\end_inset

,
 a set 
\begin_inset Formula $A\subseteq V_{q\alpha}$
\end_inset

,
 and 
\begin_inset Formula $SA\subseteq(A\cup\{q\alpha\})^{3}$
\end_inset

,
 define an element 
\begin_inset Formula $w(\alpha,A,SA)$
\end_inset

 satisfying the following conditions:
\end_layout

\begin_layout Itemize
\begin_inset Formula $w(\alpha,A,SA)\in V_{q(\alpha+1)}\setminus V_{q\alpha}$
\end_inset

,
\end_layout

\begin_layout Itemize
\begin_inset Formula $w$
\end_inset

 is injective as a class function 
\begin_inset Formula $V\times V\times V\to V$
\end_inset

,
 and
\end_layout

\begin_layout Itemize
\begin_inset Formula $w(\alpha,A,SA)$
\end_inset

 is not 
\begin_inset Formula $\in$
\end_inset

-related to any element of 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Standard
An example of such a function is 
\begin_inset Formula $w(\alpha,A,SA):=(q\alpha,(A,SA))$
\end_inset

,
 assuming the usage of Kuratowski pairs 
\begin_inset Formula $(x,y):=\{\{x\},\{x,y\}\}$
\end_inset

.
 This yields a coefficient of 
\begin_inset Formula $q=9$
\end_inset

:
\end_layout

\begin_layout Itemize
\begin_inset Formula $A\subseteq V_{q\alpha}$
\end_inset

,
 hence 
\begin_inset Formula $A\in V_{q\alpha+1}$
\end_inset

.
\end_layout

\begin_layout Itemize
Thus,
 
\begin_inset Formula $A\cup\{q\alpha\}\subseteq V_{q\alpha+1}$
\end_inset

,
 and any pair of its elements is thereby in 
\begin_inset Formula $V_{q\alpha+3}$
\end_inset

,
 whence any triplet is in 
\begin_inset Formula $V_{q\alpha+5}$
\end_inset

.
\end_layout

\begin_layout Itemize
As a consequence,
 we have 
\begin_inset Formula $SA\subseteq V_{q\alpha+5}$
\end_inset

,
 and so 
\begin_inset Formula $SA\in V_{q\alpha+6}$
\end_inset

 Thus,
 we conclude 
\begin_inset Formula $w(\alpha,A,SA)\in V_{q\alpha+9}$
\end_inset

,
 and so setting 
\begin_inset Formula $q=9$
\end_inset

 this implies 
\begin_inset Formula $w(\alpha,A,SA)\in V_{q(\alpha+1)}$
\end_inset

.
\end_layout

\begin_layout Standard
Note that 
\begin_inset Formula $w=w(\alpha,A,SA)$
\end_inset

 is not in 
\begin_inset Formula $V_{q\alpha}$
\end_inset

because 
\begin_inset Formula $V_{q\alpha}$
\end_inset

is transitive and does not contain 
\begin_inset Formula $q\alpha$
\end_inset

,
 while 
\begin_inset Formula $w$
\end_inset

 does.
\end_layout

\begin_layout Standard
We also place a certain type of restriction on the sets 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $SA$
\end_inset

 we will consider.
 We say that a pair 
\begin_inset Formula $(A,SA)$
\end_inset

 is 
\emph on
good
\emph default
 (for the ordinal 
\begin_inset Formula $\alpha$
\end_inset

) if (
\begin_inset Formula $SA$
\end_inset

 is a set of triples from 
\begin_inset Formula $A\cup\{q\alpha\}$
\end_inset

 and) the following two conditions hold:
\end_layout

\begin_layout Itemize
\begin_inset Formula $SA$
\end_inset

 agrees with 
\begin_inset Formula $S_{\alpha}$
\end_inset

 on 
\begin_inset Formula $A$
\end_inset

,
 in the sense that 
\begin_inset Formula $SA\cap A^{3}=\{(a,b,c)\in A^{3}\mid S_{\alpha}(a,b,c)\}$
\end_inset

,
 and
\end_layout

\begin_layout Itemize
For every 
\begin_inset Formula $a,b\in A$
\end_inset

 with 
\begin_inset Formula $a\in b$
\end_inset

,
 we have 
\begin_inset Formula $(a,b,z)\in SA$
\end_inset

 for every 
\begin_inset Formula $z\in A\cup\{q\alpha\}$
\end_inset

.
\end_layout

\begin_layout Standard
We are now ready to define 
\begin_inset Formula $S_{\alpha+1}$
\end_inset

.
 Given a triplet 
\begin_inset Formula $(a,b,c)\in V_{q(\alpha+1)}^{3}$
\end_inset

,
\end_layout

\begin_layout Itemize
If all elements of the triplet are in 
\begin_inset Formula $V_{q\alpha}$
\end_inset

,
 set 
\begin_inset Formula $S_{\alpha+1}(a,b,c)\equiv S_{\alpha}(a,b,c)$
\end_inset

,
\end_layout

\begin_layout Itemize
If,
 for some choice of 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $SA$
\end_inset

 that is good for 
\begin_inset Formula $\alpha$
\end_inset

,
 every element of the triplet is either in 
\begin_inset Formula $A$
\end_inset

 or is equal to 
\begin_inset Formula $w=w(\alpha,A,SA)$
\end_inset

,
 set 
\begin_inset Formula $S_{\alpha+1}(a,b,c)$
\end_inset

 to hold true if,
 and only if,
 upon replacing every instance of 
\begin_inset Formula $w$
\end_inset

 in the triplet 
\begin_inset Formula $(a,b,c)$
\end_inset

 by 
\begin_inset Formula $q\alpha$
\end_inset

,
 the resulting triplet is in 
\begin_inset Formula $SA$
\end_inset

.
 For example,
 if 
\begin_inset Formula $a,b\in A$
\end_inset

 and 
\begin_inset Formula $c=w(\alpha,A,SA)$
\end_inset

,
 set 
\begin_inset Formula $S_{\alpha+1}(a,b,c)\equiv[(a,b,q\alpha)\in SA]$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
For posteriority,
 when such a choice of 
\begin_inset Formula $\alpha$
\end_inset

,
 
\begin_inset Formula $A$
\end_inset

,
 and 
\begin_inset Formula $SA$
\end_inset

 is clear from context,
 denote by 
\begin_inset Formula $a^{*}$
\end_inset

 the operation of replacing 
\begin_inset Formula $q\alpha$
\end_inset

 by 
\begin_inset Formula $w(\alpha,A,SA)$
\end_inset

,
 and 
\begin_inset Formula $a_{*}$
\end_inset

 the inverse operation.
 Thus,
 the definition of 
\begin_inset Formula $S_{\alpha+1}$
\end_inset

 in this case can be reworded as:
 
\begin_inset Formula $S_{\alpha+1}(a,b,c)\equiv[(a_{*},b_{*},c_{*})\in SA]$
\end_inset

 or,
 equivalently,
 
\begin_inset Formula $S_{\alpha+1}(a^{*},b^{*},c^{*})\equiv[(a,b,c)\in SA]$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
For every other triplet from 
\begin_inset Formula $V_{q(\alpha+1)}$
\end_inset

,
 set 
\begin_inset Formula $S_{\alpha+1}(a,b,c)$
\end_inset

 to hold true.
\end_layout

\begin_layout Standard
Note that the first item in the definition of 
\begin_inset Quotes eld
\end_inset

good pair
\begin_inset Quotes erd
\end_inset

 ensures that the first and second item in the definition do not contradict each other.
\end_layout

\begin_layout Standard
With this,
 we may define a relation within 
\begin_inset Formula $\ZFniptc$
\end_inset

 as follows:
 Given 
\begin_inset Formula $a$
\end_inset

,
 
\begin_inset Formula $b$
\end_inset

,
 and 
\begin_inset Formula $c$
\end_inset

,
 it holds by the axiom of transitive closure that all three lie in some common 
\begin_inset Formula $V_{\alpha}$
\end_inset

.
 Then,
 evaluate 
\begin_inset Formula $S(a,b,c)\equiv S_{\alpha}(a,b,c)$
\end_inset

.
\end_layout

\begin_layout Standard
The main defining properties of the relation 
\begin_inset Formula $S$
\end_inset

 are following two lemmas:
\end_layout

\begin_layout Lemma
Provably in 
\begin_inset Formula $\ZFniptc$
\end_inset

:
 Given sets 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

,
 
\begin_inset Formula $x\in y$
\end_inset

 iff 
\begin_inset Formula $\forall_{z}S(x,y,z)$
\end_inset

.
\end_layout

\begin_layout Proof
Suppose 
\begin_inset Formula $x\in y$
\end_inset

,
 but also that there is 
\begin_inset Formula $z$
\end_inset

 such that 
\begin_inset Formula $\neg S(x,y,z)$
\end_inset

.
 The only way for this to happen is if,
 at some least stage 
\begin_inset Formula $\alpha$
\end_inset

,
 we have a good choice of 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $SA$
\end_inset

 for which 
\begin_inset Formula $(x_{*},y_{*},z_{*})\notin SA$
\end_inset

.
 Since this is a good choice,
 it must be the case that 
\begin_inset Formula $x_{*}\notin y_{*}$
\end_inset

,
 while 
\begin_inset Formula $x\in y$
\end_inset

.
 This requires that either 
\begin_inset Formula $x_{*}\neq x$
\end_inset

 or 
\begin_inset Formula $y_{*}\neq y$
\end_inset

,
 which in turn requires that one of these two is equal to 
\begin_inset Formula $w(\alpha,A,SA)$
\end_inset

.
 But if this was the case,
 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 could not be related by 
\begin_inset Formula $\in$
\end_inset

,
 which is a contradiction.
 This proves that 
\begin_inset Formula $x\in y$
\end_inset

 implies 
\begin_inset Formula $\forall_{z}S(x,y,z)$
\end_inset

.
\end_layout

\begin_layout Proof
For the other direction,
 assume 
\begin_inset Formula $x\notin y$
\end_inset

.
 Pick a large enough value of 
\begin_inset Formula $\alpha$
\end_inset

 such that 
\begin_inset Formula $A=\{x,y\}$
\end_inset

 is contained in 
\begin_inset Formula $V_{q\alpha}$
\end_inset

,
 and consider the set 
\begin_inset Formula $SA=\{(y,x,x),(y,x,y),(y,x,q\alpha)\}\cup(S_{\alpha}\cap A^{3})$
\end_inset

.
 It is not hard to verify that the pair 
\begin_inset Formula $(A,SA)$
\end_inset

 is good (in fact,
 if 
\begin_inset Formula $y\notin x$
\end_inset

 we could even set 
\begin_inset Formula $SA=S_{\alpha}\cap A^{3}$
\end_inset

).
 As such,
 for 
\begin_inset Formula $w=w(\alpha,A,SA)$
\end_inset

,
 we shall have 
\begin_inset Formula $S_{\alpha+1}(x,y,w)$
\end_inset

 iff 
\begin_inset Formula $(x,y,w)\in SA$
\end_inset

,
 which is not the case.
 Thus,
 
\begin_inset Formula $\neg S_{\alpha}(x,y,w)$
\end_inset

,
 and so 
\begin_inset Formula $\exists_{z}\neg S(x,y,z)$
\end_inset

 as desired.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:sflex"

\end_inset

Let 
\begin_inset Formula $M$
\end_inset

 be a model of 
\begin_inset Formula $\ZFniptc$
\end_inset

.
 Let 
\begin_inset Formula $A$
\end_inset

 be a finite
\begin_inset Foot
status open

\begin_layout Plain Layout
Here we mean finite from the perspective of the metatheory,
 but indeed this result holds also from within the theory,
 basically by definition.
\end_layout

\end_inset

 subset of 
\begin_inset Formula $M$
\end_inset

,
 and suppose that we wish to find an element 
\begin_inset Formula $w$
\end_inset

 that 
\begin_inset Formula $S$
\end_inset

-relates to all elements of 
\begin_inset Formula $A$
\end_inset

 in a prescribed manner.
 So long as the prescription satisfies the rule:
 
\begin_inset Quotes eld
\end_inset

For all 
\begin_inset Formula $a,b\in A$
\end_inset

 with 
\begin_inset Formula $a\in b$
\end_inset

,
 we have 
\begin_inset Formula $S(a,b,w)$
\end_inset


\begin_inset Quotes erd
\end_inset

,
 there is in fact some 
\begin_inset Formula $w\in M$
\end_inset

,
 not 
\begin_inset Formula $\in$
\end_inset

-related to any element of 
\begin_inset Formula $A$
\end_inset

,
 satisfying this prescription.
\end_layout

\begin_layout Proof
This follows basically from the definition of the 
\begin_inset Formula $S$
\end_inset

 relation,
 together with the fact that every finite set (from the perspective of the metatheory) is represented in 
\begin_inset Formula $M$
\end_inset

.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:main"

\end_inset

The Main Result
\end_layout

\begin_layout Standard
We now turn to proving the main result of this document:
\end_layout

\begin_layout Theorem*
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:main"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset


\end_layout

\end_inset

Let 
\begin_inset Formula $D$
\end_inset

 be a 
\begin_inset Formula $0'$
\end_inset

-computable model of 
\begin_inset Formula $T_{1}$
\end_inset

 (i.e.
\begin_inset space \space{}
\end_inset

set theory with set membership and the 
\begin_inset Formula $S$
\end_inset

 predicate).
 Then,
 the reduct of 
\begin_inset Formula $D$
\end_inset

 to the language with only the 
\begin_inset Formula $S$
\end_inset

 predicate (call it 
\begin_inset Formula $D\mathord{\upharpoonright}_{S}$
\end_inset

) admits a computable copy.
\end_layout

\begin_layout Proof
For the purpose of this proof,
 we envision the 
\begin_inset Formula $0'$
\end_inset

-computable structure 
\begin_inset Formula $D$
\end_inset

 as being given in the following manner:
 A computable process produces a sequence of elements.
 This process shall,
 for each new given element,
 also say how this element is related (by 
\begin_inset Formula $S$
\end_inset

 and by 
\begin_inset Formula $\in$
\end_inset

) to all the previously added elements.
 By itself,
 this would produce a computable model,
 but we also allow for this process to change its mind and erase previously added elements.
 Let 
\begin_inset Formula $D_{\omega}$
\end_inset

 be the collection of all elements that are added by the process and never removed – we shall refer to these as the 
\begin_inset Quotes eld
\end_inset

real
\begin_inset Quotes erd
\end_inset

 elements of 
\begin_inset Formula $D$
\end_inset

.
 This set admits its own version of the set membership and 
\begin_inset Formula $S$
\end_inset

 predicates,
 which is assumed to be isomorphic to 
\begin_inset Formula $D$
\end_inset

.
\end_layout

\begin_layout Proof
We shall build a computable copy of 
\begin_inset Formula $D\upto_{S}$
\end_inset

 via a finite injury argument.
 We imagine a countable assortment of workers,
 referred to as 
\begin_inset Quotes eld
\end_inset

worker 
\begin_inset Formula $i$
\end_inset


\begin_inset Quotes erd
\end_inset

 for 
\begin_inset Formula $i=0,1,2,\dots$
\end_inset

 and describe how each of these workers builds up their part of the computable model 
\begin_inset Formula $M\cong D\upto_{S}$
\end_inset

.
 At the start of the process,
 only worker 
\begin_inset Formula $0$
\end_inset

 shall be active,
 with each worker activating or deactivating higher-index workers as part of their functioning.
 Worker 
\begin_inset Formula $i$
\end_inset

 is the only one responsible for,
 and responsible only for,
 the activation of worker 
\begin_inset Formula $i+1$
\end_inset

,
 and when a worker is deactivated,
 all higher-index workers are deactivated as well.
 The model 
\begin_inset Formula $M$
\end_inset

 is seen as a dynamical variable,
 whose contents are changed over the course of the execution of the algorithm.
 Moreover,
 
\begin_inset Formula $D$
\end_inset

 is also seen as a dynamic variable,
 being modified by a computable process,
 as per the description in the first paragraph of this proof.
 It is assumed that this computable process is executing in parallel with the execution of the algorithm here being described,
 and this algorithm will dynamically react to modifications to 
\begin_inset Formula $D$
\end_inset

 as described below.
\end_layout

\begin_layout Proof
Worker 
\begin_inset Formula $i$
\end_inset

's internal state contains a partition of the (dynamic) structure 
\begin_inset Formula $M$
\end_inset

 into three parts:
\end_layout

\begin_deeper
\begin_layout Itemize
The 
\noun on
previous
\noun default
 part,
 which is the responsibility of lower-index workers and worker 
\begin_inset Formula $i$
\end_inset

 shall not touch,
\end_layout

\begin_layout Itemize
The 
\noun on
current
\noun off
 part,
 whose elements it is worker 
\begin_inset Formula $i$
\end_inset

's responsibility to match to elements of 
\begin_inset Formula $D$
\end_inset

,
 and
\end_layout

\begin_layout Itemize
The 
\noun on
next
\noun off
 part,
 consisting of elements created by workers activated by worker 
\begin_inset Formula $i$
\end_inset

,
 which worker 
\begin_inset Formula $i$
\end_inset

 shall not touch;
 of the previous three,
 this is the only part that will change over the course of the execution of the algorithm (unless worker 
\begin_inset Formula $i$
\end_inset

 gets deactivated and re-initialized).
\end_layout

\begin_layout Standard
When it is necessary to disambiguate,
 we let e.g.
\begin_inset space \space{}
\end_inset


\begin_inset Formula $\textsc{current}_{i}$
\end_inset

 denote the 
\noun on
current
\noun default
 part of 
\begin_inset Formula $M$
\end_inset

 from the perspective of worker 
\begin_inset Formula $i$
\end_inset

 at the moment.
\end_layout

\begin_layout Standard
As indicated above,
 every worker's goal is to create a matching between the 
\noun on
current
\noun off
 part of 
\begin_inset Formula $M$
\end_inset

 (from its perspective) and a subset of 
\begin_inset Formula $D$
\end_inset

.
 Only once this is done shall worker 
\begin_inset Formula $i$
\end_inset

 initialize worker 
\begin_inset Formula $i+1$
\end_inset

.
 As such,
 each worker also has access to a matching between its 
\noun on
previous
\noun default
 part of 
\begin_inset Formula $M$
\end_inset

 and a subset of 
\begin_inset Formula $D$
\end_inset

,
 induced by the lower-index workers.
\end_layout

\begin_layout Standard
When worker 
\begin_inset Formula $i$
\end_inset

 is activated,
 its internal state is initialized as follows:
\end_layout

\begin_layout Itemize
The 
\noun on
previous
\noun default
 part of 
\begin_inset Formula $M$
\end_inset

 is the union of the 
\noun on
current
\noun off
 part of workers 
\begin_inset Formula $0,1,\dots,i-1$
\end_inset

,
\end_layout

\begin_layout Itemize
The 
\noun on
current
\noun off
 part of 
\begin_inset Formula $M$
\end_inset

 consists of every element in 
\begin_inset Formula $M$
\end_inset

 (at the moment of initialization of worker 
\begin_inset Formula $i$
\end_inset

) that is not in the 
\noun on
previous
\noun default
 part,
\end_layout

\begin_layout Itemize
The 
\noun on
next
\noun off
 part of 
\begin_inset Formula $M$
\end_inset

 starts out empty.
 Whenever an element is added to 
\begin_inset Formula $M$
\end_inset

 by a worker of higher index than 
\begin_inset Formula $i$
\end_inset

,
 it will be added to the 
\noun on
next
\noun off
 part.
\end_layout

\begin_layout Standard
Once worker 
\begin_inset Formula $i$
\end_inset

 is done being initialized,
 it performs the following three tasks in order:
\end_layout

\begin_layout Itemize
To begin,
 it finds the first
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
We are being deliberately ambiguous about the 
\begin_inset Quotes eld
\end_inset

type
\begin_inset Quotes erd
\end_inset

 of the elements of 
\begin_inset Formula $D$
\end_inset

,
 but any reasonable well-ordering of its elements will be appropriate for our purposes.
 The one we find to be most elegant consists of ordering elements by the order in which they were added to 
\begin_inset Formula $D$
\end_inset

.
\end_layout

\end_inset

 element of 
\begin_inset Formula $D$
\end_inset

 that is not yet matched to any element of 
\begin_inset Formula $M$
\end_inset

;
 let's call it 
\begin_inset Formula $q$
\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
There is a minor detail to keep note of here,
 which is that this search will,
 in fact,
 eventually terminate.
 This is because 
\begin_inset Formula $D$
\end_inset

 is infinite,
 as it is a model of some type of set theory.
\end_layout

\end_inset

 Then,
 it performs the following sanity check:
 Are there any two elements of 
\begin_inset Formula $D$
\end_inset

,
 say 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset

,
 that are already matched to elements of 
\begin_inset Formula $M$
\end_inset

,
 that satisfy 
\begin_inset Formula $a\in b$
\end_inset

 and 
\begin_inset Formula $\neg S(a,b,q)$
\end_inset

?
 If there are such elements,
 wait without doing anything until 
\begin_inset Formula $D$
\end_inset

 either changes removes 
\begin_inset Formula $q$
\end_inset

,
 in which case this task is restarted,
 or until 
\begin_inset Formula $D$
\end_inset

 removes 
\begin_inset Formula $a$
\end_inset

 or 
\begin_inset Formula $b$
\end_inset

,
 in which case – as described below – an injury will occur in a lower-index worker and worker 
\begin_inset Formula $i$
\end_inset

 will be deactivated as a result.
 On the other hand,
 if there are no such elements 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset

,
 we add to 
\begin_inset Formula $M$
\end_inset

 a new element 
\begin_inset Formula $q'$
\end_inset

,
 which is 
\begin_inset Formula $S$
\end_inset

-related to the elements of the 
\noun on
previous
\noun default
 part of 
\begin_inset Formula $M$
\end_inset

 in the way prescribed by 
\begin_inset Formula $D$
\end_inset

 and the pre-existing matching between this part and a subset of 
\begin_inset Formula $D$
\end_inset

,
 and the 
\begin_inset Formula $S$
\end_inset

-relations between 
\begin_inset Formula $q'$
\end_inset

 and elements not in the 
\noun on
previous
\noun default
 part can be chosen arbitrarily.
 For the sake of concreteness,
 let's say that we set 
\begin_inset Formula $S(x,y,z)\equiv\top$
\end_inset

 whenever 
\begin_inset Formula $(x,y,z)$
\end_inset

 is a triple of elements of which at least one is 
\begin_inset Formula $q'$
\end_inset

 and the remainder are not all in the 
\noun on
previous
\noun default
 part of 
\begin_inset Formula $M$
\end_inset

.
\end_layout

\begin_layout Itemize
Once this is done,
 we set out to match all elements of the 
\noun on
current
\noun default
 part of 
\begin_inset Formula $M$
\end_inset

 to elements of 
\begin_inset Formula $D$
\end_inset

.
 To this effect,
 we iterate through these elements one by one in order
\begin_inset Foot
status open

\begin_layout Plain Layout
As in the case of 
\begin_inset Formula $D$
\end_inset

,
 assume that the elements of 
\begin_inset Formula $M$
\end_inset

 are ordered by time of creation/entry into 
\begin_inset Formula $M$
\end_inset

.
\end_layout

\end_inset

,
 and to each of them (say,
 
\begin_inset Formula $m$
\end_inset

) we assign the first element 
\begin_inset Formula $d$
\end_inset

 of 
\begin_inset Formula $D$
\end_inset

 that is:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $S$
\end_inset

-Related to all elements of 
\begin_inset Formula $D$
\end_inset

 that are already matched to elements of 
\begin_inset Formula $M$
\end_inset

 in the same way that 
\begin_inset Formula $m$
\end_inset

 is related to their match.
 In other words,
 if 
\begin_inset Formula $m_{1}$
\end_inset

,
 
\begin_inset Formula $m_{2}$
\end_inset

,
 and 
\begin_inset Formula $m_{3}$
\end_inset

 are either 
\begin_inset Formula $m$
\end_inset

 or elements of 
\begin_inset Formula $M$
\end_inset

 that have a match,
 and for 
\begin_inset Formula $i=1,2,3$
\end_inset

 we have that 
\begin_inset Formula $d_{i}$
\end_inset

 is the match of 
\begin_inset Formula $m_{i}$
\end_inset

 if it has one,
 and 
\begin_inset Formula $d$
\end_inset

 if 
\begin_inset Formula $m_{i}=d$
\end_inset

,
 then we demand that 
\begin_inset Formula $S(m_{1},m_{2,}m_{3})\equiv S(d_{1},d_{2},d_{3})$
\end_inset

 (where the right-hand side is computed from the perspective of our current approximation of 
\begin_inset Formula $D$
\end_inset

),
 and
\end_layout

\begin_layout Itemize
Not 
\begin_inset Formula $\in$
\end_inset

-related to any element of 
\begin_inset Formula $D$
\end_inset

 that is already matched to an element of 
\begin_inset Formula $M$
\end_inset

 (again,
 from the perspective of our current approximation).
\end_layout

\begin_layout Standard
We will give more details shortly,
 but we note that this search is guaranteed to terminate (or else worker 
\begin_inset Formula $i$
\end_inset

 will be facing injury) in finite time due to 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:sflex"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
Finally,
 once all elements of the 
\noun on
current
\noun default
 part of 
\begin_inset Formula $M$
\end_inset

 are matched,
 we initialize worker 
\begin_inset Formula $i+1$
\end_inset

 with:
\begin_inset Formula 
\[
\begin{cases}
\textsc{previous}_{i+1}=\textsc{previous}_{i}\cup\textsc{current}_{i},\\
\textsc{current}_{i+1}=\textsc{next}_{i},\text{ and}\\
\textsc{next}_{i+1}=\emptyset.
\end{cases}
\]

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Then,
 worker 
\begin_inset Formula $i$
\end_inset

 ceases to act unless it faces injury,
 which we will now begin to describe.
\end_layout

\end_deeper
\begin_layout Standard
The only part of the algorithm left to be described is how it deals with the possibility that the process describing 
\begin_inset Formula $D$
\end_inset

 deletes elements.
 If a deleted element has not been matched with anyone in 
\begin_inset Formula $M$
\end_inset

,
 no action needs to be taken.
 However,
 if a deleted element has been matched with some 
\begin_inset Formula $m$
\end_inset

 in 
\begin_inset Formula $M$
\end_inset

,
 we first find the value of 
\begin_inset Formula $i$
\end_inset

 for which 
\begin_inset Formula $m\in\textsc{current}_{i}$
\end_inset

.
 Then,
 we halt the execution of all workers with index greater than 
\begin_inset Formula $i$
\end_inset

,
 and forget all matchings between elements of 
\begin_inset Formula $\textsc{current}_{i}\cup\textsc{next}_{i}$
\end_inset

 and elements of 
\begin_inset Formula $D$
\end_inset

,
 and restart the execution of worker 
\begin_inset Formula $i$
\end_inset

 (which includes creating a new element for 
\begin_inset Formula $M$
\end_inset

) – albeit,
 crucially,
 
\emph on
not
\emph default
 re-initializing 
\begin_inset Formula $\textsc{next}_{i}$
\end_inset

 to be the empty set.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset

This completes the description of the computable model 
\begin_inset Formula $M$
\end_inset

.
 It remains to prove that 
\begin_inset Formula $M$
\end_inset

 is isomorphic to 
\begin_inset Formula $D\upto_{S}$
\end_inset

.
 We claim that the matching that is built along the course of the algorithm furnishes such an isomorphism.
 Indeed,
 it is obvious by construction that this matching preserves the 
\begin_inset Formula $S$
\end_inset

 relation,
 so it suffices to show that every element of 
\begin_inset Formula $M$
\end_inset

 is matched to someone in 
\begin_inset Formula $D$
\end_inset

 and vice-versa.
 To this effect,
 it suffices to show that every worker is injured finitely many times.
 This proves the desired result as follows:
\end_layout

\begin_layout Itemize
By the first task assigned to worker 
\begin_inset Formula $i$
\end_inset

,
 it's not hard to show that,
 by the time that worker 
\begin_inset Formula $i$
\end_inset

 finishes its job (and is nevermore injured),
 the 
\begin_inset Formula $i$
\end_inset

-th (real) element of 
\begin_inset Formula $D$
\end_inset

 is matched to someone in 
\begin_inset Formula $M$
\end_inset

.
 Thus,
 every (real) element of 
\begin_inset Formula $D$
\end_inset

 is eventually matched to someone in 
\begin_inset Formula $M$
\end_inset

.
\end_layout

\begin_layout Itemize
On the other hand,
 let us show that every element 
\begin_inset Formula $m$
\end_inset

 of 
\begin_inset Formula $M$
\end_inset

 is eventually matched to someone in 
\begin_inset Formula $D$
\end_inset

.
 Consider executing the algorithm until 
\begin_inset Formula $m$
\end_inset

 is added to 
\begin_inset Formula $M$
\end_inset

,
 by worker 
\begin_inset Formula $i$
\end_inset

,
 let's say.
 If worker 
\begin_inset Formula $i$
\end_inset

 is never injured,
 the matching remains forever,
 as desired.
 On the other hand,
 assume that injury occurs,
 and let 
\begin_inset Formula $j\leq i$
\end_inset

 be the smallest index worker that faces injury past this point.
 Then,
 either 
\begin_inset Formula $i=j$
\end_inset

,
 in which case 
\begin_inset Formula $m$
\end_inset

 is in 
\begin_inset Formula $\textsc{current}_{i}$
\end_inset

 and will have a permanent matching by the point where worker 
\begin_inset Formula $i$
\end_inset

 ceases to be injured,
 or 
\begin_inset Formula $j<i$
\end_inset

,
 in which case 
\begin_inset Formula $m$
\end_inset

 will be in 
\begin_inset Formula $\textsc{next}_{j}$
\end_inset

 and therefore in 
\begin_inset Formula $\textsc{current}_{j+1}$
\end_inset

 by the time worker 
\begin_inset Formula $j+1$
\end_inset

 is initialized for the last time.
 Thus,
 when worker 
\begin_inset Formula $j+1$
\end_inset

 ceases to be injured,
 
\begin_inset Formula $m$
\end_inset

 will be assigned a permanent match in 
\begin_inset Formula $D$
\end_inset

.
\end_layout

\begin_layout Standard
Thus,
 we now turn to showing that every worker is injured finitely many times.
 By induction,
 assume that this is the case for all workers of index less than a given 
\begin_inset Formula $i$
\end_inset

,
 and we shall show that it is also true for worker 
\begin_inset Formula $i$
\end_inset

.
\end_layout

\begin_layout Standard
Pick a time in the simulation where all workers less than 
\begin_inset Formula $i$
\end_inset

 have been injured as many times as they would have.
 Then,
 by the next time that worker 
\begin_inset Formula $i$
\end_inset

 is activated,
 it will never be deactivated.
 Now,
 let 
\begin_inset Formula $d$
\end_inset

 be the first real element of 
\begin_inset Formula $D$
\end_inset

 that hasn't been matched to anyone in 
\begin_inset Formula $M$
\end_inset

 yet,
 and wait until all non-real elements of 
\begin_inset Formula $D$
\end_inset

 that have been added before 
\begin_inset Formula $d$
\end_inset

 have already been removed.
 By this point,
 since worker 
\begin_inset Formula $i$
\end_inset

 always matches the first available element of 
\begin_inset Formula $D$
\end_inset

 that passes the sanity check,
 which 
\begin_inset Formula $d$
\end_inset

 does because it's a real element and 
\begin_inset Formula $D\vDash x\in y\rightarrow\forall_{z}S(x,y,z)$
\end_inset

,
 we will have matched 
\begin_inset Formula $d$
\end_inset

 to someone in 
\begin_inset Formula $M$
\end_inset

,
 and this match is permanent.
\end_layout

\begin_layout Standard
Now,
 iterate over the elements of 
\begin_inset Formula $\textsc{current}_{i}$
\end_inset

 in order.
 For each such element 
\begin_inset Formula $m$
\end_inset

,
 worker 
\begin_inset Formula $i$
\end_inset

 will always try to match it to the first element of 
\begin_inset Formula $D$
\end_inset

 that passes the sanity check.
 We show that there is a real element that passes the sanity check,
 whereby,
 by a similar argument as in the previous paragraph,
 for large enough values of time 
\begin_inset Formula $m$
\end_inset

 will be matched to the first such real element.
 To show that there is such an element that passes the sanity check,
 we apply 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:sflex"

\end_inset

 above.
 It suffices to prove that,
 if 
\begin_inset Formula $m_{1}$
\end_inset

 and 
\begin_inset Formula $m_{2}$
\end_inset

 are two elements of 
\begin_inset Formula $M$
\end_inset

 already matched to,
 say,
 
\begin_inset Formula $d_{1}$
\end_inset

 and 
\begin_inset Formula $d_{2}$
\end_inset

 in 
\begin_inset Formula $D$
\end_inset

,
 and it is the case that 
\begin_inset Formula $\neg S(m_{1},m_{2},m)$
\end_inset

,
 then it must also be the case that 
\begin_inset Formula $d_{1}\notin d_{2}$
\end_inset

.
 But by examining the way in which elements are added to 
\begin_inset Formula $M$
\end_inset

,
 and that matchings are created between elements of 
\begin_inset Formula $M$
\end_inset

 and elements of 
\begin_inset Formula $D$
\end_inset

,
 we find that care has been taken to ensure that this remains the case at every step of the algorithm,
 whence 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:sflex"

\end_inset

 applies and so element 
\begin_inset Formula $m$
\end_inset

 will eventually be (permanently) matched.
 Once all elements 
\begin_inset Formula $m\in\textsc{current}_{i}$
\end_inset

 have been permanently matched,
 worker 
\begin_inset Formula $i$
\end_inset

 will cease to act and never be injured,
 which completes the proof.
\end_layout

\end_deeper
\begin_layout Corollary
\begin_inset CommandInset label
LatexCommand label
name "cor:cet0"

\end_inset

Every consistent c.e.
\begin_inset space \space{}
\end_inset

 extension 
\begin_inset Formula $T'$
\end_inset

 of 
\begin_inset Formula $T_{0}$
\end_inset

 (in the language of 
\begin_inset Formula $S$
\end_inset

) admits a computable model
\end_layout

\begin_layout Proof
It is a standard fact that there is a 
\begin_inset Formula $0'$
\end_inset

-computable complete and consistent extension of 
\begin_inset Formula $T'\cup T_{1}$
\end_inset

,
 and by applying the relativized computable completeness theorem (see 
\begin_inset CommandInset citation
LatexCommand cite
key "harizanov"
literal "false"

\end_inset

),
 there is a 
\begin_inset Formula $0'$
\end_inset

-computable model of 
\begin_inset Formula $T'\cup T_{1}$
\end_inset

.
 We then apply 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 to this model to obtain a computable copy of its reduct to 
\begin_inset Formula $S$
\end_inset

,
 which is a model of 
\begin_inset Formula $T'$
\end_inset

.
\end_layout

\begin_layout Corollary
\begin_inset CommandInset label
LatexCommand label
name "cor:nonstd"

\end_inset

There is a computable nonstandard model of a theory definitionally equivalent to 
\begin_inset Formula $\mathsf{PA}$
\end_inset

.
\end_layout

\begin_layout Proof
First,
 we note that 
\begin_inset Formula $\ZFniptc$
\end_inset

 plus the negation of axiom of infinity,
 which we denote by 
\begin_inset Formula $\ZFfinptc$
\end_inset

,
 is definitionally equivalent to 
\begin_inset Formula $\mathsf{PA}$
\end_inset

 (see 
\begin_inset CommandInset citation
LatexCommand cite
key "kaye_wong"
literal "false"

\end_inset

 for details),
 and hence 
\begin_inset Formula $T_{0}$
\end_inset

.
 Thus,
 let 
\begin_inset Formula $T$
\end_inset

 be a theory containing 
\begin_inset Formula $T_{0}$
\end_inset

,
 plus the translation to the 
\begin_inset Formula $S$
\end_inset

-language of a statement consistent with 
\begin_inset Formula $\mathsf{PA}$
\end_inset

 not in true arithmetic.
 By 
\begin_inset CommandInset ref
LatexCommand formatted
reference "cor:cet0"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 there is a computable model of 
\begin_inset Formula $T$
\end_inset

.
\end_layout

\begin_layout Standard
The proof of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "cor:nonstd"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 presented above is very close to Pakhomov's original proof.
 We present an alternate proof,
 which is not directly possible as stated using only Pakhomov's results.
\end_layout

\begin_layout Proof
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand formatted
reference "cor:nonstd"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset


\end_layout

\end_inset

Let 
\begin_inset Formula $T$
\end_inset

 be the theory in the language of arithmetic,
 plus an added constant 
\begin_inset Formula $c$
\end_inset

,
 containing the theory of 
\begin_inset Formula $\mathsf{PA}$
\end_inset

,
 plus sentences saying that 
\begin_inset Formula $c$
\end_inset

 is nonstandard:
 
\begin_inset Formula $c\neq0$
\end_inset

,
 
\begin_inset Formula $c\neq S0$
\end_inset

,
 
\begin_inset Formula $c\neq SS0$
\end_inset

,
 and so on.
 Let 
\begin_inset Formula $T'$
\end_inset

 be the theory 
\begin_inset Formula $T$
\end_inset

,
 plus predicates 
\begin_inset Formula $S$
\end_inset

 and 
\begin_inset Formula $\in$
\end_inset

,
 and axioms defining 
\begin_inset Formula $S$
\end_inset

 and 
\begin_inset Formula $\in$
\end_inset

 in terms of the arithmetical symbols.
 Since 
\begin_inset Formula $T'$
\end_inset

 is a c.e.
\begin_inset space \space{}
\end_inset

theory,
 it admits a 
\begin_inset Formula $0'$
\end_inset

-computable model 
\begin_inset Formula $M$
\end_inset

,
 whose reduct to 
\begin_inset Formula $\{\mathord{\in},S\}$
\end_inset

 is a model of 
\begin_inset Formula $T_{1}$
\end_inset

,
 and so its reduct to 
\begin_inset Formula $S$
\end_inset

 admits a computable copy.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:additional"

\end_inset

Additional Results
\end_layout

\begin_layout Standard
In the proof of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 the predicate 
\begin_inset Formula $\in$
\end_inset

 is performing two distinct tasks.
 On the one hand,
 
\begin_inset Formula $S$
\end_inset

 is defined to mean 
\begin_inset Quotes eld
\end_inset

set inclusion,
 with a third argument that represents a witness to this fact
\begin_inset Quotes erd
\end_inset

,
 with the 
\begin_inset Quotes els
\end_inset

witness
\begin_inset Quotes ers
\end_inset

 part playing a crucial role by being flexible enough to turn 
\begin_inset Formula $0'$
\end_inset

-computable models into computable models.
 On the other hand,
 it is providing the 
\begin_inset Quotes eld
\end_inset

definitional flexibility
\begin_inset Quotes erd
\end_inset

 required to allow the entire construction of 
\begin_inset Formula $S$
\end_inset

 to take place,
 as we need the theory we're working in to be powerful enough to quantify over possible prescriptions of 
\begin_inset Formula $S$
\end_inset

 over a hypothetical extra element,
 in order to ensure that an element satisfying this prescription does exist.
 Upon understanding these roles as separate,
 one gets the idea that the construction could be applied to other predicates,
 or even applied to itself recursively.
\end_layout

\begin_layout Standard
There are a few technical hitches in the way of this idea,
 notably the fact that an implicit ingredient in the construction of 
\begin_inset Formula $S$
\end_inset

 is that the 
\begin_inset Formula $\in$
\end_inset

-relation is 
\begin_inset Quotes eld
\end_inset

rare
\begin_inset Quotes erd
\end_inset

,
 making it easy to construct elements that are 
\begin_inset Formula $\in$
\end_inset

-incomparable to previous elements,
 while conversely the 
\begin_inset Formula $S$
\end_inset

 relation is 
\begin_inset Quotes eld
\end_inset

common
\begin_inset Quotes erd
\end_inset

.
 This foreshadows the idea that,
 in order to generalize to higher-order 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $S$
\end_inset

 relations
\begin_inset Quotes erd
\end_inset

,
 we will need to introduce a few negations.
 Once this and some other technical kinks are worked out,
 we obtain the following theorem:
\end_layout

\begin_layout Theorem*
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:main2"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset


\end_layout

\end_inset

There is a nested sequence of consistent c.e.
\begin_inset space \space{}
\end_inset

theories 
\begin_inset Formula $\ZFniptc\subseteq T^{0}\subseteq T^{1}\subseteq T^{2}\subseteq\dots$
\end_inset

 satisfying the following properties:
\end_layout

\begin_deeper
\begin_layout Itemize
Each 
\begin_inset Formula $T^{n}$
\end_inset

 is in the language containing 
\begin_inset Formula $\in$
\end_inset

 and predicates 
\begin_inset Formula $S^{0}$
\end_inset

,
 
\begin_inset Formula $\dots$
\end_inset

,
 
\begin_inset Formula $S^{n}$
\end_inset

,
 with each 
\begin_inset Formula $S^{i}$
\end_inset

 being an 
\begin_inset Formula $(i+2)$
\end_inset

-ary predicate symbol,
\end_layout

\begin_layout Itemize
The predicates 
\begin_inset Formula $\in$
\end_inset

 and 
\begin_inset Formula $S^{n}$
\end_inset

 are definable in terms of the other within 
\begin_inset Formula $T^{n}$
\end_inset

,
 and
\end_layout

\begin_layout Itemize
Given a 
\begin_inset Formula $0'$
\end_inset

-computable model 
\begin_inset Formula $D$
\end_inset

 of 
\begin_inset Formula $T^{n}$
\end_inset

 restricted to the language containing 
\begin_inset Formula $S^{i}$
\end_inset

,
 
\begin_inset Formula $\dots$
\end_inset

,
 and 
\begin_inset Formula $S^{n}$
\end_inset

,
 there is a computable copy 
\begin_inset Formula $M$
\end_inset

 of 
\begin_inset Formula $D\upto(S^{i+1},\dots,S^{n})$
\end_inset

.
\end_layout

\begin_layout Standard
The last item relativizes:
 Given a 
\begin_inset Formula $X'$
\end_inset

-computable model of 
\begin_inset Formula $T^{0}\cup\dots\cup T^{n}$
\end_inset

 in the last 
\begin_inset Formula $k$
\end_inset

 predicates,
 there is an 
\begin_inset Formula $X$
\end_inset

-computable copy of its reduct to the last 
\begin_inset Formula $k-1$
\end_inset

 predicates.
\end_layout

\end_deeper
\begin_layout Proof
We define the sequence inductively.
 We begin by setting 
\begin_inset Formula $T^{0}$
\end_inset

 to be 
\begin_inset Formula $\ZFniptc$
\end_inset

,
 plus the axiom 
\begin_inset Formula $\forall_{x,y}[S^{0}(x,y)\leftrightarrow(x\notin y)]$
\end_inset

.
 It trivially (and,
 in the case of the last bullet point,
 almost vacuously) satisfies all required conditions.
 Now,
 we suppose that 
\begin_inset Formula $T^{n}$
\end_inset

 has already been defined,
 and set out to define 
\begin_inset Formula $T^{n+1}$
\end_inset

.
\end_layout

\begin_layout Proof
Within 
\begin_inset Formula $T^{n}$
\end_inset

,
 we define the ordinal-indexed sequence of predicates 
\begin_inset Formula $S_{\alpha}^{n+1}(\vec{x},y)$
\end_inset

,
 where 
\begin_inset Formula $\vec{x}$
\end_inset

 is an 
\begin_inset Formula $(n+1)$
\end_inset

-uple of variables,
 in a way similar to the definition of 
\begin_inset Formula $S_{\alpha}(x,y,z)$
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Preliminaries"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 though in order to avoid excessive technical baggage,
 we adopt the construction to better suit our purposes.
 The big picture is similar:
 We define 
\begin_inset Formula $S_{\alpha}^{n+1}$
\end_inset

 inductively as compatible sequence of relations on 
\begin_inset Formula $V_{\alpha}$
\end_inset

 (note the absence of the constant 
\begin_inset Formula $q$
\end_inset

) with 
\begin_inset Formula $S_{\lambda}^{n+1}$
\end_inset

 having an obvious definition for limit ordinals 
\begin_inset Formula $\lambda$
\end_inset

,
 so it suffices to describe the successor step.
 To assist us in that regard,
 we define the following sequence of class functions:
\end_layout

\begin_layout Proof
Given sets 
\begin_inset Formula $A$
\end_inset

,
 
\begin_inset Formula $mA$
\end_inset

,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The set 
\begin_inset Formula $mA$
\end_inset

 is not present in the original construction of 
\begin_inset Formula $S$
\end_inset

,
 and it is technically not necessary here,
 but it will save us trouble.
 It should be seen as encoding some 
\begin_inset Quotes eld
\end_inset

metadata
\begin_inset Quotes erd
\end_inset

 on the element 
\begin_inset Formula $w$
\end_inset

 we are about to define,
 which is essentially be used inductively to give flexibility to higher-order 
\begin_inset Formula $S^{N}$
\end_inset

 predicates.
\end_layout

\end_inset

 an ordinal 
\begin_inset Formula $\alpha$
\end_inset

,
 and sets 
\begin_inset Formula $S^{i}A\subseteq(A\cup\{\alpha\})^{i+2}$
\end_inset

 for 
\begin_inset Formula $i=1,\dots,n+1$
\end_inset

,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Here,
 the expression 
\begin_inset Formula $S^{i}A$
\end_inset

 is merely notation (where 
\begin_inset Formula $i$
\end_inset

 is a finite ordinal and 
\begin_inset Formula $A$
\end_inset

 is a set),
 intended to evoke the idea that 
\begin_inset Formula $S^{i}A$
\end_inset

 is defining the relation 
\begin_inset Formula $S^{i}$
\end_inset

 between the elements of 
\begin_inset Formula $A$
\end_inset

 and a new element.
\end_layout

\end_inset

 define an element 
\begin_inset Formula $w^{n}(\alpha,mA,A,SA,\dots,S^{n}A)$
\end_inset

 inductively in 
\begin_inset Formula $n$
\end_inset

 as follows.
 We assume the usage of Kuratowski pairs throughout.
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $w^{0}(\alpha,mA,A)=(\alpha,(A,mA))$
\end_inset

,
 and
\end_layout

\begin_layout Itemize
\begin_inset Formula $w^{n+1}(\alpha,mA,A,SA,\dots,S^{n}A,S^{n+1}A)=w^{n}(\alpha,(S^{n+1}A,mA),A,SA,\dots,S^{n}A)$
\end_inset

.
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
The main defining features of this sequence of class functions are:
\end_layout

\begin_layout Itemize
Each 
\begin_inset Formula $w^{n}$
\end_inset

 is an injective definable class function,
 and
\end_layout

\begin_layout Itemize
\begin_inset Formula $w^{n}(\alpha,mA,A,\dots,S^{n}A)$
\end_inset

 is 
\emph on
not
\emph default
 in 
\begin_inset Formula $V_{\alpha}$
\end_inset

.
\end_layout

\begin_layout Standard
Let us go back to defining 
\begin_inset Formula $S^{n+1}$
\end_inset

 inductively,
 assuming that we have already defined 
\begin_inset Formula $S^{0}$
\end_inset

 up to 
\begin_inset Formula $S^{n}$
\end_inset

.
 Assuming that 
\begin_inset Formula $S_{\alpha}^{n+1}$
\end_inset

 is already defined on 
\begin_inset Formula $V_{\alpha}$
\end_inset

,
 we define a 
\begin_inset Quotes eld
\end_inset

good sequence
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $(\alpha,mA,A,\dots,S^{n+1}A)$
\end_inset

 as one that satisfies the following properties:
\end_layout

\begin_layout Itemize
\begin_inset Formula $A$
\end_inset

 is a subset of 
\begin_inset Formula $V_{\alpha}$
\end_inset

,
\end_layout

\begin_layout Itemize
For 
\begin_inset Formula $i=1,\dots,n+1$
\end_inset

,
 the set 
\begin_inset Formula $S^{i}A$
\end_inset

 is a subset of 
\begin_inset Formula $(A\cup\{\alpha\})^{i+2}$
\end_inset

,
\end_layout

\begin_layout Itemize
For 
\begin_inset Formula $i=1,\dots,n$
\end_inset

,
 the set 
\begin_inset Formula $S^{i}A\cap A^{i+2}$
\end_inset

 coincides with the relation 
\begin_inset Formula $S^{i}$
\end_inset

 on 
\begin_inset Formula $A$
\end_inset

,
\end_layout

\begin_layout Itemize
The set 
\begin_inset Formula $S^{n+1}A\cap A^{n+2}$
\end_inset

 coincides with the relation 
\begin_inset Formula $S_{\alpha}^{n+1}$
\end_inset

 on 
\begin_inset Formula $A$
\end_inset

,
\end_layout

\begin_layout Itemize
For 
\begin_inset Formula $i=0,\dots,n$
\end_inset

,
 the following condition holds:
 For every 
\begin_inset Formula $(i+2)$
\end_inset

-uple 
\begin_inset Formula $\vec{a}$
\end_inset

 of elements of 
\begin_inset Formula $A$
\end_inset

,
 if 
\begin_inset Formula $\neg S^{i}(\vec{a})$
\end_inset

 holds,
 then 
\begin_inset Formula $(\vec{a},\alpha)\in S^{i+1}A$
\end_inset

.
 Recall that 
\begin_inset Formula $S^{0}(x,y)$
\end_inset

 is defined as 
\begin_inset Formula $x\notin y$
\end_inset

.
\end_layout

\begin_layout Standard
We are now ready to define 
\begin_inset Formula $S_{\alpha+1}^{n+1}$
\end_inset

.
 Given an 
\begin_inset Formula $n+3$
\end_inset

-uple 
\begin_inset Formula $\vec{x}\in V_{\alpha+1}^{n+3}$
\end_inset

,
\end_layout

\begin_layout Itemize
If all elements of the triplet are in 
\begin_inset Formula $V_{\alpha}$
\end_inset

,
 set 
\begin_inset Formula $S_{\alpha+1}^{n+1}(\vec{x})\equiv S_{\alpha}^{n+1}(\vec{x})$
\end_inset

,
\end_layout

\begin_layout Itemize
If there is a good sequence 
\begin_inset Formula $(\beta,mA,A,\dots,S^{n+1}A)$
\end_inset

,
 for some 
\begin_inset Formula $\beta\leq\alpha$
\end_inset

,
 such that the element 
\begin_inset Formula $w=w^{n+1}(\beta,mA,A,\dots,S^{n+1}A)$
\end_inset

 is in 
\begin_inset Formula $V^{\alpha+1}$
\end_inset

,
 and every entry of 
\begin_inset Formula $\vec{x}$
\end_inset

 is an element of 
\begin_inset Formula $A\cup\{w\}$
\end_inset

,
 set 
\begin_inset Formula $S_{\alpha+1}^{n+1}(\vec{x})$
\end_inset

 to hold true if,
 and only if,
 upon replacing every instance of 
\begin_inset Formula $w$
\end_inset

 in the tuple by 
\begin_inset Formula $\beta$
\end_inset

,
 the resulting tuple is in 
\begin_inset Formula $S^{n+1}A$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
For posteriority,
 when such a choice of good sequence is clear from context,
 denote by 
\begin_inset Formula $\vec{x}^{*}$
\end_inset

 the operation of replacing every entry of 
\begin_inset Formula $\vec{x}$
\end_inset

 that equals 
\begin_inset Formula $\beta$
\end_inset

 by 
\begin_inset Formula $w$
\end_inset

,
 and let 
\begin_inset Formula $\vec{x}_{*}$
\end_inset

 denote the inverse operation.
 Thus,
 the definition of 
\begin_inset Formula $S_{\alpha+1}^{n+1}$
\end_inset

 in this case can be reworded as:
 
\begin_inset Formula $S_{\alpha+1}^{n+1}(\vec{x})\equiv[\vec{x}^{*}\in S^{n+1}A]$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
For every other triplet from 
\begin_inset Formula $V_{\alpha+1}$
\end_inset

,
 set 
\begin_inset Formula $S_{\alpha+1}^{n+1}(\vec{x})$
\end_inset

 to hold true.
\end_layout

\begin_layout Standard
Note that the first and second item in the definition do not contradict each other:
 If a tuple 
\begin_inset Formula $\vec{x}$
\end_inset

 fits both bullet points,
 then either all its elements are in 
\begin_inset Formula $A$
\end_inset

,
 in which case the definition of good sequence ensures that there is agreement between both possible definitions of 
\begin_inset Formula $S_{\alpha+1}^{n+1}(\vec{x}),$
\end_inset

or one of its elements is 
\begin_inset Formula $w=w^{n+1}(\beta,mA,A,\dots,S^{n+1}A)$
\end_inset

,
 in which case 
\begin_inset Formula $S_{\gamma}^{n+1}(\vec{x})$
\end_inset

 would have defined to agree with the second bullet point for 
\begin_inset Formula $\gamma$
\end_inset

 the smallest ordinal such that 
\begin_inset Formula $w\in V_{\gamma}$
\end_inset

.
\begin_inset Note Note
status open

\begin_layout Plain Layout
i think there's a small amount of checking to do here,
 but i'll postpone it.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This induces a well-defined relation 
\begin_inset Formula $S^{n+1}$
\end_inset

,
 whose main defining properties are as follows:
\end_layout

\begin_layout Lemma
Provably in 
\begin_inset Formula $\ZFniptc$
\end_inset

,
 
\begin_inset Formula $\neg S^{n}(\vec{x})$
\end_inset

 iff 
\begin_inset Formula $\forall_{y}S^{n+1}(\vec{x},y)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:sflex_general"

\end_inset

Let 
\begin_inset Formula $M$
\end_inset

 be a model of 
\begin_inset Formula $\ZFniptc$
\end_inset

.
 Let 
\begin_inset Formula $A$
\end_inset

 be a finite subset of 
\begin_inset Formula $M$
\end_inset

,
 and suppose that we wish to find an element 
\begin_inset Formula $w$
\end_inset

 that relates to all elements of 
\begin_inset Formula $A$
\end_inset

 with regard to the predicates 
\begin_inset Formula $S^{0},\dots,S^{n+1}$
\end_inset

 in a prescribed manner.
 The following is a sufficient condition for there to exist an element of 
\begin_inset Formula $M$
\end_inset

 satisfying this prescription and 
\begin_inset Formula $\in$
\end_inset

-incomparable to 
\begin_inset Formula $A$
\end_inset

:
 For every 
\begin_inset Formula $0\leq i\leq n$
\end_inset

,
 the prescription satisfies the rule:
 
\begin_inset Quotes eld
\end_inset

For all 
\begin_inset Formula $\vec{x}\in A^{i+2}$
\end_inset

 with 
\begin_inset Formula $\neg S^{i}(\vec{x})$
\end_inset

,
 we have 
\begin_inset Formula $S^{i+1}(\vec{x},w)$
\end_inset


\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
These two lemmas are sufficient for a construction similar to the one used in the proof of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 to go through.
 If we have a 
\begin_inset Formula $0'$
\end_inset

-computable model 
\begin_inset Formula $D$
\end_inset

 of 
\begin_inset Formula $T^{n}\upto(S^{i},\dots,S^{n})$
\end_inset

,
 we execute a very similar algorithm to the one used in the proof of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "thm:main"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 to construct a structure 
\begin_inset Formula $M$
\end_inset

 implementing the predicates 
\begin_inset Formula $S^{i+1},\dots,S^{n}$
\end_inset

,
 with the following changes:
\end_layout

\begin_layout Itemize
The sanity checks performed when adding a new element 
\begin_inset Formula $m$
\end_inset

 to 
\begin_inset Formula $M$
\end_inset

 are changed to:
 For every 
\begin_inset Formula $i\leq j<n$
\end_inset

,
 and for every 
\begin_inset Formula $j+2$
\end_inset

-uple 
\begin_inset Formula $\vec{a}$
\end_inset

 of elements already in 
\begin_inset Formula $M$
\end_inset

,
 if 
\begin_inset Formula $M\vDash\neg S^{j}(\vec{a})$
\end_inset

 then it must be the case that 
\begin_inset Formula $M\vDash S^{j+1}(\vec{a},m)$
\end_inset

,
 and
\end_layout

\begin_layout Itemize
When finding a new element of 
\begin_inset Formula $D$
\end_inset

 to match to a pre-existing element of 
\begin_inset Formula $M$
\end_inset

,
 the relations 
\begin_inset Formula $S^{i+1},\dots,S^{n}$
\end_inset

 are prescribed as given by 
\begin_inset Formula $M$
\end_inset

 and its prior existing matchings to elements of 
\begin_inset Formula $D$
\end_inset

,
 and the relation 
\begin_inset Formula $S^{i}$
\end_inset

 is prescribed as always holding for tuples containing the new element.
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:sflex_general"

\end_inset

 guarantees that such an element of 
\begin_inset Formula $D$
\end_inset

 exists,
 because for example such an element exists that also satisfies 
\begin_inset Formula $S^{0},\dots,S^{i-1}$
\end_inset

 holding for all tuples containing the new element.
\end_layout

\begin_layout Standard
Routine checking will show that this algorithm constructs the desired structure 
\begin_inset Formula $M$
\end_inset

.
 This checking is not too burdensome,
 as the main technical load of the algorithm is in the priority argument,
 which remains completely unchanged.
 This completes the proof.
\end_layout

\end_deeper
\begin_layout Standard
As explained in the introduction,
 we obtain the following Corollary:
\end_layout

\begin_layout Corollary*
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand ref
reference "cor:nonstdpin"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset


\end_layout

\end_inset

For every 
\begin_inset Formula $n$
\end_inset

,
 there is a theory definitionally equivalent to 
\begin_inset Formula $\mathsf{PA}$
\end_inset

 plus 
\begin_inset Quotes eld
\end_inset

all true 
\begin_inset Formula $\Pi_{n}$
\end_inset

 sentences
\begin_inset Quotes erd
\end_inset

 that admits a computable non-standard model.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "bibliography"
options "plain"
encoding "default"

\end_inset


\end_layout

\end_body
\end_document
