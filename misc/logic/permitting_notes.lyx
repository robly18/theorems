#LyX 2.4 created this file. For more info see https://www.lyx.org/
\lyxformat 620
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{fullpage}
\usepackage{tikz}
\usepackage{braket}
\end_preamble
\use_default_options true
\begin_modules
duarte_theorems
enumitem
\end_modules
\maintain_unincluded_children no
\language english
\language_package default
\inputencoding auto-legacy
\fontencoding auto
\font_roman "lmodern" "default"
\font_sans "lmss" "default"
\font_typewriter "lmtt" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_roman_osf false
\font_sans_osf false
\font_typewriter_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\float_alignment class
\paperfontsize default
\spacing single
\use_hyperref false
\papersize letter
\use_geometry false
\use_package amsmath 2
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_formatted_ref 0
\use_minted 0
\use_lineno 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tablestyle default
\tracking_changes false
\output_changes false
\change_bars false
\postpone_fragile_content false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\docbook_table_output 0
\docbook_mathml_prefix 1
\end_header

\begin_body

\begin_layout Title
Notes on the Permitting Method
\end_layout

\begin_layout Author
Duarte Maia
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "C:/Users/gaming/Desktop/theorems/misc/lyx/macros_logic.lyx"
literal "false"

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Some notes for myself about the Permitting Method.
 I'm trying to learn 
\begin_inset Formula $\Delta_{2}$
\end_inset

 permitting,
 and I realized that I barely recall c.e.
\begin_inset space \space{}
\end_inset

permitting to begin with.
\end_layout

\begin_layout Standard
First,
 I will review Chapter V.3 of Soare 
\begin_inset CommandInset citation
LatexCommand cite
key "soare1"
literal "false"

\end_inset

.
 Then,
 I will try to understand the argument used in 
\begin_inset CommandInset citation
LatexCommand cite
key "miller"
literal "false"

\end_inset

.
\end_layout

\begin_layout Section
C.e.
 Permitting
\end_layout

\begin_layout Subsection
Theorem 3.2 and Exercise 5.6
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:1"

\end_inset

For any nonrecursive c.e.
\begin_inset space \space{}
\end_inset

set 
\begin_inset Formula $B$
\end_inset

 there is a simple nonhypersimple set 
\begin_inset Formula $A$
\end_inset

 of degree 
\begin_inset Formula $B$
\end_inset

.
\end_layout

\begin_layout Theorem
First,
 I need to recall the definitions involved.
\end_layout

\begin_layout Definition
A set 
\begin_inset Formula $A\subseteq\N$
\end_inset

 is 
\emph on
simple
\emph default
 if it is c.e.
\begin_inset space \space{}
\end_inset

,
 coinfinite,
 and every infinite c.e.
\begin_inset space \space{}
\end_inset

set 
\begin_inset Formula $W_{e}$
\end_inset

 intersects 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
A set 
\begin_inset Formula $A\subseteq\N$
\end_inset

 is 
\emph on
hypersimple
\emph default
 if it is c.e.
\begin_inset space \space{}
\end_inset

,
 coinfinite,
 and,
 for every computable sequence 
\begin_inset Formula $\{F_{n}\}_{n\in\N}$
\end_inset

 of (strongly) finite disjoint sets,
 some 
\begin_inset Formula $F_{n}$
\end_inset

 is entirely contained in 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Standard
For our purposes,
 the following equivalent definition is more convenient.
\end_layout

\begin_layout Proposition
A set 
\begin_inset Formula $A\subseteq\N$
\end_inset

 is hypersimple iff it is c.e,
 has infinite complement and,
 if 
\begin_inset Formula $a(0),a(1),\dots$
\end_inset

 is the increasing enumeration of 
\begin_inset Formula $A^{c}$
\end_inset

,
 there is no computable function 
\begin_inset Formula $f\colon\N\to\N$
\end_inset

 satisfying 
\begin_inset Formula $f\geq a$
\end_inset

.
\end_layout

\begin_layout Proof
(
\begin_inset Formula $\rightarrow$
\end_inset

) Let 
\begin_inset Formula $f$
\end_inset

 be a computable function,
 and suppose that 
\begin_inset Formula $f\geq a$
\end_inset

.
 This means that,
 for every value of 
\begin_inset Formula $x$
\end_inset

,
 there is some 
\begin_inset Formula $a\in A^{c}\cap\interval x{f(x)}$
\end_inset

.
 Thus,
 we can construct a disjoint computable sequence of finite disjoint sets 
\begin_inset Formula $F_{n}=\interval{a_{n}}{b_{n}}$
\end_inset

 via the recurrence:
 
\begin_inset Formula $a_{0}$
\end_inset

 arbitrary,
 
\begin_inset Formula $b_{n}=f(a_{n})$
\end_inset

,
 
\begin_inset Formula $a_{n+1}=b_{n}+1$
\end_inset

.
 If 
\begin_inset Formula $A$
\end_inset

 is hypersimple,
 there will be some 
\begin_inset Formula $F_{n}$
\end_inset

 containing no element of 
\begin_inset Formula $A^{c}$
\end_inset

,
 contradicting the existence of 
\begin_inset Formula $f$
\end_inset

.
\end_layout

\begin_layout Proof
(
\begin_inset Formula $\leftarrow$
\end_inset

) Suppose 
\begin_inset Formula $\{F_{n}\}_{n\in\N}$
\end_inset

 is a computable sequence of disjoint finite sets,
 all of which contain an element of 
\begin_inset Formula $A^{c}$
\end_inset

.
 Then,
 we can majorize 
\begin_inset Formula $a(n)$
\end_inset

 via 
\begin_inset Formula $f(n)=\max_{i<n}\max F_{i}$
\end_inset

.
\end_layout

\begin_layout Standard
Now,
 let us prove that there is a simple non-hypersimple set.
 The resulting set will turn out to have degree 
\begin_inset Formula $0'$
\end_inset

.
 We will then adapt this proof to build such a set with arbitrary noncomputable c.e.
\begin_inset space \space{}
\end_inset

degree.
\end_layout

\begin_layout Proposition
There is a simple non-hypersimple set.
\end_layout

\begin_layout Proof
Consider,
 in parallel,
 enumerating elements of each c.e.
\begin_inset space \space{}
\end_inset

set 
\begin_inset Formula $W_{e}$
\end_inset

.
 For each such set,
 if we find some 
\begin_inset Formula $x\geq2e$
\end_inset

,
 enumerate it and stop looking at 
\begin_inset Formula $W_{e}$
\end_inset

.
\end_layout

\begin_layout Proof
This works because the resulting set is obviously simple,
 but between 
\begin_inset Formula $0$
\end_inset

 and 
\begin_inset Formula $2e$
\end_inset

 there will always be at most 
\begin_inset Formula $e$
\end_inset

 elements,
 meaning that 
\begin_inset Formula $a(n)\leq2n$
\end_inset

.
\end_layout

\begin_layout Proposition
\begin_inset CommandInset label
LatexCommand label
name "prop:Aeqv0'"

\end_inset

The set 
\begin_inset Formula $A$
\end_inset

 described above has degree 
\begin_inset Formula $0'$
\end_inset

.
\end_layout

\begin_layout Proof
Let 
\begin_inset Formula $P$
\end_inset

 be a program.
 We will show how to tell whether 
\begin_inset Formula $P$
\end_inset

 halts by making use of 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Proof
Define 
\begin_inset Formula $W_{e}$
\end_inset

 to be the following c.e.
\begin_inset space \space{}
\end_inset

set.
 First,
 run the program 
\begin_inset Formula $P$
\end_inset

 until it halts.
 Then,
 find the first element 
\begin_inset Formula $x\geq2e$
\end_inset

 not yet in 
\begin_inset Formula $A$
\end_inset

,
 and enumerate it into into 
\begin_inset Formula $W_{e}$
\end_inset

.
\end_layout

\begin_layout Proof
Now,
 let's say that we are given 
\begin_inset Formula $A$
\end_inset

 as an oracle.
 Find the first number 
\begin_inset Formula $y$
\end_inset

 such that 
\begin_inset Formula $y\geq2e$
\end_inset

 and 
\begin_inset Formula $y\notin A$
\end_inset

,
 and then run the enumeration of 
\begin_inset Formula $A$
\end_inset

 until all elements up to 
\begin_inset Formula $y$
\end_inset

 (inclusive) have been correctly enumerated.
 Finally,
 check if 
\begin_inset Formula $P$
\end_inset

 has halted by this point.
 If it has not,
 then we know it never will,
 as otherwise it would have been the case that 
\begin_inset Formula $y$
\end_inset

 would eventually be enumerated into 
\begin_inset Formula $A$
\end_inset

,
 which it has not.
\end_layout

\begin_layout Standard
Based on the proof of Proposition 
\begin_inset CommandInset ref
LatexCommand ref
reference "prop:Aeqv0'"

\end_inset

,
 we see that the reason why the set we construct has degree equal to that of the Halting problem is because our knowledge of where an element of 
\begin_inset Formula $W_{e}$
\end_inset

 will be added (if it ever is) is too reliable.
 In other words,
 the fact that we look for an element 
\begin_inset Formula $x\geq2e$
\end_inset

 is the root cause of the issue,
 and would remain an issue if 
\begin_inset Formula $2e$
\end_inset

 were replaced – or even bounded from above – by a computable function 
\begin_inset Formula $f(e)$
\end_inset

,
 regardless of how fast it grows.
 Thus,
 if the construction can be adapted to build weaker simple-non-hypersimple sets,
 a possibly promising course of action would be to somehow make (computable) use of a fast-growing function (i.e.
\begin_inset space \space{}
\end_inset

faster than computable).
 However,
 I don't think this could be adapted into a construction:
 If 
\begin_inset Formula $g$
\end_inset

 were such a function,
 we would still need to be able to test in finite time whether 
\begin_inset Formula $x\geq g(e)$
\end_inset

,
 which means 
\begin_inset Formula $\rinterval{g(e)}{\infty}$
\end_inset

 is uniformly c.e.
\begin_inset space \space{}
\end_inset

and so we can computably bound 
\begin_inset Formula $g$
\end_inset

 from above,
 a contradiction.
\end_layout

\begin_layout Standard
Let's try an alternate approach.
 Perhaps the issue is that,
 for a given 
\begin_inset Formula $W_{e}$
\end_inset

,
 we have a fixed (and computable) value,
 in this case 
\begin_inset Formula $2e$
\end_inset

,
 for which we know that,
 if 
\begin_inset Formula $W_{e}$
\end_inset

 adds an element 
\begin_inset Formula $x$
\end_inset

 to 
\begin_inset Formula $A$
\end_inset

,
 it'll be the first element of 
\begin_inset Formula $W_{e}$
\end_inset

 our algorithm finds above 
\begin_inset Formula $2e$
\end_inset

.
 Perhaps we had best make this 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $2e$
\end_inset


\begin_inset Quotes erd
\end_inset

 value increase in time.
 In other words,
 to break our strategy to use 
\begin_inset Formula $A$
\end_inset

 to tell whether a program 
\begin_inset Formula $P$
\end_inset

 halts,
 we make it so that,
 the longer 
\begin_inset Formula $P$
\end_inset

 halts,
 the further forward the corresponding 
\begin_inset Formula $W_{e(P)}$
\end_inset

 will have to add its element,
 which means that we have no 
\shape italic
a priori
\shape default
 place to check to tell if 
\begin_inset Formula $P$
\end_inset

 will ever halt.
\end_layout

\begin_layout Standard
This alternate approach comes with its own issue:
 There is no computable function that grows slowly to serve as the 
\begin_inset Quotes eld
\end_inset

bound
\begin_inset Quotes erd
\end_inset

 above.
 The following propositions hint at the problem:
\end_layout

\begin_layout Proposition
If 
\begin_inset Formula $f\colon\N\to\N$
\end_inset

 is computable,
 unbounded,
 and increasing,
 there is an infinite c.e.
\begin_inset space \space{}
\end_inset

set 
\begin_inset Formula $W_{e}$
\end_inset

 (in fact,
 
\begin_inset Formula $W_{e}=\N$
\end_inset

) such that every element 
\begin_inset Formula $x\in W_{e}$
\end_inset

 is enumerated at a time 
\begin_inset Formula $t(x)$
\end_inset

 that satisfies 
\begin_inset Formula $f(t(x))>x$
\end_inset

.
\end_layout

\begin_layout Proof
Let 
\begin_inset Formula $W_{e}$
\end_inset

 be computed as follows.
 Track the growth of 
\begin_inset Formula $f(t)$
\end_inset

.
 Whenever 
\begin_inset Formula $f(t)$
\end_inset

 increases to a new value 
\begin_inset Formula $b$
\end_inset

,
 enumerate all elements of 
\begin_inset Formula $\rinterval 0b$
\end_inset

 into 
\begin_inset Formula $W_{e}$
\end_inset

.
\end_layout

\begin_layout Proposition
Let 
\begin_inset Formula $f\colon\N\to\N$
\end_inset

 be computable,
 unbounded,
 and increasing,
 and let 
\begin_inset Formula $A$
\end_inset

 be a c.e.
\begin_inset space \space{}
\end_inset

set for which every element added at stage 
\begin_inset Formula $t$
\end_inset

 is at least 
\begin_inset Formula $f(t)$
\end_inset

.
 Then,
 
\begin_inset Formula $A$
\end_inset

 must fail to be simple.
\end_layout

\begin_layout Proof
In this case,
 
\begin_inset Formula $A$
\end_inset

 is computable:
 To tell if 
\begin_inset Formula $x\in A$
\end_inset

,
 find a stage 
\begin_inset Formula $t$
\end_inset

 for which 
\begin_inset Formula $f(t)>x$
\end_inset

 and run the enumeration of 
\begin_inset Formula $A$
\end_inset

 until this time.
\end_layout

\begin_layout Standard
This leads us to permitting.
 We need a slow-growing function to serve the purpose of bounding added elements from below.
 This function needs to grow too slow to be computable,
 and yet it needs to be computable enough to allow us to use it in the construction of a c.e.
\begin_inset space \space{}
\end_inset

set.
 To be more precise,
 the property we will require is that 
\begin_inset Formula $f(t)$
\end_inset

 grows too slow to be computable,
 but can be uniformly approximated from above by computable functions 
\begin_inset Formula $f_{s}(t)$
\end_inset

,
 in the sense 
\begin_inset Formula $f_{s}(t)\searrow_{s}f(t)$
\end_inset

.
 This turns out to be precisely equivalent to having the same degree as a c.e.
\begin_inset space \space{}
\end_inset

set:
\end_layout

\begin_layout Definition
A 
\emph on
slow c.e.
\begin_inset space \space{}
\end_inset

order
\emph default
 is a function 
\begin_inset Formula $f\colon\N\to\N$
\end_inset

 that is unbounded and increasing (order),
 such that for any computable order 
\begin_inset Formula $g$
\end_inset

 we have 
\begin_inset Formula $f<g$
\end_inset

 infinitely often (slow),
 and for which we have uniform computable approximations from above 
\begin_inset Formula $f_{s}(t)\searrow f(t)$
\end_inset

 (c.e.).
\end_layout

\begin_layout Definition
A slow c.e.
 order is said to be 
\emph on
approximable
\emph default
 if any order 
\begin_inset Formula $g\leq f$
\end_inset

 computes 
\begin_inset Formula $f$
\end_inset

.
\end_layout

\begin_layout Proposition
\begin_inset CommandInset label
LatexCommand label
name "prop:dpm"

\end_inset

There is a degree-preserving map from noncomputable c.e.
\begin_inset space \space{}
\end_inset

sets to slow c.e.
\begin_inset space \space{}
\end_inset

orders and vice-versa.
 Every slow c.e.
\begin_inset space \space{}
\end_inset

order obtained in this manner is approximable,
 but there are non-approximable slow c.e.
\begin_inset space \space{}
\end_inset

orders.
\end_layout

\begin_layout Proof
Given a noncomputable c.e.
\begin_inset space \space{}
\end_inset

set 
\begin_inset Formula $C$
\end_inset

,
 enumerated 
\begin_inset Formula $c_{0}$
\end_inset

,
\begin_inset Formula $c_{1}$
\end_inset

,
 
\begin_inset Formula $\dots$
\end_inset

,
 consider the function 
\begin_inset Formula $f(t)$
\end_inset

 that,
 given a stage 
\begin_inset Formula $t$
\end_inset

,
 outputs the length of agreement of 
\begin_inset Formula $\{c_{0},\dots,c_{t}\}\upto t$
\end_inset

 with 
\begin_inset Formula $C\upto t$
\end_inset

.
 This is obviously an order.
 If it were not a slow order,
 there would be a computable order bounding 
\begin_inset Formula $f$
\end_inset

 from below which could then be used to compute 
\begin_inset Formula $C$
\end_inset

,
 contradicting the assumption that 
\begin_inset Formula $C$
\end_inset

 is noncomputable.
 Finally,
 
\begin_inset Formula $f$
\end_inset

 can be approximated from above by 
\begin_inset Formula $f_{s}(t)\colon$
\end_inset

the length of agreement between 
\begin_inset Formula $\{c_{0},\dots,c_{t}\}\upto t$
\end_inset

 and 
\begin_inset Formula $\{c_{0},\dots,c_{s}\}\upto t$
\end_inset

.
 It is evident that 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $C$
\end_inset

 compute each other.
\end_layout

\begin_layout Proof
Given a slow c.e.
\begin_inset space \space{}
\end_inset

order 
\begin_inset Formula $f$
\end_inset

,
 let 
\begin_inset Formula $C$
\end_inset

 be its supergraph 
\begin_inset Formula $\{\braket{x,y}\mid y\geq f(x)\}$
\end_inset

.
 This is c.e.
\begin_inset space \space{}
\end_inset

because it is a countable union of computable sets (the supergraphs of the 
\begin_inset Formula $f_{s}$
\end_inset

).
 It is evident that 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $C$
\end_inset

 compute each other,
 and in particular 
\begin_inset Formula $C$
\end_inset

 is noncomputable.
\end_layout

\begin_layout Proof
If a slow c.e.
\begin_inset space \space{}
\end_inset

order 
\begin_inset Formula $f$
\end_inset

 is obtained as the length-of-agreement function of 
\begin_inset Formula $C$
\end_inset

,
 then any order 
\begin_inset Formula $g\leq f$
\end_inset

 computes 
\begin_inset Formula $C$
\end_inset

 for the same reason that 
\begin_inset Formula $f$
\end_inset

 does.
 Thus,
 the orders obtained in this manner are always approximable.
\end_layout

\begin_layout Proof
Finally,
 let us show that there are non-approximable slow c.e.
\begin_inset space \space{}
\end_inset

orders.
 Let 
\begin_inset Formula $C$
\end_inset

 be a noncomputable c.e.
\begin_inset space \space{}
\end_inset

set,
 and let 
\begin_inset Formula $f(x)$
\end_inset

 be its associated order.
 Without loss of generality,
 assume that 
\begin_inset Formula $f(0)=0$
\end_inset

 and 
\begin_inset Formula $f(x+1)-f(x)$
\end_inset

 is always either 0 or 1,
 and likewise for the approximands 
\begin_inset Formula $f_{s}$
\end_inset

:
 This assumption can be made because there is an obvious uniform way to turn an order into a smaller order with this property,
 and this preserves c.e.-ness and slowness,
 as well as still allowing us to compute 
\begin_inset Formula $C$
\end_inset

.
 Now,
 We construct another order,
 
\begin_inset Formula $\bar{f}$
\end_inset

,
 which has degree 
\begin_inset Formula $0'$
\end_inset

,
 but may be bounded from below by something computed from 
\begin_inset Formula $f$
\end_inset

.
 Here is the idea:
 Given an arbitrary c.e.
\begin_inset space \space{}
\end_inset

set 
\begin_inset Formula $A$
\end_inset

,
 we encode it into a 
\begin_inset Quotes eld
\end_inset

stretched
\begin_inset Quotes erd
\end_inset

 version of 
\begin_inset Formula $f$
\end_inset

,
 by first setting 
\begin_inset Formula $\bar{f}(2x)=f(x)$
\end_inset

,
 and then encoding 
\begin_inset Formula $A$
\end_inset

 into the steps where 
\begin_inset Formula $f$
\end_inset

 increases.
 More precisely:
 If 
\begin_inset Formula $f(x)=f(x+1)$
\end_inset

,
 we set 
\begin_inset Formula $\bar{f}(2x+1)$
\end_inset

 equal to this common value.
 If 
\begin_inset Formula $f(x)\to f(x+1)$
\end_inset

 is the 
\begin_inset Formula $n$
\end_inset

-th increase of the function (and it goes from 
\begin_inset Formula $n$
\end_inset

 to 
\begin_inset Formula $n+1$
\end_inset

 by assumption),
 we set 
\begin_inset Formula $\bar{f}(2x+1)$
\end_inset

 to be the lowest of these if 
\begin_inset Formula $n\in A$
\end_inset

 and the highest if not.
 It requires some proof to see that the resulting order is still c.e.;
 to this effect,
 we adapt the sequence 
\begin_inset Formula $f_{s}$
\end_inset

 into 
\begin_inset Formula $\bar{f_{s}}$
\end_inset

 in the obvious way:
 If 
\begin_inset Formula $f_{s}(x)\to f_{s}(x+1)$
\end_inset

 is the 
\begin_inset Formula $n$
\end_inset

-th increase of 
\begin_inset Formula $f_{s}$
\end_inset

 we set 
\begin_inset Formula $\bar{f}_{s}(2x+1)$
\end_inset

 to be 
\begin_inset Formula $n+1$
\end_inset

 unless we have seen 
\begin_inset Formula $n\in A$
\end_inset

 by stage 
\begin_inset Formula $s$
\end_inset

,
 in which case we set it to be 
\begin_inset Formula $n$
\end_inset

.
 The result,
 then,
 is a slow c.e.
 order 
\begin_inset Formula $\bar{f}$
\end_inset

 that of degree 
\begin_inset Formula $C\oplus A$
\end_inset

,
 that admits a lower bound order of degree 
\begin_inset Formula $C$
\end_inset

.
\end_layout

\begin_layout Remark
As part of the proof of Proposition 
\begin_inset CommandInset ref
LatexCommand ref
reference "prop:dpm"

\end_inset

,
 we obtain that an order is c.e.
\begin_inset space \space{}
\end_inset

iff its supergraph is c.e.
\end_layout

\begin_layout Standard
We are now ready to prove:
\end_layout

\begin_layout Proposition
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:1"

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "prop:snhs"

\end_inset

Let 
\begin_inset Formula $C$
\end_inset

 be a noncomputable c.e.
\begin_inset space \space{}
\end_inset

set.
 Then,
 there is a simple non-hypersimple set 
\begin_inset Formula $A$
\end_inset

 of same Turing degree as 
\begin_inset Formula $C$
\end_inset

.
\end_layout

\begin_layout Proof
Let 
\begin_inset Formula $f\equiv\lim f_{s}$
\end_inset

 be the slow c.e.
\begin_inset space \space{}
\end_inset

order associated to 
\begin_inset Formula $C$
\end_inset

.
 We construct 
\begin_inset Formula $A$
\end_inset

 by performing the following two tasks in parallel for every 
\begin_inset Formula $e\in\N$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Itemize
Enumerate the elements of 
\begin_inset Formula $W_{e}$
\end_inset

.
 If we find an element 
\begin_inset Formula $y\geq3e$
\end_inset

,
 
\begin_inset Formula $y\in W_{e}$
\end_inset

 enumerated at some time 
\begin_inset Formula $t$
\end_inset

 such that 
\begin_inset Formula $y\geq f(t)$
\end_inset

,
 we enumerate 
\begin_inset Formula $y$
\end_inset

 into 
\begin_inset Formula $A$
\end_inset

 and halt this process;
\end_layout

\begin_layout Itemize
Enumerate the elements of 
\begin_inset Formula $C$
\end_inset

.
 At the moment that an element 
\begin_inset Formula $x$
\end_inset

 is enumerated into 
\begin_inset Formula $C$
\end_inset

,
 enumerate into 
\begin_inset Formula $A$
\end_inset

 the 
\begin_inset Formula $3x$
\end_inset

-th currently free element.
\end_layout

\end_deeper
\begin_layout Proof
Let us reword the first item in the above algorithm.
 What we mean by this is that we keep track of the elements 
\begin_inset Formula $y\in W_{e}$
\end_inset

 above 
\begin_inset Formula $3e$
\end_inset

,
 and the time 
\begin_inset Formula $t_{y}$
\end_inset

 at which they were enumerated.
 Then,
 we attempt to compare them by seeing if the pair 
\begin_inset Formula $\braket{t_{y},y}$
\end_inset

 is ever enumerated into the supergraph of 
\begin_inset Formula $f$
\end_inset

.
 We also present another interpretation in Remark 
\begin_inset CommandInset ref
LatexCommand ref
reference "rmk:supergraph"

\end_inset

 below.
 Now,
 let us prove that the resulting set 
\begin_inset Formula $A$
\end_inset

 has the required properties.
\end_layout

\begin_deeper
\begin_layout Itemize
(c.e.) Obvious
\end_layout

\begin_layout Itemize
(coinfinite + not hypersimple) Since we add at most 
\begin_inset Formula $2e$
\end_inset

 elements below 
\begin_inset Formula $3e$
\end_inset

,
 the 
\begin_inset Formula $n$
\end_inset

-th element of the complement is at most 
\begin_inset Formula $3n$
\end_inset

.
\end_layout

\begin_layout Itemize
(simple) Let 
\begin_inset Formula $W_{e}$
\end_inset

 be infinite,
 but suppose that no element 
\begin_inset Formula $y\in W_{e}$
\end_inset

 is ever enumerated into 
\begin_inset Formula $A$
\end_inset

.
 Then,
 it must be the case that for every value of 
\begin_inset Formula $t$
\end_inset

 for which an element 
\begin_inset Formula $y\geq3e$
\end_inset

 is enumerated into 
\begin_inset Formula $W_{e}$
\end_inset

 we have 
\begin_inset Formula $f(t)>y$
\end_inset

.
 This provides the following computable bound for 
\begin_inset Formula $f$
\end_inset

:
 Given 
\begin_inset Formula $t\in\N$
\end_inset

,
 let 
\begin_inset Formula $t'$
\end_inset

 be the some time below 
\begin_inset Formula $t$
\end_inset

 for which an element 
\begin_inset Formula $y\geq3e$
\end_inset

 is enumerated into 
\begin_inset Formula $W_{e}$
\end_inset

.
 Then,
 
\begin_inset Formula $f(t)\geq f(t')>y$
\end_inset

.
 We define a lower bound to 
\begin_inset Formula $f(t)$
\end_inset

 as the largest such 
\begin_inset Formula $y$
\end_inset

.
 The fact that 
\begin_inset Formula $W_{e}$
\end_inset

 is infinite is used to prove that the resulting computable function is unbounded.
\end_layout

\begin_layout Itemize
(computed by 
\begin_inset Formula $C$
\end_inset

) Note that 
\begin_inset Formula $C$
\end_inset

 computes 
\begin_inset Formula $f$
\end_inset

.
 To tell whether some number 
\begin_inset Formula $x$
\end_inset

 is in 
\begin_inset Formula $A$
\end_inset

 we need only run the simulation until 
\begin_inset Formula $f(t)$
\end_inset

 is greater than 
\begin_inset Formula $x$
\end_inset

,
 followed by waiting until all elements of 
\begin_inset Formula $C$
\end_inset

 below 
\begin_inset Formula $x/3$
\end_inset

 have been enumerated into 
\begin_inset Formula $C$
\end_inset

.
\end_layout

\begin_layout Itemize
(computes 
\begin_inset Formula $C$
\end_inset

) To tell whether 
\begin_inset Formula $x\in C$
\end_inset

 using 
\begin_inset Formula $A$
\end_inset

,
 first find the 
\begin_inset Formula $3x$
\end_inset

-th element of 
\begin_inset Formula $A^{c}$
\end_inset

,
 say 
\begin_inset Formula $y$
\end_inset

,
 then run the simulation for 
\begin_inset Formula $A$
\end_inset

 until all elements below this one have been enumerated.
 If,
 by this point,
 
\begin_inset Formula $x$
\end_inset

 hasn't been enumerated into 
\begin_inset Formula $C$
\end_inset

,
 then it never will,
 as then 
\begin_inset Formula $y$
\end_inset

 would be enumerated into 
\begin_inset Formula $A$
\end_inset

 after all,
 a contradiction.
\end_layout

\end_deeper
\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rmk:supergraph"

\end_inset

Let 
\begin_inset Formula $f$
\end_inset

 be the order associated to 
\begin_inset Formula $C$
\end_inset

.
 Let us think on how we would check directly whether 
\begin_inset Formula $y\geq f(t)$
\end_inset

.
 This is the same as asking whether the length of agreement of 
\begin_inset Formula $\{c_{0},\dots,c_{t}\}\upto t$
\end_inset

 with 
\begin_inset Formula $C\upto t$
\end_inset

 is less than or equal to 
\begin_inset Formula $y$
\end_inset

.
 If 
\begin_inset Formula $y\geq t$
\end_inset

 this is obviously true,
 and otherwise it depends on whether someone will ever be enumerated into 
\begin_inset Formula $C$
\end_inset

 below 
\begin_inset Formula $y$
\end_inset

.
 Thus,
 we may check whether 
\begin_inset Formula $y\geq f(t)$
\end_inset

 by enumerating elements 
\begin_inset Formula $c_{t+1}$
\end_inset

,
 
\begin_inset Formula $c_{t+2}$
\end_inset

,
 
\begin_inset Formula $\dots$
\end_inset

 and replying 
\begin_inset Quotes eld
\end_inset

yes
\begin_inset Quotes erd
\end_inset

 if any of them is ever below 
\begin_inset Formula $y$
\end_inset

,
 which matches up with the standard description of the Permitting Method,
 with the enumeration of an element below 
\begin_inset Formula $y$
\end_inset

 providing 
\begin_inset Quotes eld
\end_inset

permission
\begin_inset Quotes erd
\end_inset

 to include 
\begin_inset Formula $y$
\end_inset

 into the set.
\end_layout

\begin_layout Standard
The coding step in the proof of Proposition 
\begin_inset CommandInset ref
LatexCommand ref
reference "prop:snhs"

\end_inset

 is actually unnecessary,
 though the proof becomes slightly more convoluted,
 and this happens at the cost of uniformity.
 We phrase it completely in terms of a slow approximable c.e.
\begin_inset space \space{}
\end_inset

order 
\begin_inset Formula $f$
\end_inset

,
 to distinguish from the standard approach that focuses on the c.e.
\begin_inset space \space{}
\end_inset

set 
\begin_inset Formula $C$
\end_inset

.
\end_layout

\begin_layout Proof
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Proposition 
\begin_inset CommandInset ref
LatexCommand ref
reference "prop:snhs"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset


\end_layout

\end_inset

We construct a c.e.
\begin_inset space \space{}
\end_inset

set 
\begin_inset Formula $A$
\end_inset

 by performing the following task in parallel for every 
\begin_inset Formula $e\in\N$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize
Enumerate the elements of 
\begin_inset Formula $W_{e}$
\end_inset

.
 If we find an element 
\begin_inset Formula $y\geq2e$
\end_inset

,
 
\begin_inset Formula $y\in W_{e}$
\end_inset

 enumerated at a time 
\begin_inset Formula $t$
\end_inset

 such that 
\begin_inset Formula $y\geq f(t)$
\end_inset

,
 we enumerate 
\begin_inset Formula $y$
\end_inset

 into 
\begin_inset Formula $A$
\end_inset

 and halt this process.
\end_layout

\end_deeper
\begin_layout Proof
As before,
 it is obvious that the resulting set is c.e,
 not hypersimple and coinfinite,
 and computed by 
\begin_inset Formula $f$
\end_inset

.
 It remains to prove that 
\begin_inset Formula $A$
\end_inset

 computes 
\begin_inset Formula $f$
\end_inset

.
 We will do this by using the assumption that 
\begin_inset Formula $f$
\end_inset

 is approximable,
 and hence using 
\begin_inset Formula $A$
\end_inset

 to compute a lower bound to 
\begin_inset Formula $f$
\end_inset

;
 I don't know of a way to get around this restriction.
\end_layout

\begin_layout Proof
Given 
\begin_inset Formula $x,y\in\N$
\end_inset

,
 define 
\begin_inset Formula $W_{h(x,y)}$
\end_inset

 as the following c.e.
\begin_inset space \space{}
\end_inset

set:
 First,
 check if 
\begin_inset Formula $f(x)\leq y$
\end_inset

.
 If this is ever found to be true,
 enumerate all the numbers between 
\begin_inset Formula $2h(x,y)$
\end_inset

 and 
\begin_inset Formula $4h(x,y)$
\end_inset

.
 We will show how this can be used to furnish an 
\begin_inset Formula $A$
\end_inset

-computable lower bound for 
\begin_inset Formula $f$
\end_inset

.
\end_layout

\begin_layout Proof
Given 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

,
 run the simulation until all elements of 
\begin_inset Formula $A$
\end_inset

 up to 
\begin_inset Formula $4h(x,y)$
\end_inset

 have been enumerated.
 Note that between 
\begin_inset Formula $2h(x,y)$
\end_inset

 and 
\begin_inset Formula $4h(x,y)$
\end_inset

 we have 
\begin_inset Formula $2h(x,y)+1$
\end_inset

 elements,
 so if 
\begin_inset Formula $f(x)\leq y$
\end_inset

 were to ever by found to be true,
 one of these new elements would have been enumerated into 
\begin_inset Formula $W_{h(x,y)}$
\end_inset

.
 Thus,
 if 
\begin_inset Formula $f(x)\leq y$
\end_inset

 has not yet been found to be true,
 one of two things happen:
 Either it will never be found to be true (Case 1),
 or by the time that it is found (say 
\begin_inset Formula $T$
\end_inset

),
 
\begin_inset Formula $W_{h(x,y)}$
\end_inset

 will not have permission to add an element to 
\begin_inset Formula $A$
\end_inset

,
 meaning that 
\begin_inset Formula $f(T)>2h(x,y)$
\end_inset

 (Case 2).
 In either case,
 we obtain a lower bound for 
\begin_inset Formula $f$
\end_inset

,
 though there is some nonuniformity in the process.
\end_layout

\begin_layout Proof
To be more precise,
 one of two cases occurs:
 Either the Case 2 occurs for infinitely many pairs 
\begin_inset Formula $(x,y)$
\end_inset

,
 or it occurs for finitely many such pairs.
\end_layout

\begin_deeper
\begin_layout Itemize
If Case 2 occurs infinitely many times,
 we construct an 
\begin_inset Formula $A$
\end_inset

-computable lower bound for 
\begin_inset Formula $f$
\end_inset

 as follows.
 In parallel for each pair 
\begin_inset Formula $(x,y)$
\end_inset

,
 we execute the above procedure until we find 
\begin_inset Formula $f(T)\geq2h(x,y)$
\end_inset

.
 This will give us an infinite 
\begin_inset Formula $A$
\end_inset

-computable sequence of pairs 
\begin_inset Formula $(t_{i},v_{i})$
\end_inset

 such that 
\begin_inset Formula $f(t_{i})\geq v_{i}$
\end_inset

,
 with 
\begin_inset Formula $v_{i}\to\infty$
\end_inset

 (and consequently also 
\begin_inset Formula $t_{i}\to\infty$
\end_inset

).
 This gives us a lower bound for 
\begin_inset Formula $f$
\end_inset

 as follows:
 Given a value of 
\begin_inset Formula $t$
\end_inset

,
 enumerate values 
\begin_inset Formula $(t_{i},v_{i})$
\end_inset

 until we find 
\begin_inset Formula $t_{i}\geq t$
\end_inset

.
 At this point,
 output the largest 
\begin_inset Formula $v_{j}$
\end_inset

 found strictly before now.
 This obviously provides an 
\begin_inset Formula $A$
\end_inset

-computable lower bound for 
\begin_inset Formula $f$
\end_inset

,
 and it is increasing with 
\begin_inset Formula $t$
\end_inset

.
 The only thing that requires checking is that it attains arbitrarily large values.
 For this purpose,
 given a value of 
\begin_inset Formula $y$
\end_inset

,
 find 
\begin_inset Formula $v_{i}>y$
\end_inset

,
 and consider the bound we obtain for 
\begin_inset Formula $t$
\end_inset

 greater than all 
\begin_inset Formula $t_{j}$
\end_inset

,
 
\begin_inset Formula $j\leq i$
\end_inset

.
\end_layout

\begin_layout Itemize
If Case 2 occurs finitely many times,
 then by hardcoding the exceptions into the following algorithm to remove the offending values of 
\begin_inset Formula $(x,y)$
\end_inset

 from consideration,
 we may assume that Case 1 is the only one to occur.
 In other words,
 for every value of 
\begin_inset Formula $(x,y)$
\end_inset

,
 we run the simulation of 
\begin_inset Formula $A$
\end_inset

 until all elements up to 
\begin_inset Formula $4f(x,y)$
\end_inset

 have been enumerated,
 and query if we've found 
\begin_inset Formula $f(x)\leq y$
\end_inset

 to be true until now.
 Modulo the finite number of exceptions,
 the resulting answer will be truthful,
 and so 
\begin_inset Formula $A$
\end_inset

 computes the supergraph of 
\begin_inset Formula $f$
\end_inset

,
 and so computes 
\begin_inset Formula $f$
\end_inset

 itself.
\end_layout

\end_deeper
\begin_layout Proof
In either case,
 
\begin_inset Formula $A$
\end_inset

 computes 
\begin_inset Formula $f$
\end_inset

,
 and the proof is complete.
\end_layout

\begin_layout Subsection
Exercise 3.5
\end_layout

\begin_layout Definition
A c.e.
\begin_inset space \space{}
\end_inset

set 
\begin_inset Formula $A$
\end_inset

 is said to be 
\emph on
semicreative
\emph default
 if there is a recursive function 
\begin_inset Formula $g$
\end_inset

 such that,
 for every 
\begin_inset Formula $W_{x}\subseteq A^{c}$
\end_inset

,
 we have 
\begin_inset Formula $W_{g(x)}\subseteq A^{c}$
\end_inset

 but 
\begin_inset Formula $W_{g(x)}\nsubseteq W_{x}$
\end_inset

.
\end_layout

\begin_layout Theorem
There is a semicreative set in every c.e.
\begin_inset space \space{}
\end_inset

degree.
\end_layout

\begin_layout Proof
The idea behind this proof is that,
 in order to create a semicreative set,
 we can satisfy the condition on 
\begin_inset Formula $W_{x}$
\end_inset

 separately for each value of 
\begin_inset Formula $x$
\end_inset

,
 by 
\begin_inset Quotes eld
\end_inset

reserving
\begin_inset Quotes erd
\end_inset

 a row 
\begin_inset Formula $\{x\}\times\omega$
\end_inset

 to be dedicated to 
\begin_inset Formula $W_{x}$
\end_inset

 specifically.
\end_layout

\begin_layout Proof
Let 
\begin_inset Formula $f$
\end_inset

 be a slow c.e.
\begin_inset space \space{}
\end_inset

order.
 To determine row 
\begin_inset Formula $x$
\end_inset

 of 
\begin_inset Formula $A$
\end_inset

,
 we enumerate the points of the section 
\begin_inset Formula $W_{x}\cap(\{x\}\times\omega)$
\end_inset

 and look for an element 
\begin_inset Formula $\braket{x,y}$
\end_inset

 enumerated at time 
\begin_inset Formula $t$
\end_inset

 such that 
\begin_inset Formula $f(t)\leq y$
\end_inset

.
 If we ever find one,
 we enumerate it into 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Proof
The resulting set is 
\begin_inset Formula $f$
\end_inset

-computable because,
 to check whether 
\begin_inset Formula $\braket{x,y}$
\end_inset

 is in 
\begin_inset Formula $A$
\end_inset

,
 we need only find some time 
\begin_inset Formula $t$
\end_inset

 for which 
\begin_inset Formula $f(t)>y$
\end_inset

 and run the above simulation until this time.
 It is semicreative because,
 if 
\begin_inset Formula $W_{x}\subseteq A^{c}$
\end_inset

,
 this implies that nothing was ever added to the 
\begin_inset Formula $x$
\end_inset

-th row of 
\begin_inset Formula $A$
\end_inset

,
 meaning that 
\begin_inset Formula $W_{g(x)}=\{x\}\times\omega$
\end_inset

 satisfies the desired condition.
\end_layout

\begin_layout Proof
Finally,
 let's show that the resulting set computes 
\begin_inset Formula $f$
\end_inset

.
 First,
 it would be quite easy to directly encode 
\begin_inset Formula $f$
\end_inset

 into 
\begin_inset Formula $A$
\end_inset

;
 we could,
 for example,
 reserve one of the rows to be the supergraph of 
\begin_inset Formula $f$
\end_inset

,
 and move all the other rows down by one.
 However,
 the algorithm described above actually encodes 
\begin_inset Formula $f$
\end_inset

 directly as it is:
 To check if 
\begin_inset Formula $f(x)\leq y$
\end_inset

,
 we define 
\begin_inset Formula $W_{h(x,y)}$
\end_inset

 as the c.e.
\begin_inset space \space{}
\end_inset

set that enumerates,
 at time 
\begin_inset Formula $t=x$
\end_inset

,
 the number 
\begin_inset Formula $\braket{h(x,y),y}$
\end_inset

 into itself,
 and no more.
 Then,
 checking if 
\begin_inset Formula $\braket{h(x,y),y}$
\end_inset

 is in 
\begin_inset Formula $A$
\end_inset

 will give us the answer to whether 
\begin_inset Formula $f(x)\leq y$
\end_inset

 or not.
\end_layout

\begin_layout Subsection
Exercise 2.6
\end_layout

\begin_layout Theorem
There is a hypersimple set in every c.e.
\begin_inset space \space{}
\end_inset

degree.
\end_layout

\begin_layout Proof
Let 
\begin_inset Formula $f$
\end_inset

 be a slow approximable c.e.
\begin_inset space \space{}
\end_inset

order.
 We build a hypersimple set by using 
\begin_inset Formula $f$
\end_inset

 to establish a 
\begin_inset Quotes eld
\end_inset

wall
\begin_inset Quotes erd
\end_inset

,
 behind which the set 
\begin_inset Formula $A$
\end_inset

 is frozen and so we cannot modify it any further;
 this will ensure that our set can be computed by 
\begin_inset Formula $f$
\end_inset

.
 The strategy will be similar to the one used to construct a simple set,
 but a crucial difference is that we have no 
\shape italic
a priori
\shape default
 bound for how many elements the 
\begin_inset Formula $e$
\end_inset

-th array will have to add.
 Consequently,
 the 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $2e$
\end_inset


\begin_inset Quotes erd
\end_inset

 trick ceases to work.
 We instead replace it by a 
\begin_inset Quotes eld
\end_inset

marker construction
\begin_inset Quotes erd
\end_inset

,
 cf.
\begin_inset space \space{}
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
after "p. 67"
key "soare1"
literal "false"

\end_inset

.
\end_layout

\begin_layout Proof
Let 
\begin_inset Formula $m_{i}$
\end_inset

 denote the position of the 
\begin_inset Formula $i$
\end_inset

-th marker at a context-dependent time.
 To 
\begin_inset Quotes eld
\end_inset

kick the marker 
\begin_inset Formula $m_{i}$
\end_inset


\begin_inset Quotes erd
\end_inset

 means to enumerate 
\begin_inset Formula $m_{i}$
\end_inset

 into our c.e.
\begin_inset space \space{}
\end_inset

set,
 thereby changing the position of 
\begin_inset Formula $m_{i}$
\end_inset

 of what was before 
\begin_inset Formula $m_{i+1}$
\end_inset

,
 which in turn changes to what was before 
\begin_inset Formula $m_{i+2}$
\end_inset

,
 and so on.
 We start with a marker 
\begin_inset Formula $m_{i}$
\end_inset

 at every natural number 
\begin_inset Formula $i$
\end_inset

.
 For the purposes of permitting,
 we establish that 
\begin_inset Formula $m_{i}$
\end_inset

 may only be kicked if we find 
\begin_inset Formula $f(t)\leq i$
\end_inset

.
\end_layout

\begin_layout Proof
So,
 our algorithm to construct a hypersimple set 
\begin_inset Formula $A$
\end_inset

 becomes as follows.
 Let 
\begin_inset Formula $\{F_{n}^{e}\}_{n\in\N}$
\end_inset

 be the 
\begin_inset Formula $e$
\end_inset

-th array,
 i.e.
\begin_inset space \space{}
\end_inset

the enumeration of finite sets corresponding to the program 
\begin_inset Formula $e$
\end_inset

.
 In parallel,
 we perform the following task for every 
\begin_inset Formula $e\in\N$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize
Enumerate sets in 
\begin_inset Formula $\{F_{n}^{e}\}_{n\in\N}$
\end_inset

.
 If any of these sets ever contains no markers,
 halt this process.
 Otherwise,
 if we ever find some 
\begin_inset Formula $F_{n}^{e}$
\end_inset

 (enumerated at time 
\begin_inset Formula $t$
\end_inset

,
 say) containing markers 
\begin_inset Formula $m_{i_{1}},\dots,m_{i_{k}}$
\end_inset

with all 
\begin_inset Formula $i\geq f(t)$
\end_inset

 (or equivalently 
\begin_inset Formula $i_{1}\geq f(t)$
\end_inset

) and all 
\begin_inset Formula $i\geq e$
\end_inset

 (equivalently 
\begin_inset Formula $i_{1}\geq e$
\end_inset

),
 we kick all of these markers and halt this process.
 (If some markers get kicked out of the way meanwhile,
 we nevertheless continue performing the comparison between 
\begin_inset Formula $i_{1}$
\end_inset

 and 
\begin_inset Formula $f(t)$
\end_inset

,
 but the rule about 
\begin_inset Formula $i_{1}\geq e$
\end_inset

 takes precedence.)
\end_layout

\end_deeper
\begin_layout Proof
Let's verify that this produces a hypersimple set.
 The result is obviously c.e,
 and it is coinfinite because each marker 
\begin_inset Formula $m_{i}$
\end_inset

 can be kicked finitely many times (to be more precise,
 it can be targeted by at most 
\begin_inset Formula $i+1$
\end_inset

 distinct arrays 
\begin_inset Formula $\{F_{n}^{i}\}_{n\in\N}$
\end_inset

,
 each of which is be responsible by a finite number of kicks).
\end_layout

\begin_layout Proof
To show that it is hypersimple,
 consider a fixed array 
\begin_inset Formula $\{F_{n}^{e}\}_{n\in\N}$
\end_inset

,
 and suppose that all 
\begin_inset Formula $F_{n}^{e}$
\end_inset

 are disjoint and that they all contain some element of 
\begin_inset Formula $A^{c}$
\end_inset

.
 Then,
 for every value of 
\begin_inset Formula $n$
\end_inset

,
 it must be the case that the above algorithm was unable to kick the markers in 
\begin_inset Formula $F_{n}^{e}$
\end_inset

 out of the way.
 This might have been because some of the markers had indices less than 
\begin_inset Formula $e$
\end_inset

,
 but since each marker moves finitely much and all the 
\begin_inset Formula $F_{n}^{e}$
\end_inset

 are disjoint,
 we may restrict our attention to values of 
\begin_inset Formula $n$
\end_inset

 large enough that this will never be a problem.
 Then,
 the only way that the markers were never able to be kicked is because,
 whenever 
\begin_inset Formula $F_{n}^{e}$
\end_inset

 was enumerated (say time 
\begin_inset Formula $t$
\end_inset

),
 we had that the smallest marker index (say 
\begin_inset Formula $i_{1}$
\end_inset

) was less than 
\begin_inset Formula $f(t)$
\end_inset

.
 Since this happens infinitely many times with infinitely many marker indices (again,
 
\begin_inset Formula $i_{1}$
\end_inset

 can only move finitely much and all 
\begin_inset Formula $F_{n}^{e}$
\end_inset

 are disjoint so eventually we will enumerate arrays with numbers large enough that none of them are 
\begin_inset Formula $i_{1}$
\end_inset

),
 we have a infinite enumeration of lower bounds 
\begin_inset Formula $i<f(t)$
\end_inset

,
 and by a similar argument to the one used to prove simplicity in Proposition 
\begin_inset CommandInset ref
LatexCommand ref
reference "prop:snhs"

\end_inset

,
 we obtain that this furnishes a contradiction to the slowness of 
\begin_inset Formula $f$
\end_inset

.
\end_layout

\begin_layout Proof
Now,
 let us work on making our set compute 
\begin_inset Formula $f$
\end_inset

.
 It is very likely that the above construction computes 
\begin_inset Formula $f$
\end_inset

 as it is,
 but instead of figuring out how,
 I will instead code 
\begin_inset Formula $f$
\end_inset

 into 
\begin_inset Formula $A$
\end_inset

 directly.
 There is probably a plethora of clever ways,
 but here is the one I will take:
 I shall ensure that the pairs 
\begin_inset Formula $(m_{i},i)$
\end_inset

 furnish a lower bound to 
\begin_inset Formula $f$
\end_inset

.
 More specifically,
 whenever I spot that 
\begin_inset Formula $f(m_{i})\leq i$
\end_inset

,
 I kick the marker 
\begin_inset Formula $m_{i}$
\end_inset

 forward.
 This necessarily modifies the construction,
 but not in a significant manner.
 Each 
\begin_inset Formula $m_{i}$
\end_inset

 is still moved finitely many times,
 because this process moves it only up until a value 
\begin_inset Formula $x$
\end_inset

 satisfying 
\begin_inset Formula $f(x)>i$
\end_inset

.
\end_layout

\begin_layout Subsection
Proposition 3.1 of Miller's paper
\end_layout

\begin_layout Theorem
There is a uniform construction that,
 given a c.e.
\begin_inset space \space{}
\end_inset

set 
\begin_inset Formula $C$
\end_inset

 as an oracle,
 as well as a computable linear order 
\begin_inset Formula $L$
\end_inset

 and an element 
\begin_inset Formula $\hat{b}\in L$
\end_inset

,
 computes a linear order 
\begin_inset Formula $B$
\end_inset

 satisfying the following properties
\end_layout

\begin_deeper
\begin_layout Itemize
If 
\begin_inset Formula $\hat{b}$
\end_inset

 has exactly 
\begin_inset Formula $c\in\omega$
\end_inset

 predecessors in 
\begin_inset Formula $L$
\end_inset

,
 then 
\begin_inset Formula $B=c+\omega^{*}$
\end_inset

,
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $\hat{b}$
\end_inset

 has infinitely many predecessors in 
\begin_inset Formula $L$
\end_inset

,
 then 
\begin_inset Formula $B=\omega$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
This theorem is distinct from what has been done in the previous sections,
 because now we have no requirement that our construction be c.e,
 or computable in any way.
\end_layout

\begin_layout Proof
x
\end_layout

\begin_layout Section
\begin_inset Formula $\Delta_{2}$
\end_inset

 Permitting
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
We saw that a feasible approach to c.e.
\begin_inset space \space{}
\end_inset

permitting is to think,
 instead of c.e.
\begin_inset space \space{}
\end_inset

sets,
 about slow-growing orders 
\begin_inset Formula $f$
\end_inset

 that satisfy certain restrictions.
 These orders have a 
\begin_inset Quotes eld
\end_inset

computable shadow
\begin_inset Quotes erd
\end_inset

,
 namely their supergraph (which is c.e.),
 which allows us to construct objects that are somewhat computable (in this case,
 c.e.) while exhibiting noncomputable behavior computable by 
\begin_inset Formula $f$
\end_inset

,
 because we use 
\begin_inset Formula $f$
\end_inset

 to bound how the object may change past a certain point.
\end_layout

\begin_layout Standard
The case of 
\begin_inset Formula $\Delta_{2}$
\end_inset

 permitting is more complicated.
 Let 
\begin_inset Formula $C$
\end_inset

 be a 
\begin_inset Formula $\Delta_{2}$
\end_inset

 set,
 equipped with its 
\begin_inset Formula $\Delta_{2}$
\end_inset

 approximations 
\begin_inset Formula $\{C_{s}\}_{s\in\N}$
\end_inset

.
 In this case,
 we will build an object
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "bibliography"
options "plain"
encoding "default"

\end_inset


\end_layout

\end_body
\end_document
