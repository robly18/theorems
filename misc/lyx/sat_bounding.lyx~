#LyX 2.4 created this file. For more info see https://www.lyx.org/
\lyxformat 620
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble

\usepackage{listings}
\lstset{
basicstyle=\ttfamily\footnotesize,
keepspaces=true,
tabsize=4,
breaklines=true,
columns=fullflexible,
mathescape=true
}
\usepackage{fullpage}
\usepackage[cal=euler]{mathalpha}
\usepackage{tikz}
\usetikzlibrary{shapes}
\usepackage{braket}
\end_preamble
\use_default_options true
\begin_modules
duarte_theorems
\end_modules
\maintain_unincluded_children no
\language english
\language_package default
\inputencoding auto-legacy
\fontencoding auto
\font_roman "lmodern" "default"
\font_sans "lmss" "default"
\font_typewriter "lmtt" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_roman_osf false
\font_sans_osf false
\font_typewriter_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 1
\output_sync_macro "\synctex=1"
\bibtex_command default
\index_command default
\float_placement h
\float_alignment class
\paperfontsize default
\spacing single
\use_hyperref false
\papersize letter
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_formatted_ref 0
\use_minted 0
\use_lineno 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tablestyle default
\tracking_changes false
\output_changes false
\change_bars false
\postpone_fragile_content false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\docbook_table_output 0
\docbook_mathml_prefix 1
\end_header

\begin_body

\begin_layout Title
Notes on Saturated Bounding Degrees
\end_layout

\begin_layout Author
Duarte Maia
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "macros_logic.lyx"
literal "false"

\end_inset


\end_layout

\begin_layout Section
Main Question
\end_layout

\begin_layout Definition
A 
\emph on
TAC theory
\emph default
 is a decidable complete consistent theory 
\begin_inset Formula $T$
\end_inset

 whose types are all computable.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
A degree 
\begin_inset Formula $d$
\end_inset

 is said to be 
\emph on
saturated bounding
\emph default
 if,
 for any TAC theory 
\begin_inset Formula $T$
\end_inset

,
 
\begin_inset Formula $d$
\end_inset

 decides a saturated model of 
\begin_inset Formula $T$
\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
This means that 
\begin_inset Formula $d$
\end_inset

 computes the elementary diagram of the model in question.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We will prove below that every high degree is saturated bounding,
 as is every PA degree.
 The question we seek to answer is the following:
 
\emph on
Is every saturated bounding degree either high or PA?
\end_layout

\begin_layout Section
Background Results
\end_layout

\begin_layout Subsection
An Alternative Characterization
\end_layout

\begin_layout Definition
We say that 
\begin_inset Formula $T$
\end_inset

 is an NDEPACCT if it is a 
\emph on
computable (binary) tree
\emph default
 (CT) with 
\emph on
no dead ends
\emph default
 (NDE) 
\emph on
all of whose paths are computable
\emph default
 (PAC).
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:altchr"

\end_inset

A degree 
\begin_inset Formula $d$
\end_inset

 is saturated bounding iff,
 whenever 
\begin_inset Formula $T$
\end_inset

 is an NDEPACCT,
 
\begin_inset Formula $d$
\end_inset

 computes an enumeration of all paths in 
\begin_inset Formula $T$
\end_inset

 (possibly with repetitions).
\end_layout

\begin_layout Proof
\begin_inset Formula $(\rightarrow)$
\end_inset

 Let 
\begin_inset Formula $T$
\end_inset

 be an arbitrary NDEPACCT.
 We will construct a certain TAC theory 
\begin_inset Formula $T'$
\end_inset

,
 and then we will show that from a saturated model of 
\begin_inset Formula $T'$
\end_inset

 we can effectively obtain an enumeration of all paths in 
\begin_inset Formula $T$
\end_inset

.
\end_layout

\begin_layout Proof
Consider the language 
\begin_inset Formula $\Lang$
\end_inset

 which consists of a countable number of unary predicate symbols 
\begin_inset Formula $p_{0}$
\end_inset

,
 
\begin_inset Formula $p_{1}$
\end_inset

,
 and so on.
 Define axioms for 
\begin_inset Formula $T'$
\end_inset

 as follows:
 For every binary string 
\begin_inset Formula $\sigma\in2^{<\omega}$
\end_inset

,
 if 
\begin_inset Formula $\sigma\in T$
\end_inset

 we add axioms saying:
 There exist infinitely many 
\begin_inset Formula $x$
\end_inset

 such that 
\begin_inset Formula $p_{0}(x)^{\sigma_{0}}\land\dots\land p_{n}(x)^{\sigma_{n}}$
\end_inset

,
 where we adopt the convention that 
\begin_inset Formula $P^{1}$
\end_inset

 means 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $P^{0}$
\end_inset

 means 
\begin_inset Formula $\neg P$
\end_inset

.
 If 
\begin_inset Formula $\sigma\notin T$
\end_inset

,
 we add an axiom saying that there is no such 
\begin_inset Formula $x$
\end_inset

.
 We verify that 
\begin_inset Formula $T'$
\end_inset

 is TAC.
\end_layout

\begin_deeper
\begin_layout Description
(
\begin_inset Formula $T'$
\end_inset


\begin_inset space ~
\end_inset

is
\begin_inset space ~
\end_inset

complete) It is a standard result that,
 over any language which admits only unary symbols,
 any sentence is provably equivalent to a Boolean combination of sentences of the form:
 There are at least 
\begin_inset Formula $n$
\end_inset

 distinct elements satisfying such-and-such combination of unary predicates.
 Our axiomatization of 
\begin_inset Formula $T'$
\end_inset

 decides every such sentence.
\end_layout

\begin_layout Description
(
\begin_inset Formula $T'$
\end_inset


\begin_inset space ~
\end_inset

is
\begin_inset space ~
\end_inset

consistent) A model of 
\begin_inset Formula $T'$
\end_inset

 is furnished by 
\begin_inset Formula $M=[T]\times\N$
\end_inset

.
 More concretely,
 our universe consists of countably many copies of every path of 
\begin_inset Formula $T$
\end_inset

.
 If 
\begin_inset Formula $(f,n)$
\end_inset

 is an element of 
\begin_inset Formula $M$
\end_inset

,
 we define 
\begin_inset Formula $p_{i}^{M}(f,n)=f_{i}$
\end_inset

.
\end_layout

\begin_layout Description
(
\begin_inset Formula $T'$
\end_inset


\begin_inset space ~
\end_inset

has
\begin_inset space ~
\end_inset

all
\begin_inset space ~
\end_inset

types
\begin_inset space ~
\end_inset

computable) Let 
\begin_inset Formula $\Sigma(\vec{x})$
\end_inset

 be a complete type in 
\begin_inset Formula $T'$
\end_inset

.
 By a refinement of the arguments referred to in the proof that 
\begin_inset Formula $T'$
\end_inset

 is complete,
 we know that a type is fully determined by its atomic part,
 i.e.
\begin_inset space ~
\end_inset

formulas of the form 
\begin_inset Formula $p_{i}(x_{j})$
\end_inset

,
 
\begin_inset Formula $\neg p_{i}(x_{j})$
\end_inset

,
 
\begin_inset Formula $x_{i}=x_{j}$
\end_inset

,
 and 
\begin_inset Formula $x_{i}\neq x_{j}$
\end_inset

.
 In other words,
 to specify 
\begin_inset Formula $\Sigma(\vec{x})$
\end_inset

,
 we need only specify equalities and inequalities between the 
\begin_inset Formula $x_{i}$
\end_inset

,
 and which predicates are satisfied by each 
\begin_inset Formula $x_{i}$
\end_inset

.
 Now,
 let us define 
\begin_inset Formula $f\in2^{\omega}$
\end_inset

 as to satisfy 
\begin_inset Formula $p_{k}(x_{i})^{f_{k}}\in\Sigma(\vec{x})$
\end_inset

 for all 
\begin_inset Formula $k$
\end_inset

.
 Then,
 since 
\begin_inset Formula $\Sigma$
\end_inset

 is consistent with 
\begin_inset Formula $T'$
\end_inset

,
 we must have that 
\begin_inset Formula $f$
\end_inset

 is a path in 
\begin_inset Formula $T$
\end_inset

,
 and hence 
\begin_inset Formula $f$
\end_inset

 is computable.
 Thus,
 the following data is enough to computably reconstruct 
\begin_inset Formula $\Sigma(\vec{x})$
\end_inset

:
 The equality relations between the 
\begin_inset Formula $x_{i}$
\end_inset

,
 and the finite number of computable paths corresponding to each 
\begin_inset Formula $x_{i}$
\end_inset

.
 This is evidently computable.
\end_layout

\end_deeper
\begin_layout Proof
Thus,
 
\begin_inset Formula $d$
\end_inset

 decides a saturated model 
\begin_inset Formula $M$
\end_inset

 of 
\begin_inset Formula $T'$
\end_inset

.
 This model is evidently infinite,
 so we may without loss of generality assume its universe to be 
\begin_inset Formula $\N$
\end_inset

.
 Finally,
 define the 
\begin_inset Formula $d$
\end_inset

-computable function
\begin_inset Formula 
\[
F(x,y)=\begin{cases}
1, & \text{if \ensuremath{M\vDash p_{y}[x]},}\\
0, & \text{otherwise.}
\end{cases}
\]

\end_inset

We claim that 
\begin_inset Formula $F$
\end_inset

 is an enumeration (with repetitions) of the paths in 
\begin_inset Formula $T$
\end_inset

.
 Indeed,
 since 
\begin_inset Formula $M$
\end_inset

 is a saturated model,
 it realizes any unary type.
 Moreover,
 any path 
\begin_inset Formula $f$
\end_inset

 in 
\begin_inset Formula $T$
\end_inset

 induces a consistent type 
\begin_inset Formula $\Sigma^{f}(x)=\{\,p_{i}(x)^{f_{i}}\mid i\in\N\,\}$
\end_inset

,
 which is therefore realized in 
\begin_inset Formula $M$
\end_inset

 by some 
\begin_inset Formula $x\in\N$
\end_inset

.
 Thus,
 the 
\begin_inset Formula $x$
\end_inset

-th row of 
\begin_inset Formula $F$
\end_inset

 will consist of the path 
\begin_inset Formula $f$
\end_inset

,
 and since this path is arbitrary,
 every path of 
\begin_inset Formula $T$
\end_inset

 is enumerated by 
\begin_inset Formula $F$
\end_inset

.
\begin_inset VSpace medskip
\end_inset


\begin_inset Formula $(\leftarrow)$
\end_inset

 Let us now suppose that 
\begin_inset Formula $d$
\end_inset

 computes an enumeration the paths of any NDEPACCT.
 Moreover,
 let 
\begin_inset Formula $T'$
\end_inset

 be a complete consistent computable theory (in the language 
\begin_inset Formula $\Lang$
\end_inset

) all of whose types are computable.
 We shall construct a 
\begin_inset Formula $d$
\end_inset

-decidable saturated model of 
\begin_inset Formula $T'$
\end_inset

,
 with recourse to the following theorem due to Morley 
\begin_inset CommandInset citation
LatexCommand cite
after "Theorem 6.1"
key "morley_computable_saturated"
literal "false"

\end_inset

 and Millar 
\begin_inset CommandInset citation
LatexCommand cite
after "Theorem 2"
key "millar"
literal "false"

\end_inset

,
 whose proof we reproduce in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:millar"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
\end_layout

\begin_deeper
\begin_layout Theorem*
\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:millar"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset


\end_layout

\end_inset

If 
\begin_inset Formula $T'$
\end_inset

 is a 
\begin_inset Formula $d$
\end_inset

-decidable theory such that there is a 
\begin_inset Formula $d$
\end_inset

-computable enumeration of the types of 
\begin_inset Formula $T'$
\end_inset

,
 then there is a 
\begin_inset Formula $d$
\end_inset

-computable countable saturated model of 
\begin_inset Formula $T'$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Proof
Thus,
 since 
\begin_inset Formula $T'$
\end_inset

 is known to be computable,
 it suffices to 
\begin_inset Formula $d$
\end_inset

-enumerate its types.
 We do this by creating a tree with the following appearance:
\end_layout

\begin_layout Proof
\begin_inset Float figure
placement document
alignment document
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[subtree/.style={draw,
 regular polygon,
 regular polygon sides=3,
 anchor=north}]
\end_layout

\begin_layout Plain Layout


\backslash
node (T) at (0,0) {$T
\backslash
;=$};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{scope}[shift={(2.5,2)}]
\end_layout

\begin_layout Plain Layout


\backslash
node[subtree] (I) at (-1,-1) {$T_1$};
\end_layout

\begin_layout Plain Layout


\backslash
node[subtree] (II) at (0,-2) {$T_2$};
\end_layout

\begin_layout Plain Layout


\backslash
node[subtree] (III) at (1,-3) {$T_3$};
\end_layout

\begin_layout Plain Layout


\backslash
node (ETC) at (3.5,-3.5) {$
\backslash
ddots$};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw (0,0) -- (I.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw (1,-1) -- (II.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw (2,-2) -- (III.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw (0,0) -- (ETC);
\end_layout

\begin_layout Plain Layout


\backslash
end{scope}
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
The tree we'll create.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Proof
Where each 
\begin_inset Formula $T_{n}$
\end_inset

 is a subtree that will be used to enumerate the types of arity 
\begin_inset Formula $n$
\end_inset

.
 If we can compute the 
\begin_inset Formula $T_{n}$
\end_inset

 uniformly,
 evidently we can also compute 
\begin_inset Formula $T$
\end_inset

.
 We now describe the procedure to compute 
\begin_inset Formula $T_{n}$
\end_inset

:
\end_layout

\begin_layout Proof
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Let $
\backslash
varphi_i(
\backslash
vec x)$ be an enumeration of the formulas in $n$ variables.
\end_layout

\begin_layout Plain Layout

To determine whether $
\backslash
sigma 
\backslash
in 2^{<
\backslash
omega}$ (of length $k$) is in $T_n$:
\end_layout

\begin_layout Plain Layout

  Is $T'$ consistent with $
\backslash
exists_{
\backslash
vec x} (
\backslash
varphi_0(
\backslash
vec x)^{
\backslash
sigma_0} 
\backslash
land 
\backslash
dots 
\backslash
land 
\backslash
varphi_{k-1}(
\backslash
vec x)^{
\backslash
sigma_{k-1}})$?
\end_layout

\begin_layout Plain Layout

  If yes,
 declare $
\backslash
sigma 
\backslash
in T_n$.
\end_layout

\begin_layout Plain Layout

  If not,
 declare $
\backslash
sigma 
\backslash
notin T_n$.
\end_layout

\end_inset


\end_layout

\begin_layout Proof
Evidently,
 a 
\begin_inset Formula $T'$
\end_inset

-type of arity 
\begin_inset Formula $n$
\end_inset

 is the same as a path in 
\begin_inset Formula $T_{n}$
\end_inset

.
 Moreover,
 the tree 
\begin_inset Formula $T$
\end_inset

 is computable and has no dead ends.
 Finally,
 all paths of 
\begin_inset Formula $T$
\end_inset

 are computable,
 as every path is either a 
\begin_inset Formula $T'$
\end_inset

-type (assumed to be computable) prefixed by a series of ones (as many as its arity) and a zero,
 or it's the all-ones path.
 Thus,
 
\begin_inset Formula $d$
\end_inset

 computes an enumeration of the paths of 
\begin_inset Formula $T$
\end_inset

,
 and it's not difficult to turn this into an enumeration of the 
\begin_inset Formula $T'$
\end_inset

-types.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
One has to be slightly careful in dealing with the all-ones path.
 A possible approach is to fix one particular type 
\begin_inset Formula $\Sigma$
\end_inset

,
 let 
\begin_inset Formula $f_{n}$
\end_inset

 be an enumeration of paths of 
\begin_inset Formula $T$
\end_inset

 which repeats every path infinitely many times,
 and define 
\begin_inset Formula $\Sigma_{n}$
\end_inset

 by:
 If 
\begin_inset Formula $f_{n}$
\end_inset

 starts with at most 
\begin_inset Formula $n$
\end_inset

 ones and a zero,
 set 
\begin_inset Formula $\Sigma_{n}$
\end_inset

to be the remainder.
 Otherwise,
 set 
\begin_inset Formula $\Sigma_{n}=\Sigma$
\end_inset

.
\end_layout

\end_inset

 Hence,
 we may apply Millar's theorem to obtain a 
\begin_inset Formula $d$
\end_inset

-computable saturated model of 
\begin_inset Formula $T'$
\end_inset

,
 and so 
\begin_inset Formula $d$
\end_inset

 is saturated bounding.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:altchr"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 actually proves something stronger than stated:
 
\begin_inset Formula $d$
\end_inset

 being saturated bounding is also equivalent to 
\begin_inset Formula $d$
\end_inset

 being 
\emph on
weakly saturated bounding
\emph default
,
 in the sense that it only computes (rather than decides) models of TAC theories.
\end_layout

\begin_layout Remark
In hindsight this isn't very surprising:
 here is a direct proof of equivalence.
 If 
\begin_inset Formula $d$
\end_inset

 is weakly saturated bounding,
 for any given TAC theory 
\begin_inset Formula $T$
\end_inset

 we can consider its Morleyization 
\begin_inset Formula $T^{*}$
\end_inset

.
 It shouldn't be hard to show that 
\begin_inset Formula $T^{*}$
\end_inset

 is also TAC,
 and so 
\begin_inset Formula $d$
\end_inset

 computes a model of 
\begin_inset Formula $T^{*}$
\end_inset

.
 But this is the same as to decide a model of 
\begin_inset Formula $T$
\end_inset

.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:millar"

\end_inset

Morley and Millar's Theorem
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:millar"

\end_inset

If 
\begin_inset Formula $T$
\end_inset

 is a 
\begin_inset Formula $d$
\end_inset

-decidable theory such that there is a 
\begin_inset Formula $d$
\end_inset

-computable enumeration of the types of 
\begin_inset Formula $T$
\end_inset

,
 then there is a 
\begin_inset Formula $d$
\end_inset

-computable countable saturated model of 
\begin_inset Formula $T$
\end_inset

.
\end_layout

\begin_layout Theorem
The following proof was constructed by myself.
 It is quite different from Millar's;
 his proof consists of constructing a homogeneous model which realizes every type.
 In hindsight,
 however,
 my approach closely resembles Morley's,
 who proved the theorem a couple years before Millar.
 His proof may be found in 
\begin_inset CommandInset citation
LatexCommand cite
key "morley_computable_saturated"
literal "false"

\end_inset

.
\end_layout

\begin_layout Proof
We will prove the theorem for the case 
\begin_inset Formula $d=0$
\end_inset

;
 the relativization is straight-forward.
\end_layout

\begin_layout Proof
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Right now,
 I think that a strategy close to my original one should work...
 I should tell myself why it doesn't,
 when I come to that conclusion.
\end_layout

\begin_layout Plain Layout
Hi,
 this is future self.
 The original one indeed doesn't work.
 The fact that you can decide 
\begin_inset Formula $T_{\text{curr}}+\Sigma_{0}(\vec{c}_{0},d_{p_{0}})$
\end_inset

 but not 
\begin_inset Formula $T_{\text{curr}}+\Sigma_{0}(\vec{c}_{0},d_{p_{0}})+\Sigma_{1}(\vec{c}_{1},d_{p_{1}})$
\end_inset

 is too troublesome.
 I will now try a slightly distinct approach.
\end_layout

\begin_layout Plain Layout
Future future self here.
 I think this approach works.
 But the notation is utter garbage.
 Note to self,
 find a better way to word it all.
 Maybe look at Morley's proof,
 it seems quite similar.
\end_layout

\end_inset


\end_layout

\begin_layout Proof
Let us establish two countable sets of fresh variables,
 
\begin_inset Formula $C=\{c_{i}\}_{i\in\N}$
\end_inset

 and 
\begin_inset Formula $D=\{d_{i}\}_{i\in\N}$
\end_inset

,
 and define 
\begin_inset Formula $T^{*}\supseteq T$
\end_inset

 as a decidable theory such that the constants 
\begin_inset Formula $c_{i}$
\end_inset

 form a set of Henkin witnesses.
 Thus,
 to decide a model of 
\begin_inset Formula $T^{*}$
\end_inset

 is the same as to complete it,
 and in this case the constants in 
\begin_inset Formula $C$
\end_inset

 (modulo provable equality) will furnish a model.
 As such,
 to ensure that this model is saturated,
 we need only fulfill the following countable number of constraints.
 Let 
\begin_inset Formula $\{\Sigma_{n}(\vec{x},y)\}_{n\in\N}$
\end_inset

 be an enumeration of the 
\begin_inset Formula $T$
\end_inset

-types,
 and 
\begin_inset Formula $\{\vec{c}_{n}\}_{n\in\N}$
\end_inset

 an enumeration of the tuples of constants from 
\begin_inset Formula $C$
\end_inset

.
 Then,
 we define:
\begin_inset Formula 
\[
P_{nk}\colon\quad\begin{array}{l}
\text{If we have not yet contradicted \ensuremath{\exists_{y}\Sigma_{n}(\vec{c}_{k},y)},}\\
\text{there should be some \ensuremath{d_{p}} such that we commit to satisfying \ensuremath{\Sigma_{n}(\vec{c}_{k},d_{p})}.}
\end{array}
\]

\end_inset

We will start with the theory 
\begin_inset Formula $T^{*}$
\end_inset

 and iterate over all sentences 
\begin_inset Formula $\varphi_{n}$
\end_inset

 in the language 
\begin_inset Formula $\Lang^{*}=\Lang\cup C\cup D$
\end_inset

,
 at each step committing to adding the sentence or its negation.
 We will strive to meet all constraints 
\begin_inset Formula $P_{nk}$
\end_inset

,
 but the major obstacle will be that we cannot computably tell whether we're trying to make incompatible or inconsistent commitments.
 As such,
 we may sometimes have to injure some of the requirements.
 If we contradict 
\begin_inset Formula $\exists_{y}\Sigma_{n}(\vec{c}_{k},y)$
\end_inset

,
 the requirement 
\begin_inset Formula $P_{nk}$
\end_inset

 is met forever,
 but it may happen that we are forced to contradict 
\begin_inset Formula $\Sigma_{n}(\vec{c}_{k},d_{p})$
\end_inset

.
 In this scenario,
 we may think to increase the index of 
\begin_inset Formula $d$
\end_inset

 and try to meet it again,
 but there is no apparent reason as yet for why we can force this increase to occur a finite number of times (which is necessary so that we have a fixed and particular element to realize the type 
\begin_inset Formula $\Sigma_{n}(\vec{c}_{k},y)$
\end_inset

).
 
\end_layout

\begin_layout Proof
To motivate the rest of the proof,
 we will first show that we can in fact meet any one fixed 
\begin_inset Formula $P_{nk}$
\end_inset

 without injury.
 The algorithm goes as follows.
 First,
 let 
\begin_inset Formula $N$
\end_inset

 be the largest index of a constant in 
\begin_inset Formula $\vec{c}_{k}$
\end_inset

.
 Then,
 let 
\begin_inset Formula $p$
\end_inset

 be large enough such that 
\begin_inset Formula $d_{p}$
\end_inset

 does not appear in any of the Henkin sentences 
\begin_inset Formula $\exists_{x}\varphi(x)\rightarrow\varphi(c_{i})$
\end_inset

 with 
\begin_inset Formula $i\leq N$
\end_inset

.
 Finally,
 we loop over the 
\begin_inset Formula $\Lang^{*}$
\end_inset

-sentences 
\begin_inset Formula $\varphi_{n}$
\end_inset

 and decide whether to add 
\begin_inset Formula $\varphi_{n}$
\end_inset

 or its negation via the following decision procedure:
\end_layout

\begin_layout Proof
\begin_inset Float algorithm
placement document
alignment document
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(1) Does $T_{
\backslash
text{curr}}$ force either $
\backslash
varphi_n$ or $
\backslash
neg
\backslash
varphi_n$?
\end_layout

\begin_layout Plain Layout

If so,
 add the one you are forced to add.
\end_layout

\begin_layout Plain Layout

If not:
\end_layout

\begin_layout Plain Layout

  (2) Does $
\backslash
varphi_n$ contradict $T_{
\backslash
text{curr}} + 
\backslash
Sigma_n(
\backslash
vec c_k,
 d_p)$?
\end_layout

\begin_layout Plain Layout

  If so,
 add $
\backslash
neg
\backslash
varphi_n$.
\end_layout

\begin_layout Plain Layout

  Otherwise,
 add $
\backslash
varphi_n$.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:onepnk"

\end_inset

Fulfilling one 
\begin_inset Formula $P_{nk}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Proof
We need to verify that the two steps marked 
\begin_inset Formula $(1)$
\end_inset

 and 
\begin_inset Formula $(2)$
\end_inset

 are computable.
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $(1)$
\end_inset

 Since 
\begin_inset Formula $T_{\text{curr}}$
\end_inset

 consists of 
\begin_inset Formula $T^{*}$
\end_inset

 plus a finite number of formulas,
 it is also decidable.
\end_layout

\begin_layout Itemize
\begin_inset Formula $(2)$
\end_inset

 This one is a little more complicated.
\end_layout

\begin_deeper
\begin_layout Standard
Let us suppose for the time being that 
\begin_inset Formula $T_{\text{curr}}+\Sigma_{n}(\vec{c}_{k},d_{p})+\varphi_{n}\vdash\bot$
\end_inset

.
 Then,
 there is 
\begin_inset Formula $\sigma\in\Sigma_{n}$
\end_inset

 such that
\begin_inset Formula 
\[
T^{*}\vdash\sigma(\vec{c}_{k},d_{p})\rightarrow\neg\varphi(\vec{c}_{k},d_{p},\vec{c}',\vec{d}'),
\]

\end_inset

where 
\begin_inset Formula $\varphi$
\end_inset

 is the conjunction of 
\begin_inset Formula $\varphi_{n}$
\end_inset

 and the finitely many formulas added between 
\begin_inset Formula $T^{*}$
\end_inset

 and 
\begin_inset Formula $T_{\text{curr}}$
\end_inset

,
 and 
\begin_inset Formula $\vec{c}'$
\end_inset

 and 
\begin_inset Formula $\vec{d}'$
\end_inset

 represent constants 
\begin_inset Formula $c$
\end_inset

 or 
\begin_inset Formula $d$
\end_inset

 that are used in 
\begin_inset Formula $\varphi_{n}$
\end_inset

 but aren't 
\begin_inset Formula $\vec{c}_{k}$
\end_inset

 nor 
\begin_inset Formula $d_{p}$
\end_inset

.
 We will show that these may be eliminated in some sense,
 so that the question boils down to asking whether a certain sentence (using only 
\begin_inset Formula $\vec{c}_{k}$
\end_inset

 and 
\begin_inset Formula $d_{p}$
\end_inset

) is in 
\begin_inset Formula $\Sigma_{n}$
\end_inset

 or not.
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $W(c_{0},\dots,c_{N},d_{0},\dots,d_{p-1})$
\end_inset

 be the conjunction of the Henkin sentences 
\begin_inset Formula $\exists_{x}\varphi(x)\rightarrow\varphi(c_{n})$
\end_inset

 with 
\begin_inset Formula $n\leq N$
\end_inset

.
 Then,
 a standard argument shows that
\begin_inset Formula 
\[
T^{*}\vdash\sigma(\vec{c}_{k},d_{p})\rightarrow\neg\varphi(\vec{c}_{k},d_{p},\vec{c}',\vec{d}')\quad\text{iff}\quad T\vdash\sigma(\vec{c}_{k},d_{p})\rightarrow(W\rightarrow\neg\varphi).
\]

\end_inset

Now,
 all constants 
\begin_inset Formula $c$
\end_inset

 and 
\begin_inset Formula $d$
\end_inset

 other than 
\begin_inset Formula $\vec{c}_{k}$
\end_inset

 and 
\begin_inset Formula $d_{p}$
\end_inset

 are mentioned only by 
\begin_inset Formula $W$
\end_inset

 and 
\begin_inset Formula $\varphi$
\end_inset

,
 and so may be replaced by arbitrary variables.
 Hence,
\begin_inset Formula 
\[
T^{*}\vdash\sigma(\vec{c}_{k},d_{p})\rightarrow\neg\varphi(\vec{c}_{k},d_{p},\vec{c}',\vec{d}')\quad\text{iff}\quad T\vdash\sigma(\vec{c}_{k},d_{p})\rightarrow\exists(W\rightarrow\neg\varphi),
\]

\end_inset

where 
\begin_inset Formula $\exists(W\rightarrow\neg\varphi)$
\end_inset

 is shorthand for replacing every 
\begin_inset Formula $c$
\end_inset

 or 
\begin_inset Formula $d$
\end_inset

 other than the ones mentioned above by existentially quantified variables.
 Note that the process of obtaining 
\begin_inset Formula $\exists(W\rightarrow\neg\varphi)$
\end_inset

 was uniform.
 Finally,
 we note that 
\begin_inset Formula $\sigma\rightarrow\exists(W\rightarrow\neg\varphi)$
\end_inset

 for some 
\begin_inset Formula $\sigma\in\Sigma_{n}$
\end_inset

 iff 
\begin_inset Formula $\exists(W\rightarrow\neg\varphi)$
\end_inset

 was already in 
\begin_inset Formula $\Sigma_{n}$
\end_inset

 to begin with,
 as this sentence only uses symbols from the original language 
\begin_inset Formula $\Lang$
\end_inset

 and the constants 
\begin_inset Formula $\vec{c}_{k}$
\end_inset

 and 
\begin_inset Formula $d_{p}$
\end_inset

.
\end_layout

\begin_layout Standard
In conclusion,
 we can tell whether 
\begin_inset Formula $T_{\text{curr}}+\Sigma_{n}(\vec{c}_{k},d_{p})+\varphi_{n}$
\end_inset

 is contradictory by checking whether the formula (in the variables 
\begin_inset Formula $\vec{c}_{k}$
\end_inset

 and 
\begin_inset Formula $d_{p}$
\end_inset

) 
\begin_inset Formula $\exists(W\rightarrow\neg\varphi)$
\end_inset

 is in the type 
\begin_inset Formula $\Sigma_{n}$
\end_inset

 or not.
\end_layout

\end_deeper
\end_deeper
\begin_layout Proof
Part 
\begin_inset Formula $(2)$
\end_inset

 will be particularly relevant in the sequence,
 so we give it its own role as a lemma.
\end_layout

\begin_deeper
\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:typedecidable"

\end_inset

Let 
\begin_inset Formula $T$
\end_inset

 be a decidable theory and 
\begin_inset Formula $\Sigma(\vec{x})$
\end_inset

 is a type over 
\begin_inset Formula $T$
\end_inset

.
 Moreover,
 let 
\begin_inset Formula $T^{*}$
\end_inset

 be a decidable extension of 
\begin_inset Formula $T$
\end_inset

 by Henkin witnesses 
\begin_inset Formula $\{c_{i}\}_{i\in\N}$
\end_inset

.
 Then,
 if 
\begin_inset Formula $\vec{c}$
\end_inset

 is a tuple of these new constants,
 the theory 
\begin_inset Formula $T^{*}+\Sigma(\vec{c})$
\end_inset

 is decidable.
 In particular,
 any finite extension of it is also decidable.
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $\hat{T}$
\end_inset

 be the theory resulting from Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:onepnk"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
 We wish to show that 
\begin_inset Formula $P_{nk}$
\end_inset

 is fulfilled.
 We show that one of two things happen:
 Either 
\begin_inset Formula $T^{*}$
\end_inset

 contradicted 
\begin_inset Formula $\exists_{y}\Sigma_{n}(\vec{c}_{k},y)$
\end_inset

 from the start,
 in which case 
\begin_inset Formula $P_{nk}$
\end_inset

 is fulfilled,
 or 
\begin_inset Formula $T^{*}$
\end_inset

 is consistent with 
\begin_inset Formula $\exists_{y}\Sigma_{n}(\vec{c}_{k},y)$
\end_inset

 at the start,
 in which case we will show that 
\begin_inset Formula $T^{*}$
\end_inset

 is consistent with 
\begin_inset Formula $\Sigma_{n}(\vec{c}_{k},d_{p})$
\end_inset

.
 From this it follows that the algorithm outlined above will also never contradict 
\begin_inset Formula $\Sigma_{n}(\vec{c}_{k},d_{p})$
\end_inset

,
 and so this type will be contained in the completion we've built.
\end_layout

\begin_layout Standard
Suppose that 
\begin_inset Formula $T^{*}+\Sigma_{n}(\vec{c}_{k},d_{p})\vdash\bot$
\end_inset

.
 Then,
 there is 
\begin_inset Formula $\sigma\in\Sigma_{n}$
\end_inset

 such that 
\begin_inset Formula $T^{*}\vdash\neg\sigma(\vec{c}_{k},d_{p})$
\end_inset

.
 If we define 
\begin_inset Formula $W$
\end_inset

 as in the above argument,
 we conclude that 
\begin_inset Formula $T\vdash W\rightarrow\neg\sigma$
\end_inset

.
 Since 
\begin_inset Formula $d_{p}$
\end_inset

 was chosen as not to appear in 
\begin_inset Formula $W$
\end_inset

,
 we then conclude 
\begin_inset Formula $T\vdash W\rightarrow\neg\exists_{y}\sigma(\vec{c}_{k},y)$
\end_inset

,
 and so 
\begin_inset Formula $T^{*}+\exists_{y}\Sigma_{n}(\vec{c}_{k},y)$
\end_inset

 is contradictory,
 as we wanted to show.
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset

Now,
 Millar's theorem consists of adapting the above strategy as to fulfill every 
\begin_inset Formula $P_{nk}$
\end_inset

 as opposed to just one.
 This turns out to be harder than expected,
 and the main reason is the following:
 Even though by Lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:typedecidable"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 it is the case that,
 for a single type 
\begin_inset Formula $\Sigma(\vec{c},d_{p})$
\end_inset

,
 the theory 
\begin_inset Formula $T_{\text{curr}}+\Sigma(\vec{c},d_{p})$
\end_inset

 is decidable,
 it is not the case that the theory obtained by considering two types simultaneously is.
 As such,
 it might be that at any stage neither type individually forces neither a sentence 
\begin_inset Formula $\varphi$
\end_inset

 nor its negation,
 but there are two types which together force,
 say,
 
\begin_inset Formula $\neg\varphi$
\end_inset

 to hold.
 But we did not know that at the time,
 and so we unknowingly set ourselves up for an injury down the line.
 And this might happen very often,
 so one type or another may never be witnessed by any 
\begin_inset Formula $d_{p}$
\end_inset

 because it keeps getting injured and its representative keeps jumping around.
\end_layout

\begin_layout Standard
A way to try to get around this is to attempt to collect several types into one overarching megatype;
 e.g.
 given 
\begin_inset Formula $\Sigma_{0}(\vec{c}_{0},d_{p_{0}})$
\end_inset

 and 
\begin_inset Formula $\Sigma_{1}(\vec{c}_{1},d_{p_{1}})$
\end_inset

,
 attempt to find a type 
\begin_inset Formula $\Sigma_{01}(\vec{c}_{0},\vec{c}_{1},d_{p_{0}},d_{p_{1}})$
\end_inset

 which contains 
\begin_inset Formula $\Sigma_{0}(\vec{c}_{0},d_{p_{0}})\cup\Sigma_{1}(\vec{c}_{1},d_{p_{1}})$
\end_inset

.
 Then,
 instead of trying to do what 
\begin_inset Formula $\Sigma_{0}$
\end_inset

 and 
\begin_inset Formula $\Sigma_{1}$
\end_inset

 force individually,
 we do what 
\begin_inset Formula $\Sigma_{01}$
\end_inset

 forces.
\end_layout

\begin_layout Standard
This approach has an obvious problem:
 There is no effective way to find 
\begin_inset Formula $\Sigma_{01}$
\end_inset

 as above,
 if it exists.
 We can,
 however,
 guess a type.
 And if that type is the wrong one,
 we guess the next,
 and so on.
 If our guess is wrong,
 we can verify that in finite time and change our guess.
 Moreover,
 we will 
\emph on
eventually
\emph default
 hit upon a right guess.
 Thus,
 we have the right setup for a finite-injury type argument.
\end_layout

\begin_layout Standard
This isn't quite the full story,
 because in the meantime we may have committed to a formula which specifies some way in which 
\begin_inset Formula $\vec{c}_{0}$
\end_inset

 and 
\begin_inset Formula $\vec{c}_{1}$
\end_inset

 relate,
 which 
\begin_inset Formula $\Sigma_{01}$
\end_inset

 does not agree with.
 So when we are trying to find 
\begin_inset Formula $\Sigma_{01}$
\end_inset

,
 we also need to take care to find a type which is consistent with the formulas we've acquired so far.
\end_layout

\begin_layout Standard
Before describing the algorithm,
 here is some necessary notation:
\end_layout

\begin_layout Itemize
Given a collection of 
\begin_inset Formula $c$
\end_inset

-variables 
\begin_inset Formula $\vec{c}$
\end_inset

,
 the corresponding 
\emph on
Henkin formula
\emph default
 
\begin_inset Formula $W$
\end_inset

 is the conjunction of the least initial segment of Henkin formulas containing 
\begin_inset Formula $\exists_{x}\varphi(x)\rightarrow\varphi(c)$
\end_inset

 for 
\begin_inset Formula $c$
\end_inset

 in 
\begin_inset Formula $\vec{c}$
\end_inset

,
\end_layout

\begin_layout Itemize
At a given state,
 let 
\begin_inset Formula $\Phi$
\end_inset

 be the conjunction of all formulas we've committed to,
\end_layout

\begin_layout Itemize
We fix a 
\begin_inset Formula $d$
\end_inset

-computable enumeration of pairs 
\begin_inset Formula $(\Sigma_{i},\vec{c}_{i})$
\end_inset

 which covers all pairs of types and valid tuples,
\end_layout

\begin_layout Itemize
Over the course of the following algorithm,
 some indices will be said to be 
\emph on
fulfilled
\emph default
.
 This is because we've found that the formulas 
\begin_inset Formula $\exists_{y}\Sigma_{i}(\vec{c}_{i},y)$
\end_inset

 can no longer be a subset of the the final theory,
 and so there is no work to be done to ensure saturation regarding this type.
 When discussing enumerations 
\begin_inset Formula $\vec{c}_{0},\dots,\vec{c}_{i}$
\end_inset

,
 we introduce two notations that modify how this expression should be interpreted:
\end_layout

\begin_deeper
\begin_layout Itemize
When we write 
\begin_inset Formula $\vec{c}_{0},\overset{\nu}{\dots},\vec{c}_{i}$
\end_inset

,
 it should be understood that the tuples 
\begin_inset Formula $\vec{c}_{j}$
\end_inset

 for fulfilled indices 
\begin_inset Formula $j$
\end_inset

 are replaced by arbitrary fresh constants,
\end_layout

\begin_layout Itemize
When we write 
\begin_inset Formula $\vec{c}_{0},\overset{\times}{\dots},\vec{c}_{i}$
\end_inset

,
 it should be understood that the tuples 
\begin_inset Formula $\vec{c}_{j}$
\end_inset

 for fulfilled indices 
\begin_inset Formula $j$
\end_inset

 are removed.
\end_layout

\end_deeper
\begin_layout Standard
We may now describe the algorithm.
\end_layout

\end_deeper
\begin_layout Proof
\begin_inset Float algorithm
placement document
alignment document
wide false
sideways false
status open

\begin_layout Plain Layout
We will have three processes running concurrently:
\end_layout

\begin_layout Itemize
The first process will attempt to find,
 for increasing values of 
\begin_inset Formula $i$
\end_inset

,
 a sequence of types 
\begin_inset Formula $\Sigma_{0},\Sigma_{01},\Sigma_{012},\dots,\Sigma_{0\dots i}$
\end_inset

 such that 
\begin_inset Formula $\Sigma_{0\dots i+1}(\vec{x},\vec{x}',y,y')\supseteq\Sigma_{0\dots i}(\vec{x},y)\cup\Sigma_{i+1}(\vec{x}',y')$
\end_inset

.
 In parallel,
 it will try to falsify its previous choices by trying to find a formula that is in 
\begin_inset Formula $\Sigma_{0\dots i}$
\end_inset

 or in 
\begin_inset Formula $\Sigma_{i}$
\end_inset

 but not in 
\begin_inset Formula $\Sigma_{0\dots i+1}$
\end_inset

.
 In this scenario,
 it changes its guess for 
\begin_inset Formula $\Sigma_{0\dots i+1}$
\end_inset

,
 forgets all its guesses for greater values of 
\begin_inset Formula $i$
\end_inset

,
 and keeps trying.
 This process is performed so that every type can show up as a guess for 
\begin_inset Formula $\Sigma_{0\dots i}$
\end_inset

 infinitely often.
\end_layout

\begin_deeper
\begin_layout Plain Layout
When finding a new candidate for 
\begin_inset Formula $\Sigma_{0\dots i}$
\end_inset

,
 it will find the first new type such that 
\begin_inset Formula $\Sigma_{0\dots i}(\vec{c}_{0},\overset{\nu}{\dots},\vec{c}_{i},d_{p_{0}},\dots,d_{p_{i-1}},y)$
\end_inset

 is consistent with 
\begin_inset Formula $W+\Phi$
\end_inset

,
 where 
\begin_inset Formula $W$
\end_inset

 is the Henkin formula of the collection of 
\begin_inset Formula $\vec{c}$
\end_inset

 up to 
\begin_inset Formula $\vec{c}_{i}$
\end_inset

 and the ones used in 
\begin_inset Formula $\Phi$
\end_inset

.
 Note that consistency with 
\begin_inset Formula $W+\Phi$
\end_inset

 is the same as to be consistent with 
\begin_inset Formula $T_{\text{curr}}$
\end_inset

.
\end_layout

\begin_layout Plain Layout
When a new guess is made for 
\begin_inset Formula $\Sigma_{0\dots i}$
\end_inset

,
 this process will also pick a value of 
\begin_inset Formula $p_{i}$
\end_inset

 large enough that 
\begin_inset Formula $d_{p_{i}}$
\end_inset

is not in 
\begin_inset Formula $W$
\end_inset

.
 This guarantees that 
\begin_inset Formula $\Sigma_{0\dots i}(\vec{c}_{0},\overset{\nu}{\dots},\vec{c}_{i},d_{p_{0}},\dots,d_{p})$
\end_inset

 is consistent with 
\begin_inset Formula $T_{\text{curr}}$
\end_inset

,
 as from its perspective 
\begin_inset Formula $d_{p}$
\end_inset

 is equivalent to a fresh variable.
\end_layout

\end_deeper
\begin_layout Itemize
The second process will loop over sentences 
\begin_inset Formula $\varphi_{n}$
\end_inset

 and commit to either adding the formula or its negation to the theory.
 It will prioritize being consistent with 
\begin_inset Formula $\Sigma_{0\dots i}(\vec{c}_{0},\overset{\nu}{\dots},\vec{c}_{i},d_{p_{0}},\dots,d_{p_{i}})$
\end_inset

 for smaller values of 
\begin_inset Formula $i$
\end_inset

.
 It might be unable to be consistent with all the types we've established so far;
 it will try to be consistent with as large an initial segment as it can.
\end_layout

\begin_deeper
\begin_layout Plain Layout
In the event that it is impossible to be consistent with 
\begin_inset Formula $\Sigma_{0\dots i}$
\end_inset

 and 
\begin_inset Formula $\Sigma_{0\dots i+1}$
\end_inset

 at the same time,
 we signal to the first process that it should find a new candidate for 
\begin_inset Formula $\Sigma_{0\dots i+1}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
The third process will regularly check that 
\begin_inset Formula $T_{\text{curr}}$
\end_inset

 is consistent with 
\begin_inset Formula $\exists_{y}\Sigma_{i}(\vec{c}_{i},y)$
\end_inset

 for every value of 
\begin_inset Formula $i$
\end_inset

.
 If it ever finds an inconsistency,
 it marks the corresponding index as fulfilled.
 Moreover,
 it signals the first process to find new variables 
\begin_inset Formula $d_{p_{j}}$
\end_inset

 for 
\begin_inset Formula $j>i$
\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:hatt"

\end_inset

The Theory Used to Create a Saturated Model
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
This algorthm evidently produces a consistent decidable theory 
\begin_inset Formula $\hat{T}$
\end_inset

 at the end,
 and hence the 
\begin_inset Formula $c$
\end_inset

 constants mod provable equality form a model.
 It remains to verify that this algorithm produces a saturated model.
 Inductively on 
\begin_inset Formula $i\in\N$
\end_inset

,
 we show that if 
\begin_inset Formula $\exists_{y}\Sigma_{i}(\vec{c}_{i},y)$
\end_inset

 is contained in the final theory then there is 
\begin_inset Formula $d_{p_{i}}$
\end_inset

 such that 
\begin_inset Formula $\Sigma_{i}(\vec{c}_{i},d_{p_{i}})$
\end_inset

 is contained in the final theory.
\end_layout

\begin_layout Standard
Consider a stage after which the third process has already found all inconsistencies for indices below 
\begin_inset Formula $i$
\end_inset

.
 Moreover,
 assume (as part of an inductive reasoning) that 
\begin_inset Formula $\Sigma_{0\dots j}$
\end_inset

 and 
\begin_inset Formula $d_{p_{j}}$
\end_inset

 stabilize for 
\begin_inset Formula $j<i$
\end_inset

,
 and indeed that we are in a stage after which this has already occurred.
 We claim that 
\begin_inset Formula $\Sigma_{0\dots i}$
\end_inset

 (and corresponding 
\begin_inset Formula $d_{p_{i}}$
\end_inset

) will eventually stabilize.
\end_layout

\begin_layout Standard
Assume by contradiction that it does not.
 Then,
 it will over the course of execution take on all possible types such that 
\begin_inset Formula $\Sigma_{0\dots i}(\vec{c}_{0},\overset{\nu}{\dots},\vec{c}_{i},d_{p_{0}},\dots,d_{p_{i-1}},y)$
\end_inset

 is compatible with 
\begin_inset Formula $T_{\text{curr}}$
\end_inset

.
 As such,
 it will eventually take on a type which is a consistent extension of 
\begin_inset Formula $\bar{\Sigma}=\hat{T}|(\vec{c}_{0},\overset{\times}{\dots},\vec{c}_{i},d_{p_{0}},\dots,d_{p_{i-1}})+\Sigma_{0\dots i-1}(\vec{c}_{0},\overset{\nu}{\dots},\vec{c}_{i-1},d_{p_{0}},\dots,d_{p_{i-1}})+\Sigma_{i}(\vec{c}_{i},y)$
\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Some proof is required to conclude that 
\begin_inset Formula $\bar{\Sigma}$
\end_inset

 is a consistent set of formulas.
 The proof consists of noticing that,
 by construction of the second process,
 
\begin_inset Formula $\hat{T}$
\end_inset

 is constructed specifically so that this is the case.
\end_layout

\end_inset

 By inspection of the algorithm,
 from that moment onward the type will never change because it has no reason to:
 
\end_layout

\begin_layout Itemize
The first process will never force a change of type because 
\begin_inset Formula $\Sigma_{0\dots i}(\vec{c}_{0},\overset{\nu}{\dots},\vec{c}_{i},d_{p_{0}},\dots,d_{p_{i-1}},y)$
\end_inset

 is chosen as to extend 
\begin_inset Formula $\Sigma_{0\dots i-1}(\vec{c}_{0},\overset{\nu}{\dots},\vec{c}_{i-1},d_{p_{0}},\dots,d_{p_{i-1}})+\Sigma_{i}(\vec{c}_{i},y)$
\end_inset

 and 
\begin_inset Formula $\Sigma_{0\dots j}$
\end_inset

 has stabilized for 
\begin_inset Formula $j<i$
\end_inset

.
 
\end_layout

\begin_layout Itemize
The second process will never force a change of type because 
\begin_inset Formula $\Sigma_{0\dots i}(\vec{c}_{0},\overset{\nu}{\dots},\vec{c}_{i},d_{p_{0}},\dots,d_{p_{i-1}},y)$
\end_inset

 is chosen as to extend 
\begin_inset Formula $\hat{T}|(\vec{c}_{0},\overset{\times}{\dots},\vec{c}_{i},d_{p_{0}},\dots,d_{p_{i-1}})$
\end_inset

.
 
\end_layout

\begin_layout Itemize
The third process will never force a change of type because we've assumed that it has been triggered as many times as it ever will be below 
\begin_inset Formula $i$
\end_inset

.
\end_layout

\begin_layout Standard
We actually draw a stronger conclusion:
 This (being a consistent extension of 
\begin_inset Formula $\bar{\Sigma}$
\end_inset

) is,
 in fact,
 the only way the type can stabilize.
 Moreover,
 in this instance,
 we will by construction never commit to a formula that contradicts 
\begin_inset Formula $\Sigma_{0\dots i}(\vec{c}_{0},\dots,\vec{c}_{i},d_{p_{0}},\dots,d_{p_{i-1}},d_{p_{i}})$
\end_inset

,
 and so we conclude that 
\begin_inset Formula $d_{p_{i}}$
\end_inset

 will satisfy 
\begin_inset Formula $\Sigma_{i}(\vec{c}_{i},d_{p_{i}})$
\end_inset

.
 Since 
\begin_inset Formula $i$
\end_inset

 is an arbitrary unfulfilled index,
 we conclude that the model corresponding to 
\begin_inset Formula $\hat{T}$
\end_inset

 is in fact saturated.
\end_layout

\end_deeper
\begin_layout Subsection
Subenumerative Degrees
\end_layout

\begin_layout Definition
A degree 
\begin_inset Formula $d$
\end_inset

 is said to be 
\emph on
subenumerative
\emph default
 if it computes a subenumeration of the computable sets;
 that is,
 a function 
\begin_inset Formula $F\colon\N\times\N\to2$
\end_inset

 such that the collection of sections 
\begin_inset Formula $F_{s}$
\end_inset

 includes all characteristic functions of computable sets.
\end_layout

\begin_layout Theorem
A degree is subenumerative iff it is either high or PA.
\end_layout

\begin_layout Proof
I feel comfortable enough with the proof that I don't feel the need to write it out right now.
 It can be found in 
\begin_inset CommandInset citation
LatexCommand cite
key "jockusch_1972"
literal "false"

\end_inset

.
\end_layout

\begin_layout Subsection
The Converse of the Conjecture
\end_layout

\begin_layout Theorem
Every subenumerative degree is saturated bounding
\end_layout

\begin_layout Proof
We characterized a saturated bounding degree as one which,
 for every NDEPACCT 
\begin_inset Formula $T$
\end_inset

,
 computes an enumeration of the paths in 
\begin_inset Formula $T$
\end_inset

.
 However,
 it actually suffices to compute a listing of sets which includes the paths in 
\begin_inset Formula $T$
\end_inset

.
 This is because,
 since 
\begin_inset Formula $T$
\end_inset

 is computable with no dead ends,
 we can uniformly turn an arbitrary path into a path in 
\begin_inset Formula $T$
\end_inset

:
 Just follow along the path until you detect that you've left 
\begin_inset Formula $T$
\end_inset

,
 and from then on replace the path by the one obtained by going left whenever possible.
\end_layout

\begin_layout Proof
From this,
 the theorem becomes clear,
 as a subenumerative computes a listing of 
\emph on
all
\emph default
 computable sets,
 which in particular includes all paths in any NDEPACCT.
\end_layout

\begin_layout Subsection
\begin_inset Formula $0$
\end_inset

 is Not Saturated Bounding
\end_layout

\begin_layout Theorem
\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
Millar 
\begin_inset CommandInset citation
LatexCommand cite
key "millar"
literal "false"

\end_inset

,
 Goncharovâ€“Nurtazin
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "thm:zeronotsatbounding"

\end_inset


\begin_inset Formula $0$
\end_inset

 is not saturated bounding.
\end_layout

\begin_layout Proof
We build an NDEPACCT 
\begin_inset Formula $T$
\end_inset

 for which there fails to have any computable enumeration of its paths.
 We've seen that if we enumerate 
\begin_inset Quotes eld
\end_inset

too many paths
\begin_inset Quotes erd
\end_inset

 we can always 
\begin_inset Quotes eld
\end_inset

prune the enumeration down
\begin_inset Quotes erd
\end_inset

,
 so this is done by ensuring that there is a path that fails to be enumerated.
\end_layout

\begin_layout Proof
Our tree 
\begin_inset Formula $T$
\end_inset

 will be built in the following shape:
\begin_inset Float figure
placement document
alignment document
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[subtree/.style={draw,
 regular polygon,
 regular polygon sides=3,
 anchor=north}]
\end_layout

\begin_layout Plain Layout


\backslash
node (T) at (0,0) {$T
\backslash
;=$};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{scope}[shift={(2.5,2)}]
\end_layout

\begin_layout Plain Layout


\backslash
node[subtree] (I) at (-1,-1) {$T_0$};
\end_layout

\begin_layout Plain Layout


\backslash
node[subtree] (II) at (0,-2) {$T_1$};
\end_layout

\begin_layout Plain Layout


\backslash
node[subtree] (III) at (1,-3) {$T_2$};
\end_layout

\begin_layout Plain Layout


\backslash
node (ETC) at (3.5,-3.5) {$
\backslash
ddots$};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw (0,0) -- (I.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw (1,-1) -- (II.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw (2,-2) -- (III.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw (0,0) -- (ETC);
\end_layout

\begin_layout Plain Layout


\backslash
end{scope}
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
The tree we'll create.
\end_layout

\end_inset


\end_layout

\end_inset

in which 
\begin_inset Formula $T_{n}$
\end_inset

 will have the role of preventing 
\begin_inset Formula $\varphi_{n}$
\end_inset

 from being an enumeration of the paths of 
\begin_inset Formula $T$
\end_inset

,
 by containing a path distinct from every row of 
\begin_inset Formula $\varphi_{n}$
\end_inset

.
\end_layout

\begin_layout Proof
To describe 
\begin_inset Formula $T_{n}$
\end_inset

,
 we shall describe a procedure such that at each stage we have a finite tree,
 with some leaves marked as 
\begin_inset Quotes eld
\end_inset

unknown
\begin_inset Quotes erd
\end_inset

.
 This should be taken to mean that we haven't decided whether the tree will branch off to that node or not.
 We will also be highlighting a path through this tree,
 which is the path that we ensure is 
\emph on
not
\emph default
 enumerated by 
\begin_inset Formula $\varphi_{n}$
\end_inset

.
 Here is a picture of what 
\begin_inset Formula $T$
\end_inset

 might look at a finite stage,
 with emphasis on 
\begin_inset Formula $T_{1}$
\end_inset

.
\end_layout

\begin_layout Proof
\begin_inset Float figure
placement document
alignment document
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[
\end_layout

\begin_layout Plain Layout

scale=0.7,
\end_layout

\begin_layout Plain Layout

subtree/.style={draw,
 regular polygon,
 regular polygon sides=3,
 anchor=north},
\end_layout

\begin_layout Plain Layout

unk/.style={sibling distance=0.5cm,
 level distance=8mm},
\end_layout

\begin_layout Plain Layout

edge from parent path={(
\backslash
tikzparentnode.south)--(
\backslash
tikzchildnode.north)},
\end_layout

\begin_layout Plain Layout

level distance=15mm,
\end_layout

\begin_layout Plain Layout

sibling distance=7cm,
\end_layout

\begin_layout Plain Layout

thetree/.style={sibling distance=2cm},
\end_layout

\begin_layout Plain Layout

reg/.style={thin},
\end_layout

\begin_layout Plain Layout

marked/.style={line width=1mm}]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
coordinate
\end_layout

\begin_layout Plain Layout

	child {node[subtree]{$T_0$}}
\end_layout

\begin_layout Plain Layout

	child {
\end_layout

\begin_layout Plain Layout

		child {node[draw,
 circle] {$T_1$}
\end_layout

\begin_layout Plain Layout

			[thetree]
\end_layout

\begin_layout Plain Layout

			child[reg] {
\end_layout

\begin_layout Plain Layout

				child[missing] {}
\end_layout

\begin_layout Plain Layout

				child {
\end_layout

\begin_layout Plain Layout

					child[unk] {node{?}}
\end_layout

\begin_layout Plain Layout

					child[unk] {node{?}}
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			child[marked] {
\end_layout

\begin_layout Plain Layout

				child[missing]{}
\end_layout

\begin_layout Plain Layout

				child {
\end_layout

\begin_layout Plain Layout

					child[missing] {}
\end_layout

\begin_layout Plain Layout

					child {
\end_layout

\begin_layout Plain Layout

						child {
\end_layout

\begin_layout Plain Layout

							child {
\end_layout

\begin_layout Plain Layout

								[reg]
\end_layout

\begin_layout Plain Layout

								child[unk] {node{?}}
\end_layout

\begin_layout Plain Layout

								child[unk] {node{?}}
\end_layout

\begin_layout Plain Layout

							}
\end_layout

\begin_layout Plain Layout

							child {
\end_layout

\begin_layout Plain Layout

								[reg]
\end_layout

\begin_layout Plain Layout

								child[unk] {node{?}}
\end_layout

\begin_layout Plain Layout

								child[unk] {node{?}}
\end_layout

\begin_layout Plain Layout

							}
\end_layout

\begin_layout Plain Layout

						}
\end_layout

\begin_layout Plain Layout

						child[reg] {
\end_layout

\begin_layout Plain Layout

							child[missing]{}
\end_layout

\begin_layout Plain Layout

							child {
\end_layout

\begin_layout Plain Layout

								child[unk] {node{?}}
\end_layout

\begin_layout Plain Layout

								child[unk] {node{?}}
\end_layout

\begin_layout Plain Layout

							}
\end_layout

\begin_layout Plain Layout

						}
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

			}		
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		child {
\end_layout

\begin_layout Plain Layout

			child {node[subtree]{$T_2$}}
\end_layout

\begin_layout Plain Layout

			child[edge from parent path={(
\backslash
tikzparentnode.south)--(
\backslash
tikzchildnode)}] {node {$
\backslash
ddots$}}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Formula $T$
\end_inset

 after a few stages.
\end_layout

\end_inset


\end_layout

\end_inset

The algorithm executes the following two processes in parallel:
\end_layout

\begin_deeper
\begin_layout Itemize
The first process will replace every left-facing 
\begin_inset Formula $?$
\end_inset

 by a non-branch,
 and every right-facing 
\begin_inset Formula $?$
\end_inset

 by a branch both of whose children are marked 
\begin_inset Formula $?$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement document
alignment document
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[
\end_layout

\begin_layout Plain Layout

scale=1,
\end_layout

\begin_layout Plain Layout

subtree/.style={draw,
 regular polygon,
 regular polygon sides=3,
 anchor=north},
\end_layout

\begin_layout Plain Layout

unk/.style={sibling distance=0.5cm,
 level distance=8mm},
\end_layout

\begin_layout Plain Layout

edge from parent path={(
\backslash
tikzparentnode.south)--(
\backslash
tikzchildnode.north)},
\end_layout

\begin_layout Plain Layout

level distance=15mm,
\end_layout

\begin_layout Plain Layout

sibling distance=2cm]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[coordinate] at (0,0) {}
\end_layout

\begin_layout Plain Layout

	child[unk] {node{?}}
\end_layout

\begin_layout Plain Layout

	child[unk] {node{?}};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw[->] (1,0) -- (2,0);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[coordinate] at (3,0){}
\end_layout

\begin_layout Plain Layout

	child[missing]{}
\end_layout

\begin_layout Plain Layout

	child{
\end_layout

\begin_layout Plain Layout

		child[unk]{node{?}}
\end_layout

\begin_layout Plain Layout

		child[unk]{node{?}}
\end_layout

\begin_layout Plain Layout

	};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
The action performed by the first process.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The second process will keep an internal counter 
\begin_inset Formula $k$
\end_inset

,
 which starts at 
\begin_inset Formula $k=0$
\end_inset

.
 The value of this counter dictates that this process will ensure that 
\begin_inset Formula $T$
\end_inset

 contains a path that is distinct from 
\begin_inset Formula $i\mapsto\varphi_{n}\braket{k,i}$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
At any given point,
 this process will be computing the path 
\begin_inset Formula $(\varphi_{n}\braket{k,0},\varphi_{n}\braket{k,1},\dots)$
\end_inset

 up to the depth of the marked path of 
\begin_inset Formula $T_{n}$
\end_inset

 (including the prefix 
\begin_inset Formula $\overset{n}{\overbrace{1\dots1}}0$
\end_inset

),
 
\emph on
plus one
\emph default
.
 At this stage (we can prove by induction that) that which lies below the marked node will look like this:
\begin_inset Float figure
placement document
alignment document
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[
\end_layout

\begin_layout Plain Layout

scale=0.5,
\end_layout

\begin_layout Plain Layout

subtree/.style={draw,
 regular polygon,
 regular polygon sides=3,
 anchor=north},
\end_layout

\begin_layout Plain Layout

unk/.style={sibling distance=0.5cm,
 level distance=8mm},
\end_layout

\begin_layout Plain Layout

edge from parent path={(
\backslash
tikzparentnode.south)--(
\backslash
tikzchildnode.north)},
\end_layout

\begin_layout Plain Layout

level distance=15mm,
\end_layout

\begin_layout Plain Layout

sibling distance=2cm,
\end_layout

\begin_layout Plain Layout

reg/.style={thin},
\end_layout

\begin_layout Plain Layout

marked/.style={line width=1mm}]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
coordinate (root)
\end_layout

\begin_layout Plain Layout

	child[missing] {}
\end_layout

\begin_layout Plain Layout

	child[marked] {
\end_layout

\begin_layout Plain Layout

		child[reg] {
\end_layout

\begin_layout Plain Layout

			child[missing]{}
\end_layout

\begin_layout Plain Layout

			child {
\end_layout

\begin_layout Plain Layout

				child[missing]{}
\end_layout

\begin_layout Plain Layout

				child {
\end_layout

\begin_layout Plain Layout

					child[unk]{node{?}}
\end_layout

\begin_layout Plain Layout

					child[unk]{node{?}}
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		child[reg] {
\end_layout

\begin_layout Plain Layout

			child[missing]{}
\end_layout

\begin_layout Plain Layout

			child {
\end_layout

\begin_layout Plain Layout

				child[missing]{}
\end_layout

\begin_layout Plain Layout

				child {
\end_layout

\begin_layout Plain Layout

					child[unk]{node{?}}
\end_layout

\begin_layout Plain Layout

					child[unk]{node{?}}
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[right of=root] {(depth $d$)};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Below a marked node.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this scenario,
 if the path 
\begin_inset Formula $\varphi_{n}\braket{k,\cdot}$
\end_inset

 went left,
 we stipulate that the marked path shall go right,
 and vice versa.
 Then,
 we make the marked path go as far down as we've constructed the tree,
 and add branches on both sides.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement document
alignment document
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[
\end_layout

\begin_layout Plain Layout

scale=0.5,
\end_layout

\begin_layout Plain Layout

subtree/.style={draw,
 regular polygon,
 regular polygon sides=3,
 anchor=north},
\end_layout

\begin_layout Plain Layout

unk/.style={sibling distance=0.5cm,
 level distance=8mm},
\end_layout

\begin_layout Plain Layout

edge from parent path={(
\backslash
tikzparentnode.south)--(
\backslash
tikzchildnode.north)},
\end_layout

\begin_layout Plain Layout

level distance=15mm,
\end_layout

\begin_layout Plain Layout

sibling distance=2cm,
\end_layout

\begin_layout Plain Layout

reg/.style={thin},
\end_layout

\begin_layout Plain Layout

marked/.style={line width=1mm}]
\end_layout

\begin_layout Plain Layout


\backslash
coordinate (X)
\end_layout

\begin_layout Plain Layout

	child[missing] {}
\end_layout

\begin_layout Plain Layout

	child[marked] {
\end_layout

\begin_layout Plain Layout

		child[reg] {
\end_layout

\begin_layout Plain Layout

			child[missing]{}
\end_layout

\begin_layout Plain Layout

			child {
\end_layout

\begin_layout Plain Layout

				child[missing]{}
\end_layout

\begin_layout Plain Layout

				child {
\end_layout

\begin_layout Plain Layout

					child[unk]{node{?}}
\end_layout

\begin_layout Plain Layout

					child[unk]{node{?}}
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		child[marked] {
\end_layout

\begin_layout Plain Layout

			child[missing]{}
\end_layout

\begin_layout Plain Layout

			child {
\end_layout

\begin_layout Plain Layout

				child[missing]{}
\end_layout

\begin_layout Plain Layout

				child {
\end_layout

\begin_layout Plain Layout

					child[reg]{
\end_layout

\begin_layout Plain Layout

						child[unk]{node{?}}
\end_layout

\begin_layout Plain Layout

						child[unk]{node{?}}
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

					child[reg]{
\end_layout

\begin_layout Plain Layout

						child[unk]{node{?}}
\end_layout

\begin_layout Plain Layout

						child[unk]{node{?}}
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	};
\end_layout

\begin_layout Plain Layout


\backslash
node[above of=X] {If $
\backslash
varphi_n
\backslash
braket{k,d+1}=0$};
\end_layout

\begin_layout Plain Layout


\backslash
coordinate (Y) at (8,0)
\end_layout

\begin_layout Plain Layout

	child[missing] {}
\end_layout

\begin_layout Plain Layout

	child[marked] {
\end_layout

\begin_layout Plain Layout

		child[marked] {
\end_layout

\begin_layout Plain Layout

			child[missing]{}
\end_layout

\begin_layout Plain Layout

			child {
\end_layout

\begin_layout Plain Layout

				child[missing]{}
\end_layout

\begin_layout Plain Layout

				child {
\end_layout

\begin_layout Plain Layout

					child[reg]{
\end_layout

\begin_layout Plain Layout

						child[unk]{node{?}}
\end_layout

\begin_layout Plain Layout

						child[unk]{node{?}}
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

					child[reg]{
\end_layout

\begin_layout Plain Layout

						child[unk]{node{?}}
\end_layout

\begin_layout Plain Layout

						child[unk]{node{?}}
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		child[reg] {
\end_layout

\begin_layout Plain Layout

			child[missing]{}
\end_layout

\begin_layout Plain Layout

			child {
\end_layout

\begin_layout Plain Layout

				child[missing]{}
\end_layout

\begin_layout Plain Layout

				child {
\end_layout

\begin_layout Plain Layout

					child[unk]{node{?}}
\end_layout

\begin_layout Plain Layout

					child[unk]{node{?}}
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	};
\end_layout

\begin_layout Plain Layout


\backslash
node[above of=Y] {If $
\backslash
varphi_n
\backslash
braket{k,d+1}=1$};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
The action of the second process.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Upon performing this action,
 after which we are sure that the marked path will definitely not agree with 
\begin_inset Formula $\varphi_{n}\braket{k,\cdot}$
\end_inset

,
 we increment the counter 
\begin_inset Formula $k$
\end_inset

.
\end_layout

\end_deeper
\end_deeper
\begin_layout Proof
The first process ensures that the resulting tree is computable:
 Given a node 
\begin_inset Formula $\sigma$
\end_inset

 for which we desire to know whether it is or not in 
\begin_inset Formula $T$
\end_inset

,
 we simply execute the algorithm until the first process has run at least 
\begin_inset Formula $\ell=\mathrm{length}(\sigma)$
\end_inset

 times;
 at this point we will have committed to adding or not adding every node up to depth 
\begin_inset Formula $\ell$
\end_inset

.
\end_layout

\begin_layout Proof
The resulting tree has no dead ends because neither process allows the creation of a dead end.
\end_layout

\begin_layout Proof
The resulting tree has all of its paths computable because all of its paths can be broken up into the following three categories
\begin_inset Foot
status open

\begin_layout Plain Layout
These three categories actually split the paths by their Cantor-Bendixson rank.
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The paths of some 
\begin_inset Formula $T_{n}$
\end_inset

 which have at some point split off from the marked path,
 or for which the second process associated to 
\begin_inset Formula $T_{n}$
\end_inset

 loops indefinitely,
 will only ever be affected by the first process,
 which results in the path having an infinite prefix of ones.
 This evidently makes it computable.
\end_layout

\begin_deeper
\begin_layout Standard
(We could also have argued using the fact that that these paths are isolated.)
\end_layout

\end_deeper
\begin_layout Itemize
The marked path of a given 
\begin_inset Formula $T_{n}$
\end_inset

 for which the second process never loops indefinitely is computable,
 as we can simply run the simulation to find the marked path to arbitrary accuracy.
\end_layout

\begin_layout Itemize
The only remaining path is the path that goes to the right forever,
 which is evidently computable.
\end_layout

\end_deeper
\begin_layout Proof
Finally,
 it is true by construction that the tree admits no computable enumeration of its paths:
 For any candidate total function 
\begin_inset Formula $\varphi_{n}$
\end_inset

,
 the marked path of 
\begin_inset Formula $T_{n}$
\end_inset

 will furnish a path that is missed by 
\begin_inset Formula $\varphi_{n}$
\end_inset

.
\end_layout

\begin_layout Section
Original Work
\end_layout

\begin_layout Subsection
A Degree Which Doesn't Enumerate Paths of Millar's Tree
\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\TM}{T_{\mathrm{M}}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\length}{\mathop{\mathrm{length}}}
\end_inset


\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $\TM$
\end_inset

,
 henceforth referred to as 
\begin_inset Quotes eld
\end_inset

Millar's Tree
\begin_inset Quotes erd
\end_inset

,
 be the tree constructed in the proof of Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:zeronotsatbounding"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
 In order to investigate the saturated bounding degrees,
 it is natural to ask what degrees enumerate paths of Millar's tree.
\end_layout

\begin_layout Standard
After thinking about the subject for some time,
 I came to conjecture that any nontrivial degree enumerates paths of 
\begin_inset Formula $\TM$
\end_inset

.
 In this section,
 I disprove this conjecture.
\end_layout

\begin_layout Proposition
There is a noncomputable degree 
\begin_inset Formula $d$
\end_inset

 which does not compute an enumeration of the paths of 
\begin_inset Formula $\TM$
\end_inset

.
\end_layout

\begin_layout Proof
We build a set 
\begin_inset Formula $A$
\end_inset

 (to represent the degree 
\begin_inset Formula $d$
\end_inset

 to be built) by defining an ever-increasing initial final segment.
 At stage 
\begin_inset Formula $s$
\end_inset

,
 let 
\begin_inset Formula $\sigma_{s}\in2^{<\omega}$
\end_inset

 be the initial segment we've constructed.
 Let 
\begin_inset Formula $\sigma_{-1}$
\end_inset

 be the empty string.
\end_layout

\begin_deeper
\begin_layout Itemize
At even stage 
\begin_inset Formula $s=2e$
\end_inset

:
 We ensure that 
\begin_inset Formula $A$
\end_inset

 is noncomputable.
 To do so,
 let 
\begin_inset Formula $x=\varphi_{e}(\length(\sigma_{s-1}))$
\end_inset

,
 if this expression converges.
 If it does let 
\begin_inset Formula $\sigma_{s}$
\end_inset

 be the result of appending 
\begin_inset Formula $1\overset{.}{-}x$
\end_inset

 to the end of 
\begin_inset Formula $\sigma_{s-1}$
\end_inset

.
 Otherwise,
 set 
\begin_inset Formula $\sigma_{s}=\sigma_{s-1}$
\end_inset

.
\end_layout

\begin_layout Itemize
At each odd stage 
\begin_inset Formula $s$
\end_inset

,
 we pay attention to a specific oracle program 
\begin_inset Formula $P$
\end_inset

,
 in such a way that each particular program is paid attention to an infinite number of times.
\end_layout

\begin_deeper
\begin_layout Standard
When paying attention to 
\begin_inset Formula $P$
\end_inset

 for the first time,
 we first ask whether there is an extension 
\begin_inset Formula $\sigma'$
\end_inset

 of 
\begin_inset Formula $\sigma=\sigma_{s-1}$
\end_inset

 such that,
 no matter the oracle we choose to extend 
\begin_inset Formula $\sigma'$
\end_inset

,
 
\begin_inset Formula $P$
\end_inset

 fails to be total.
 If there is such 
\begin_inset Formula $\sigma'$
\end_inset

,
 we set 
\begin_inset Formula $\sigma_{s}=\sigma'$
\end_inset

.
\end_layout

\begin_layout Standard
When paying attention to 
\begin_inset Formula $P$
\end_inset

 for the 
\begin_inset Formula $x+1$
\end_inset

-th time,
 we look the section 
\begin_inset Formula $P_{x}$
\end_inset

 (in the sense that 
\begin_inset Formula $P_{x}(y)$
\end_inset

 should be read as 
\begin_inset Formula $P\braket{x,y}$
\end_inset

).
 We see what 
\begin_inset Formula $P_{x}$
\end_inset

 does when given 
\begin_inset Formula $\sigma$
\end_inset

 as a(n incomplete) oracle,
 in particular we check is there is any extension 
\begin_inset Formula $\tau$
\end_inset

 of 
\begin_inset Formula $\sigma=\sigma_{s-1}$
\end_inset

 for which some converging initial segment of 
\begin_inset Formula $P_{x}^{\tau}$
\end_inset

 is an isolated node of 
\begin_inset Formula $\TM$
\end_inset

.
 If there is,
 we set 
\begin_inset Formula $\sigma_{s}=\tau$
\end_inset

.
\end_layout

\begin_layout Standard
If there is no such extension,
 let 
\begin_inset Formula $\sigma_{s}=\sigma$
\end_inset

.
\end_layout

\end_deeper
\end_deeper
\begin_layout Proof
Now,
 our claim is that the oracle 
\begin_inset Formula $A$
\end_inset

 obtained by the above procedure (which is evidently noncomputable) does not enumerate the paths of 
\begin_inset Formula $\TM$
\end_inset

.
 To this effect,
 suppose that it does,
 with oracle program 
\begin_inset Formula $P$
\end_inset

.
 In particular,
 
\begin_inset Formula $P^{A}$
\end_inset

 is total.
 Let 
\begin_inset Formula $s$
\end_inset

 be the first stage in which we paid attention to 
\begin_inset Formula $P$
\end_inset

,
 and let 
\begin_inset Formula $\sigma=\sigma_{s}$
\end_inset

.
\end_layout

\begin_layout Proof
We define the following 
\emph on
computable
\emph default
 enumeration of paths 
\begin_inset Formula $P'$
\end_inset

 of 
\begin_inset Formula $\TM$
\end_inset

.
 Given a string 
\begin_inset Formula $\tau$
\end_inset

 which extends 
\begin_inset Formula $\sigma$
\end_inset

 and 
\begin_inset Formula $x\in\N$
\end_inset

,
 the path 
\begin_inset Formula $P'_{\braket{\tau,x}}(y)$
\end_inset

 is given by evaluating 
\begin_inset Formula $P_{x}(y)$
\end_inset

 on the partial oracle 
\begin_inset Formula $\tau$
\end_inset

,
 with the caveat that when querying the oracle for elements past where 
\begin_inset Formula $\tau$
\end_inset

 is defined we nondeterministically find an extension of 
\begin_inset Formula $\tau$
\end_inset

 on which the program terminates at the given index.
 Such an extension exists because if it did not,
 we would have made 
\begin_inset Formula $P^{A}$
\end_inset

 nontotal when paying attention to 
\begin_inset Formula $P$
\end_inset

.
 We take care to ensure that for different choices of 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 the resulting extensions of 
\begin_inset Formula $\tau$
\end_inset

 are coherent with one another,
 so that for every 
\begin_inset Formula $\tau$
\end_inset

 there is an oracle 
\begin_inset Formula $B_{\tau}$
\end_inset

 such that 
\begin_inset Formula $P'_{\braket{\tau,x}}(y)=P_{x}^{B_{\tau}}(y)$
\end_inset

.
\end_layout

\begin_layout Proof
Since 
\begin_inset Formula $P'$
\end_inset

 is a computable enumeration of paths,
 there must be some marked path of 
\begin_inset Formula $\TM$
\end_inset

 that 
\begin_inset Formula $P'$
\end_inset

 misses,
 which in turn is attained by some row of 
\begin_inset Formula $P$
\end_inset

,
 say 
\begin_inset Formula $P_{x}^{A}$
\end_inset

.
 Now,
 this index 
\begin_inset Formula $x$
\end_inset

 is considered eventually when paying attention to 
\begin_inset Formula $P$
\end_inset

,
 let us say at stage 
\begin_inset Formula $s_{0}$
\end_inset

.
 Moreover,
 there is some stage 
\begin_inset Formula $s$
\end_inset

 past 
\begin_inset Formula $s_{0}$
\end_inset

where 
\begin_inset Formula $A$
\end_inset

 has already been well-defined enough to determine the stage at which 
\begin_inset Formula $P_{x}^{A}$
\end_inset

 outputs its first zero.
 Let 
\begin_inset Formula $\tau$
\end_inset

 be 
\begin_inset Formula $\sigma_{s}$
\end_inset

 at this stage.
 We conclude that 
\begin_inset Formula $P_{x}^{B_{\tau}}(y)$
\end_inset

 
\emph on
must
\emph default
 be a nonprincipal path,
 as otherwise 
\begin_inset Formula $P_{x}^{A}$
\end_inset

 would have been a principal path.
 Moreover,
 
\begin_inset Formula $P_{x}^{B_{\tau}}$
\end_inset

 must have its first zero at the same place as 
\begin_inset Formula $P_{x}^{A}$
\end_inset

,
 whence we conclude 
\begin_inset Formula $P_{x}^{B_{\tau}}=P_{x}^{A}$
\end_inset

,
 or,
 equivalently,
 
\begin_inset Formula $P'_{\braket{\tau,x}}=P_{x}$
\end_inset

.
 But this is a contradiction,
 as we assumed that 
\begin_inset Formula $P_{x}$
\end_inset

 was a path that is not enumerated by 
\begin_inset Formula $P'$
\end_inset

.
 This contradiction proves that indeed 
\begin_inset Formula $P^{A}$
\end_inset

 cannot enumerate all paths,
 and the proof is complete.
\end_layout

\begin_layout Subsection
No Particular Tree Will Solve Our Problem
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
I think this is wrong :(
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Genericity Applied to the Above Two Sections
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "C:/Users/gaming/Desktop/theorems/misc/logic/bibliography"
options "plain"
encoding "default"

\end_inset


\end_layout

\end_body
\end_document
