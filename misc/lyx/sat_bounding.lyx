#LyX 2.4 created this file. For more info see https://www.lyx.org/
\lyxformat 620
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble

\usepackage{fullpage}
\usepackage[cal=euler]{mathalpha}
\usepackage{tikz}
\usetikzlibrary{shapes}
\usetikzlibrary{positioning}
\usepackage{braket}
\end_preamble
\use_default_options true
\begin_modules
duarte_theorems
\end_modules
\maintain_unincluded_children no
\language english
\language_package default
\inputencoding auto-legacy
\fontencoding auto
\font_roman "lmodern" "default"
\font_sans "lmss" "default"
\font_typewriter "lmtt" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_roman_osf false
\font_sans_osf false
\font_typewriter_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 1
\output_sync_macro "\synctex=1"
\bibtex_command default
\index_command default
\float_placement h
\float_alignment class
\paperfontsize default
\spacing single
\use_hyperref false
\papersize letter
\use_geometry false
\use_package amsmath 2
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_formatted_ref 0
\use_minted 0
\use_lineno 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tablestyle default
\listings_params "basicstyle={\ttfamily\footnotesize},keepspaces=true,tabsize=4,breaklines=true,columns=fullflexible,mathescape=true"
\tracking_changes false
\output_changes false
\change_bars false
\postpone_fragile_content false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\docbook_table_output 0
\docbook_mathml_prefix 1
\end_header

\begin_body

\begin_layout Title
Originally:
 Notes on Saturated Bounding Degrees
\begin_inset Newline newline
\end_inset

Now,
 A Study On a Tree by Millar
\end_layout

\begin_layout Author
Duarte Maia
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "macros_logic.lyx"
literal "false"

\end_inset


\end_layout

\begin_layout Section
Main Question
\end_layout

\begin_layout Definition
A 
\emph on
TAC theory
\emph default
 is a decidable complete consistent theory 
\begin_inset Formula $T$
\end_inset

 whose types are all computable.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
A degree 
\begin_inset Formula $d$
\end_inset

 is said to be 
\emph on
saturated bounding
\emph default
 if,
 for any TAC theory 
\begin_inset Formula $T$
\end_inset

,
 
\begin_inset Formula $d$
\end_inset

 decides a saturated model of 
\begin_inset Formula $T$
\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
This means that 
\begin_inset Formula $d$
\end_inset

 computes the elementary diagram of the model in question.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We will prove below that every high degree is saturated bounding,
 as is every PA degree.
 The question we seek to answer is the following:
 
\emph on
Is every saturated bounding degree either high or PA?
\end_layout

\begin_layout Section
Background Results
\end_layout

\begin_layout Subsection
An Alternative Characterization
\end_layout

\begin_layout Definition
We say that 
\begin_inset Formula $T$
\end_inset

 is an NDEPACCT if it is a 
\emph on
computable (binary) tree
\emph default
 (CT) with 
\emph on
no dead ends
\emph default
 (NDE) 
\emph on
all of whose paths are computable
\emph default
 (PAC).
\end_layout

\begin_layout Remark
Here are two alternate name proposals for the above definitions.
 One of them is:
 
\nospellcheck on
PACNDEC
\nospellcheck default
 (
\begin_inset Quotes eld
\end_inset

Packing Deck
\begin_inset Quotes erd
\end_inset

).
 The other is 
\nospellcheck on
CNDEPAC
\nospellcheck default
 (
\begin_inset Quotes eld
\end_inset

Candy Pack
\begin_inset Quotes erd
\end_inset

).
 I think both are better than 
\nospellcheck on
NDEPACC
\nospellcheck default
.
 As of the moment,
 I am particularly partial to 
\begin_inset Quotes eld
\end_inset

Candy Pack Tree
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:altchr"

\end_inset

A degree 
\begin_inset Formula $d$
\end_inset

 is saturated bounding iff,
 whenever 
\begin_inset Formula $T$
\end_inset

 is an NDEPACCT,
 
\begin_inset Formula $d$
\end_inset

 computes an enumeration of all paths in 
\begin_inset Formula $T$
\end_inset

 (possibly with repetitions).
\end_layout

\begin_layout Proof
\begin_inset Formula $(\rightarrow)$
\end_inset

 Let 
\begin_inset Formula $T$
\end_inset

 be an arbitrary NDEPACCT.
 We will construct a certain TAC theory 
\begin_inset Formula $T'$
\end_inset

,
 and then we will show that from a saturated model of 
\begin_inset Formula $T'$
\end_inset

 we can effectively obtain an enumeration of all paths in 
\begin_inset Formula $T$
\end_inset

.
\end_layout

\begin_layout Proof
Consider the language 
\begin_inset Formula $\Lang$
\end_inset

 which consists of a countable number of unary predicate symbols 
\begin_inset Formula $p_{0}$
\end_inset

,
 
\begin_inset Formula $p_{1}$
\end_inset

,
 and so on.
 Define axioms for 
\begin_inset Formula $T'$
\end_inset

 as follows:
 For every binary string 
\begin_inset Formula $\sigma\in2^{<\omega}$
\end_inset

,
 if 
\begin_inset Formula $\sigma\in T$
\end_inset

 we add axioms saying:
 There exist infinitely many 
\begin_inset Formula $x$
\end_inset

 such that 
\begin_inset Formula $p_{0}(x)^{\sigma_{0}}\land\dots\land p_{n}(x)^{\sigma_{n}}$
\end_inset

,
 where we adopt the convention that 
\begin_inset Formula $P^{1}$
\end_inset

 means 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $P^{0}$
\end_inset

 means 
\begin_inset Formula $\neg P$
\end_inset

.
 If 
\begin_inset Formula $\sigma\notin T$
\end_inset

,
 we add an axiom saying that there is no such 
\begin_inset Formula $x$
\end_inset

.
 We verify that 
\begin_inset Formula $T'$
\end_inset

 is TAC.
\end_layout

\begin_deeper
\begin_layout Description
(
\begin_inset Formula $T'$
\end_inset


\begin_inset space ~
\end_inset

is
\begin_inset space ~
\end_inset

complete) It is a standard result that,
 over any language which admits only unary symbols,
 any sentence is provably equivalent to a Boolean combination of sentences of the form:
 There are at least 
\begin_inset Formula $n$
\end_inset

 distinct elements satisfying such-and-such combination of unary predicates.
 Our axiomatization of 
\begin_inset Formula $T'$
\end_inset

 decides every such sentence.
\end_layout

\begin_layout Description
(
\begin_inset Formula $T'$
\end_inset


\begin_inset space ~
\end_inset

is
\begin_inset space ~
\end_inset

consistent) A model of 
\begin_inset Formula $T'$
\end_inset

 is furnished by 
\begin_inset Formula $M=[T]\times\N$
\end_inset

.
 More concretely,
 our universe consists of countably many copies of every path of 
\begin_inset Formula $T$
\end_inset

.
 If 
\begin_inset Formula $(f,n)$
\end_inset

 is an element of 
\begin_inset Formula $M$
\end_inset

,
 we define 
\begin_inset Formula $p_{i}^{M}(f,n)=f_{i}$
\end_inset

.
\end_layout

\begin_layout Description
(
\begin_inset Formula $T'$
\end_inset


\begin_inset space ~
\end_inset

has
\begin_inset space ~
\end_inset

all
\begin_inset space ~
\end_inset

types
\begin_inset space ~
\end_inset

computable) Let 
\begin_inset Formula $\Sigma(\vec{x})$
\end_inset

 be a complete type in 
\begin_inset Formula $T'$
\end_inset

.
 By a refinement of the arguments referred to in the proof that 
\begin_inset Formula $T'$
\end_inset

 is complete,
 we know that a type is fully determined by its atomic part,
 i.e.
\begin_inset space ~
\end_inset

formulas of the form 
\begin_inset Formula $p_{i}(x_{j})$
\end_inset

,
 
\begin_inset Formula $\neg p_{i}(x_{j})$
\end_inset

,
 
\begin_inset Formula $x_{i}=x_{j}$
\end_inset

,
 and 
\begin_inset Formula $x_{i}\neq x_{j}$
\end_inset

.
 In other words,
 to specify 
\begin_inset Formula $\Sigma(\vec{x})$
\end_inset

,
 we need only specify equalities and inequalities between the 
\begin_inset Formula $x_{i}$
\end_inset

,
 and which predicates are satisfied by each 
\begin_inset Formula $x_{i}$
\end_inset

.
 Now,
 let us define 
\begin_inset Formula $f\in2^{\omega}$
\end_inset

 as to satisfy 
\begin_inset Formula $p_{k}(x_{i})^{f_{k}}\in\Sigma(\vec{x})$
\end_inset

 for all 
\begin_inset Formula $k$
\end_inset

.
 Then,
 since 
\begin_inset Formula $\Sigma$
\end_inset

 is consistent with 
\begin_inset Formula $T'$
\end_inset

,
 we must have that 
\begin_inset Formula $f$
\end_inset

 is a path in 
\begin_inset Formula $T$
\end_inset

,
 and hence 
\begin_inset Formula $f$
\end_inset

 is computable.
 Thus,
 the following data is enough to computably reconstruct 
\begin_inset Formula $\Sigma(\vec{x})$
\end_inset

:
 The equality relations between the 
\begin_inset Formula $x_{i}$
\end_inset

,
 and the finite number of computable paths corresponding to each 
\begin_inset Formula $x_{i}$
\end_inset

.
 This is evidently computable.
\end_layout

\end_deeper
\begin_layout Proof
Thus,
 
\begin_inset Formula $d$
\end_inset

 decides a saturated model 
\begin_inset Formula $M$
\end_inset

 of 
\begin_inset Formula $T'$
\end_inset

.
 This model is evidently infinite,
 so we may without loss of generality assume its universe to be 
\begin_inset Formula $\N$
\end_inset

.
 Finally,
 define the 
\begin_inset Formula $d$
\end_inset

-computable function
\begin_inset Formula 
\[
F(x,y)=\begin{cases}
1, & \text{if \ensuremath{M\vDash p_{y}[x]},}\\
0, & \text{otherwise.}
\end{cases}
\]

\end_inset

We claim that 
\begin_inset Formula $F$
\end_inset

 is an enumeration (with repetitions) of the paths in 
\begin_inset Formula $T$
\end_inset

.
 Indeed,
 since 
\begin_inset Formula $M$
\end_inset

 is a saturated model,
 it realizes any unary type.
 Moreover,
 any path 
\begin_inset Formula $f$
\end_inset

 in 
\begin_inset Formula $T$
\end_inset

 induces a consistent type 
\begin_inset Formula $\Sigma^{f}(x)=\{\,p_{i}(x)^{f_{i}}\mid i\in\N\,\}$
\end_inset

,
 which is therefore realized in 
\begin_inset Formula $M$
\end_inset

 by some 
\begin_inset Formula $x\in\N$
\end_inset

.
 Thus,
 the 
\begin_inset Formula $x$
\end_inset

-th row of 
\begin_inset Formula $F$
\end_inset

 will consist of the path 
\begin_inset Formula $f$
\end_inset

,
 and since this path is arbitrary,
 every path of 
\begin_inset Formula $T$
\end_inset

 is enumerated by 
\begin_inset Formula $F$
\end_inset

.
\begin_inset VSpace medskip
\end_inset


\begin_inset Formula $(\leftarrow)$
\end_inset

 Let us now suppose that 
\begin_inset Formula $d$
\end_inset

 computes an enumeration the paths of any NDEPACCT.
 Moreover,
 let 
\begin_inset Formula $T'$
\end_inset

 be a complete consistent computable theory (in the language 
\begin_inset Formula $\Lang$
\end_inset

) all of whose types are computable.
 We shall construct a 
\begin_inset Formula $d$
\end_inset

-decidable saturated model of 
\begin_inset Formula $T'$
\end_inset

,
 with recourse to the following theorem due to Morley 
\begin_inset CommandInset citation
LatexCommand cite
after "Theorem 6.1"
key "morley_computable_saturated"
literal "false"

\end_inset

 and Millar 
\begin_inset CommandInset citation
LatexCommand cite
after "Theorem 2"
key "millar"
literal "false"

\end_inset

,
 whose proof we reproduce in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:millar"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
\end_layout

\begin_deeper
\begin_layout Theorem*
\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:millar"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset


\end_layout

\end_inset

If 
\begin_inset Formula $T'$
\end_inset

 is a 
\begin_inset Formula $d$
\end_inset

-decidable theory such that there is a 
\begin_inset Formula $d$
\end_inset

-computable enumeration of the types of 
\begin_inset Formula $T'$
\end_inset

,
 then there is a 
\begin_inset Formula $d$
\end_inset

-computable countable saturated model of 
\begin_inset Formula $T'$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Proof
Thus,
 since 
\begin_inset Formula $T'$
\end_inset

 is known to be computable,
 it suffices to 
\begin_inset Formula $d$
\end_inset

-enumerate its types.
 We do this by creating a tree with the following appearance:
\end_layout

\begin_layout Proof
\begin_inset Float figure
placement document
alignment document
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[subtree/.style={draw,
 regular polygon,
 regular polygon sides=3,
 anchor=north}]
\end_layout

\begin_layout Plain Layout


\backslash
node (T) at (0,0) {$T
\backslash
;=$};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{scope}[shift={(2.5,2)}]
\end_layout

\begin_layout Plain Layout


\backslash
node[subtree] (I) at (-1,-1) {$T_1$};
\end_layout

\begin_layout Plain Layout


\backslash
node[subtree] (II) at (0,-2) {$T_2$};
\end_layout

\begin_layout Plain Layout


\backslash
node[subtree] (III) at (1,-3) {$T_3$};
\end_layout

\begin_layout Plain Layout


\backslash
node (ETC) at (3.5,-3.5) {$
\backslash
ddots$};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw (0,0) -- (I.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw (1,-1) -- (II.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw (2,-2) -- (III.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw (0,0) -- (ETC);
\end_layout

\begin_layout Plain Layout


\backslash
end{scope}
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
The tree we'll create.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Proof
Where each 
\begin_inset Formula $T_{n}$
\end_inset

 is a subtree that will be used to enumerate the types of arity 
\begin_inset Formula $n$
\end_inset

.
 If we can compute the 
\begin_inset Formula $T_{n}$
\end_inset

 uniformly,
 evidently we can also compute 
\begin_inset Formula $T$
\end_inset

.
 We now describe the procedure to compute 
\begin_inset Formula $T_{n}$
\end_inset

:
\end_layout

\begin_layout Proof
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Let $
\backslash
varphi_i(
\backslash
vec x)$ be an enumeration of the formulas in $n$ variables.
\end_layout

\begin_layout Plain Layout

To determine whether $
\backslash
sigma 
\backslash
in 2^{<
\backslash
omega}$ (of length $k$) is in $T_n$:
\end_layout

\begin_layout Plain Layout

  Is $T'$ consistent with $
\backslash
exists_{
\backslash
vec x} (
\backslash
varphi_0(
\backslash
vec x)^{
\backslash
sigma_0} 
\backslash
land 
\backslash
dots 
\backslash
land 
\backslash
varphi_{k-1}(
\backslash
vec x)^{
\backslash
sigma_{k-1}})$?
\end_layout

\begin_layout Plain Layout

  If yes,
 declare $
\backslash
sigma 
\backslash
in T_n$.
\end_layout

\begin_layout Plain Layout

  If not,
 declare $
\backslash
sigma 
\backslash
notin T_n$.
\end_layout

\end_inset


\end_layout

\begin_layout Proof
Evidently,
 a 
\begin_inset Formula $T'$
\end_inset

-type of arity 
\begin_inset Formula $n$
\end_inset

 is the same as a path in 
\begin_inset Formula $T_{n}$
\end_inset

.
 Moreover,
 the tree 
\begin_inset Formula $T$
\end_inset

 is computable and has no dead ends.
 Finally,
 all paths of 
\begin_inset Formula $T$
\end_inset

 are computable,
 as every path is either a 
\begin_inset Formula $T'$
\end_inset

-type (assumed to be computable) prefixed by a series of ones (as many as its arity) and a zero,
 or it's the all-ones path.
 Thus,
 
\begin_inset Formula $d$
\end_inset

 computes an enumeration of the paths of 
\begin_inset Formula $T$
\end_inset

,
 and it's not difficult to turn this into an enumeration of the 
\begin_inset Formula $T'$
\end_inset

-types.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
One has to be slightly careful in dealing with the all-ones path.
 A possible approach is to fix one particular type 
\begin_inset Formula $\Sigma$
\end_inset

,
 let 
\begin_inset Formula $f_{n}$
\end_inset

 be an enumeration of paths of 
\begin_inset Formula $T$
\end_inset

 which repeats every path infinitely many times,
 and define 
\begin_inset Formula $\Sigma_{n}$
\end_inset

 by:
 If 
\begin_inset Formula $f_{n}$
\end_inset

 starts with at most 
\begin_inset Formula $n$
\end_inset

 ones and a zero,
 set 
\begin_inset Formula $\Sigma_{n}$
\end_inset

to be the remainder.
 Otherwise,
 set 
\begin_inset Formula $\Sigma_{n}=\Sigma$
\end_inset

.
\end_layout

\end_inset

 Hence,
 we may apply Millar's theorem to obtain a 
\begin_inset Formula $d$
\end_inset

-computable saturated model of 
\begin_inset Formula $T'$
\end_inset

,
 and so 
\begin_inset Formula $d$
\end_inset

 is saturated bounding.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:altchr"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 actually proves something stronger than stated:
 
\begin_inset Formula $d$
\end_inset

 being saturated bounding is also equivalent to 
\begin_inset Formula $d$
\end_inset

 being 
\emph on
weakly saturated bounding
\emph default
,
 in the sense that it only computes (rather than decides) models of TAC theories.
\end_layout

\begin_layout Remark
In hindsight this isn't very surprising:
 here is a direct proof of equivalence.
 If 
\begin_inset Formula $d$
\end_inset

 is weakly saturated bounding,
 for any given TAC theory 
\begin_inset Formula $T$
\end_inset

 we can consider its Morleyization 
\begin_inset Formula $T^{*}$
\end_inset

.
 It shouldn't be hard to show that 
\begin_inset Formula $T^{*}$
\end_inset

 is also TAC,
 and so 
\begin_inset Formula $d$
\end_inset

 computes a model of 
\begin_inset Formula $T^{*}$
\end_inset

.
 But this is the same as to decide a model of 
\begin_inset Formula $T$
\end_inset

.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:millar"

\end_inset

Morley and Millar's Theorem
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:millar"

\end_inset

If 
\begin_inset Formula $T$
\end_inset

 is a 
\begin_inset Formula $d$
\end_inset

-decidable theory such that there is a 
\begin_inset Formula $d$
\end_inset

-computable enumeration of the types of 
\begin_inset Formula $T$
\end_inset

,
 then there is a 
\begin_inset Formula $d$
\end_inset

-computable countable saturated model of 
\begin_inset Formula $T$
\end_inset

.
\end_layout

\begin_layout Theorem
The following proof was constructed by myself.
 It is quite different from Millar's;
 his proof consists of constructing a homogeneous model which realizes every type.
 In hindsight,
 however,
 my approach closely resembles Morley's,
 who proved the theorem a couple years before Millar.
 His proof may be found in 
\begin_inset CommandInset citation
LatexCommand cite
key "morley_computable_saturated"
literal "false"

\end_inset

.
\end_layout

\begin_layout Proof
We will prove the theorem for the case 
\begin_inset Formula $d=0$
\end_inset

;
 the relativization is straight-forward.
\end_layout

\begin_layout Proof
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Right now,
 I think that a strategy close to my original one should work...
 I should tell myself why it doesn't,
 when I come to that conclusion.
\end_layout

\begin_layout Plain Layout
Hi,
 this is future self.
 The original one indeed doesn't work.
 The fact that you can decide 
\begin_inset Formula $T_{\text{curr}}+\Sigma_{0}(\vec{c}_{0},d_{p_{0}})$
\end_inset

 but not 
\begin_inset Formula $T_{\text{curr}}+\Sigma_{0}(\vec{c}_{0},d_{p_{0}})+\Sigma_{1}(\vec{c}_{1},d_{p_{1}})$
\end_inset

 is too troublesome.
 I will now try a slightly distinct approach.
\end_layout

\begin_layout Plain Layout
Future future self here.
 I think this approach works.
 But the notation is utter garbage.
 Note to self,
 find a better way to word it all.
 Maybe look at Morley's proof,
 it seems quite similar.
\end_layout

\end_inset


\end_layout

\begin_layout Proof
Let us establish two countable sets of fresh variables,
 
\begin_inset Formula $C=\{c_{i}\}_{i\in\N}$
\end_inset

 and 
\begin_inset Formula $D=\{d_{i}\}_{i\in\N}$
\end_inset

,
 and define 
\begin_inset Formula $T^{*}\supseteq T$
\end_inset

 as a decidable theory such that the constants 
\begin_inset Formula $c_{i}$
\end_inset

 form a set of Henkin witnesses.
 Thus,
 to decide a model of 
\begin_inset Formula $T^{*}$
\end_inset

 is the same as to complete it,
 and in this case the constants in 
\begin_inset Formula $C$
\end_inset

 (modulo provable equality) will furnish a model.
 As such,
 to ensure that this model is saturated,
 we need only fulfill the following countable number of constraints.
 Let 
\begin_inset Formula $\{\Sigma_{n}(\vec{x},y)\}_{n\in\N}$
\end_inset

 be an enumeration of the 
\begin_inset Formula $T$
\end_inset

-types,
 and 
\begin_inset Formula $\{\vec{c}_{n}\}_{n\in\N}$
\end_inset

 an enumeration of the tuples of constants from 
\begin_inset Formula $C$
\end_inset

.
 Then,
 we define:
\begin_inset Formula 
\[
P_{nk}\colon\quad\begin{array}{l}
\text{If we have not yet contradicted \ensuremath{\exists_{y}\Sigma_{n}(\vec{c}_{k},y)},}\\
\text{there should be some \ensuremath{d_{p}} such that we commit to satisfying \ensuremath{\Sigma_{n}(\vec{c}_{k},d_{p})}.}
\end{array}
\]

\end_inset

We will start with the theory 
\begin_inset Formula $T^{*}$
\end_inset

 and iterate over all sentences 
\begin_inset Formula $\varphi_{n}$
\end_inset

 in the language 
\begin_inset Formula $\Lang^{*}=\Lang\cup C\cup D$
\end_inset

,
 at each step committing to adding the sentence or its negation.
 We will strive to meet all constraints 
\begin_inset Formula $P_{nk}$
\end_inset

,
 but the major obstacle will be that we cannot computably tell whether we're trying to make incompatible or inconsistent commitments.
 As such,
 we may sometimes have to injure some of the requirements.
 If we contradict 
\begin_inset Formula $\exists_{y}\Sigma_{n}(\vec{c}_{k},y)$
\end_inset

,
 the requirement 
\begin_inset Formula $P_{nk}$
\end_inset

 is met forever,
 but it may happen that we are forced to contradict 
\begin_inset Formula $\Sigma_{n}(\vec{c}_{k},d_{p})$
\end_inset

.
 In this scenario,
 we may think to increase the index of 
\begin_inset Formula $d$
\end_inset

 and try to meet it again,
 but there is no apparent reason as yet for why we can force this increase to occur a finite number of times (which is necessary so that we have a fixed and particular element to realize the type 
\begin_inset Formula $\Sigma_{n}(\vec{c}_{k},y)$
\end_inset

).
 
\end_layout

\begin_layout Proof
To motivate the rest of the proof,
 we will first show that we can in fact meet any one fixed 
\begin_inset Formula $P_{nk}$
\end_inset

 without injury.
 The algorithm goes as follows.
 First,
 let 
\begin_inset Formula $N$
\end_inset

 be the largest index of a constant in 
\begin_inset Formula $\vec{c}_{k}$
\end_inset

.
 Then,
 let 
\begin_inset Formula $p$
\end_inset

 be large enough such that 
\begin_inset Formula $d_{p}$
\end_inset

 does not appear in any of the Henkin sentences 
\begin_inset Formula $\exists_{x}\varphi(x)\rightarrow\varphi(c_{i})$
\end_inset

 with 
\begin_inset Formula $i\leq N$
\end_inset

.
 Finally,
 we loop over the 
\begin_inset Formula $\Lang^{*}$
\end_inset

-sentences 
\begin_inset Formula $\varphi_{n}$
\end_inset

 and decide whether to add 
\begin_inset Formula $\varphi_{n}$
\end_inset

 or its negation via the following decision procedure:
\end_layout

\begin_layout Proof
\begin_inset Float algorithm
placement document
alignment document
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(1) Does $T_{
\backslash
text{curr}}$ force either $
\backslash
varphi_n$ or $
\backslash
neg
\backslash
varphi_n$?
\end_layout

\begin_layout Plain Layout

If so,
 add the one you are forced to add.
\end_layout

\begin_layout Plain Layout

If not:
\end_layout

\begin_layout Plain Layout

  (2) Does $
\backslash
varphi_n$ contradict $T_{
\backslash
text{curr}} + 
\backslash
Sigma_n(
\backslash
vec c_k,
 d_p)$?
\end_layout

\begin_layout Plain Layout

  If so,
 add $
\backslash
neg
\backslash
varphi_n$.
\end_layout

\begin_layout Plain Layout

  Otherwise,
 add $
\backslash
varphi_n$.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:onepnk"

\end_inset

Fulfilling one 
\begin_inset Formula $P_{nk}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Proof
We need to verify that the two steps marked 
\begin_inset Formula $(1)$
\end_inset

 and 
\begin_inset Formula $(2)$
\end_inset

 are computable.
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $(1)$
\end_inset

 Since 
\begin_inset Formula $T_{\text{curr}}$
\end_inset

 consists of 
\begin_inset Formula $T^{*}$
\end_inset

 plus a finite number of formulas,
 it is also decidable.
\end_layout

\begin_layout Itemize
\begin_inset Formula $(2)$
\end_inset

 This one is a little more complicated.
\end_layout

\begin_deeper
\begin_layout Standard
Let us suppose for the time being that 
\begin_inset Formula $T_{\text{curr}}+\Sigma_{n}(\vec{c}_{k},d_{p})+\varphi_{n}\vdash\bot$
\end_inset

.
 Then,
 there is 
\begin_inset Formula $\sigma\in\Sigma_{n}$
\end_inset

 such that
\begin_inset Formula 
\[
T^{*}\vdash\sigma(\vec{c}_{k},d_{p})\rightarrow\neg\varphi(\vec{c}_{k},d_{p},\vec{c}',\vec{d}'),
\]

\end_inset

where 
\begin_inset Formula $\varphi$
\end_inset

 is the conjunction of 
\begin_inset Formula $\varphi_{n}$
\end_inset

 and the finitely many formulas added between 
\begin_inset Formula $T^{*}$
\end_inset

 and 
\begin_inset Formula $T_{\text{curr}}$
\end_inset

,
 and 
\begin_inset Formula $\vec{c}'$
\end_inset

 and 
\begin_inset Formula $\vec{d}'$
\end_inset

 represent constants 
\begin_inset Formula $c$
\end_inset

 or 
\begin_inset Formula $d$
\end_inset

 that are used in 
\begin_inset Formula $\varphi_{n}$
\end_inset

 but aren't 
\begin_inset Formula $\vec{c}_{k}$
\end_inset

 nor 
\begin_inset Formula $d_{p}$
\end_inset

.
 We will show that these may be eliminated in some sense,
 so that the question boils down to asking whether a certain sentence (using only 
\begin_inset Formula $\vec{c}_{k}$
\end_inset

 and 
\begin_inset Formula $d_{p}$
\end_inset

) is in 
\begin_inset Formula $\Sigma_{n}$
\end_inset

 or not.
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $W(c_{0},\dots,c_{N},d_{0},\dots,d_{p-1})$
\end_inset

 be the conjunction of the Henkin sentences 
\begin_inset Formula $\exists_{x}\varphi(x)\rightarrow\varphi(c_{n})$
\end_inset

 with 
\begin_inset Formula $n\leq N$
\end_inset

.
 Then,
 a standard argument shows that
\begin_inset Formula 
\[
T^{*}\vdash\sigma(\vec{c}_{k},d_{p})\rightarrow\neg\varphi(\vec{c}_{k},d_{p},\vec{c}',\vec{d}')\quad\text{iff}\quad T\vdash\sigma(\vec{c}_{k},d_{p})\rightarrow(W\rightarrow\neg\varphi).
\]

\end_inset

Now,
 all constants 
\begin_inset Formula $c$
\end_inset

 and 
\begin_inset Formula $d$
\end_inset

 other than 
\begin_inset Formula $\vec{c}_{k}$
\end_inset

 and 
\begin_inset Formula $d_{p}$
\end_inset

 are mentioned only by 
\begin_inset Formula $W$
\end_inset

 and 
\begin_inset Formula $\varphi$
\end_inset

,
 and so may be replaced by arbitrary variables.
 Hence,
\begin_inset Formula 
\[
T^{*}\vdash\sigma(\vec{c}_{k},d_{p})\rightarrow\neg\varphi(\vec{c}_{k},d_{p},\vec{c}',\vec{d}')\quad\text{iff}\quad T\vdash\sigma(\vec{c}_{k},d_{p})\rightarrow\exists(W\rightarrow\neg\varphi),
\]

\end_inset

where 
\begin_inset Formula $\exists(W\rightarrow\neg\varphi)$
\end_inset

 is shorthand for replacing every 
\begin_inset Formula $c$
\end_inset

 or 
\begin_inset Formula $d$
\end_inset

 other than the ones mentioned above by existentially quantified variables.
 Note that the process of obtaining 
\begin_inset Formula $\exists(W\rightarrow\neg\varphi)$
\end_inset

 was uniform.
 Finally,
 we note that 
\begin_inset Formula $\sigma\rightarrow\exists(W\rightarrow\neg\varphi)$
\end_inset

 for some 
\begin_inset Formula $\sigma\in\Sigma_{n}$
\end_inset

 iff 
\begin_inset Formula $\exists(W\rightarrow\neg\varphi)$
\end_inset

 was already in 
\begin_inset Formula $\Sigma_{n}$
\end_inset

 to begin with,
 as this sentence only uses symbols from the original language 
\begin_inset Formula $\Lang$
\end_inset

 and the constants 
\begin_inset Formula $\vec{c}_{k}$
\end_inset

 and 
\begin_inset Formula $d_{p}$
\end_inset

.
\end_layout

\begin_layout Standard
In conclusion,
 we can tell whether 
\begin_inset Formula $T_{\text{curr}}+\Sigma_{n}(\vec{c}_{k},d_{p})+\varphi_{n}$
\end_inset

 is contradictory by checking whether the formula (in the variables 
\begin_inset Formula $\vec{c}_{k}$
\end_inset

 and 
\begin_inset Formula $d_{p}$
\end_inset

) 
\begin_inset Formula $\exists(W\rightarrow\neg\varphi)$
\end_inset

 is in the type 
\begin_inset Formula $\Sigma_{n}$
\end_inset

 or not.
\end_layout

\end_deeper
\end_deeper
\begin_layout Proof
Part 
\begin_inset Formula $(2)$
\end_inset

 will be particularly relevant in the sequence,
 so we give it its own role as a lemma.
\end_layout

\begin_deeper
\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:typedecidable"

\end_inset

Let 
\begin_inset Formula $T$
\end_inset

 be a decidable theory and 
\begin_inset Formula $\Sigma(\vec{x})$
\end_inset

 is a type over 
\begin_inset Formula $T$
\end_inset

.
 Moreover,
 let 
\begin_inset Formula $T^{*}$
\end_inset

 be a decidable extension of 
\begin_inset Formula $T$
\end_inset

 by Henkin witnesses 
\begin_inset Formula $\{c_{i}\}_{i\in\N}$
\end_inset

.
 Then,
 if 
\begin_inset Formula $\vec{c}$
\end_inset

 is a tuple of these new constants,
 the theory 
\begin_inset Formula $T^{*}+\Sigma(\vec{c})$
\end_inset

 is decidable.
 In particular,
 any finite extension of it is also decidable.
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $\hat{T}$
\end_inset

 be the theory resulting from Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:onepnk"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
 We wish to show that 
\begin_inset Formula $P_{nk}$
\end_inset

 is fulfilled.
 We show that one of two things happen:
 Either 
\begin_inset Formula $T^{*}$
\end_inset

 contradicted 
\begin_inset Formula $\exists_{y}\Sigma_{n}(\vec{c}_{k},y)$
\end_inset

 from the start,
 in which case 
\begin_inset Formula $P_{nk}$
\end_inset

 is fulfilled,
 or 
\begin_inset Formula $T^{*}$
\end_inset

 is consistent with 
\begin_inset Formula $\exists_{y}\Sigma_{n}(\vec{c}_{k},y)$
\end_inset

 at the start,
 in which case we will show that 
\begin_inset Formula $T^{*}$
\end_inset

 is consistent with 
\begin_inset Formula $\Sigma_{n}(\vec{c}_{k},d_{p})$
\end_inset

.
 From this it follows that the algorithm outlined above will also never contradict 
\begin_inset Formula $\Sigma_{n}(\vec{c}_{k},d_{p})$
\end_inset

,
 and so this type will be contained in the completion we've built.
\end_layout

\begin_layout Standard
Suppose that 
\begin_inset Formula $T^{*}+\Sigma_{n}(\vec{c}_{k},d_{p})\vdash\bot$
\end_inset

.
 Then,
 there is 
\begin_inset Formula $\sigma\in\Sigma_{n}$
\end_inset

 such that 
\begin_inset Formula $T^{*}\vdash\neg\sigma(\vec{c}_{k},d_{p})$
\end_inset

.
 If we define 
\begin_inset Formula $W$
\end_inset

 as in the above argument,
 we conclude that 
\begin_inset Formula $T\vdash W\rightarrow\neg\sigma$
\end_inset

.
 Since 
\begin_inset Formula $d_{p}$
\end_inset

 was chosen as not to appear in 
\begin_inset Formula $W$
\end_inset

,
 we then conclude 
\begin_inset Formula $T\vdash W\rightarrow\neg\exists_{y}\sigma(\vec{c}_{k},y)$
\end_inset

,
 and so 
\begin_inset Formula $T^{*}+\exists_{y}\Sigma_{n}(\vec{c}_{k},y)$
\end_inset

 is contradictory,
 as we wanted to show.
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset

Now,
 Millar's theorem consists of adapting the above strategy as to fulfill every 
\begin_inset Formula $P_{nk}$
\end_inset

 as opposed to just one.
 This turns out to be harder than expected,
 and the main reason is the following:
 Even though by Lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:typedecidable"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 it is the case that,
 for a single type 
\begin_inset Formula $\Sigma(\vec{c},d_{p})$
\end_inset

,
 the theory 
\begin_inset Formula $T_{\text{curr}}+\Sigma(\vec{c},d_{p})$
\end_inset

 is decidable,
 it is not the case that the theory obtained by considering two types simultaneously is.
 As such,
 it might be that at any stage neither type individually forces neither a sentence 
\begin_inset Formula $\varphi$
\end_inset

 nor its negation,
 but there are two types which together force,
 say,
 
\begin_inset Formula $\neg\varphi$
\end_inset

 to hold.
 But we did not know that at the time,
 and so we unknowingly set ourselves up for an injury down the line.
 And this might happen very often,
 so one type or another may never be witnessed by any 
\begin_inset Formula $d_{p}$
\end_inset

 because it keeps getting injured and its representative keeps jumping around.
\end_layout

\begin_layout Standard
A way to try to get around this is to attempt to collect several types into one overarching 
\nospellcheck on
megatype
\nospellcheck default
;
 e.g.
 given 
\begin_inset Formula $\Sigma_{0}(\vec{c}_{0},d_{p_{0}})$
\end_inset

 and 
\begin_inset Formula $\Sigma_{1}(\vec{c}_{1},d_{p_{1}})$
\end_inset

,
 attempt to find a type 
\begin_inset Formula $\Sigma_{01}(\vec{c}_{0},\vec{c}_{1},d_{p_{0}},d_{p_{1}})$
\end_inset

 which contains 
\begin_inset Formula $\Sigma_{0}(\vec{c}_{0},d_{p_{0}})\cup\Sigma_{1}(\vec{c}_{1},d_{p_{1}})$
\end_inset

.
 Then,
 instead of trying to do what 
\begin_inset Formula $\Sigma_{0}$
\end_inset

 and 
\begin_inset Formula $\Sigma_{1}$
\end_inset

 force individually,
 we do what 
\begin_inset Formula $\Sigma_{01}$
\end_inset

 forces.
\end_layout

\begin_layout Standard
This approach has an obvious problem:
 There is no effective way to find 
\begin_inset Formula $\Sigma_{01}$
\end_inset

 as above,
 if it exists.
 We can,
 however,
 guess a type.
 And if that type is the wrong one,
 we guess the next,
 and so on.
 If our guess is wrong,
 we can verify that in finite time and change our guess.
 Moreover,
 we will 
\emph on
eventually
\emph default
 hit upon a right guess.
 Thus,
 we have the right setup for a finite-injury type argument.
\end_layout

\begin_layout Standard
This isn't quite the full story,
 because in the meantime we may have committed to a formula which specifies some way in which 
\begin_inset Formula $\vec{c}_{0}$
\end_inset

 and 
\begin_inset Formula $\vec{c}_{1}$
\end_inset

 relate,
 which 
\begin_inset Formula $\Sigma_{01}$
\end_inset

 does not agree with.
 So when we are trying to find 
\begin_inset Formula $\Sigma_{01}$
\end_inset

,
 we also need to take care to find a type which is consistent with the formulas we've acquired so far.
\end_layout

\begin_layout Standard
Before describing the algorithm,
 here is some necessary notation:
\end_layout

\begin_layout Itemize
Given a collection of 
\begin_inset Formula $c$
\end_inset

-variables 
\begin_inset Formula $\vec{c}$
\end_inset

,
 the corresponding 
\emph on
Henkin formula
\emph default
 
\begin_inset Formula $W$
\end_inset

 is the conjunction of the least initial segment of Henkin formulas containing 
\begin_inset Formula $\exists_{x}\varphi(x)\rightarrow\varphi(c)$
\end_inset

 for 
\begin_inset Formula $c$
\end_inset

 in 
\begin_inset Formula $\vec{c}$
\end_inset

,
\end_layout

\begin_layout Itemize
At a given state,
 let 
\begin_inset Formula $\Phi$
\end_inset

 be the conjunction of all formulas we've committed to,
\end_layout

\begin_layout Itemize
We fix a 
\begin_inset Formula $d$
\end_inset

-computable enumeration of pairs 
\begin_inset Formula $(\Sigma_{i},\vec{c}_{i})$
\end_inset

 which covers all pairs of types and valid tuples,
\end_layout

\begin_layout Itemize
Over the course of the following algorithm,
 some indices will be said to be 
\emph on
fulfilled
\emph default
.
 This is because we've found that the formulas 
\begin_inset Formula $\exists_{y}\Sigma_{i}(\vec{c}_{i},y)$
\end_inset

 can no longer be a subset of the the final theory,
 and so there is no work to be done to ensure saturation regarding this type.
 When discussing enumerations 
\begin_inset Formula $\vec{c}_{0},\dots,\vec{c}_{i}$
\end_inset

,
 we introduce two notations that modify how this expression should be interpreted:
\end_layout

\begin_deeper
\begin_layout Itemize
When we write 
\begin_inset Formula $\vec{c}_{0},\overset{\nu}{\dots},\vec{c}_{i}$
\end_inset

,
 it should be understood that the tuples 
\begin_inset Formula $\vec{c}_{j}$
\end_inset

 for fulfilled indices 
\begin_inset Formula $j$
\end_inset

 are replaced by arbitrary fresh constants,
\end_layout

\begin_layout Itemize
When we write 
\begin_inset Formula $\vec{c}_{0},\overset{\times}{\dots},\vec{c}_{i}$
\end_inset

,
 it should be understood that the tuples 
\begin_inset Formula $\vec{c}_{j}$
\end_inset

 for fulfilled indices 
\begin_inset Formula $j$
\end_inset

 are removed.
\end_layout

\end_deeper
\begin_layout Standard
We may now describe the algorithm.
\end_layout

\end_deeper
\begin_layout Proof
\begin_inset Float algorithm
placement document
alignment document
wide false
sideways false
status open

\begin_layout Plain Layout
We will have three processes running concurrently:
\end_layout

\begin_layout Itemize
The first process will attempt to find,
 for increasing values of 
\begin_inset Formula $i$
\end_inset

,
 a sequence of types 
\begin_inset Formula $\Sigma_{0},\Sigma_{01},\Sigma_{012},\dots,\Sigma_{0\dots i}$
\end_inset

 such that 
\begin_inset Formula $\Sigma_{0\dots i+1}(\vec{x},\vec{x}',y,y')\supseteq\Sigma_{0\dots i}(\vec{x},y)\cup\Sigma_{i+1}(\vec{x}',y')$
\end_inset

.
 In parallel,
 it will try to falsify its previous choices by trying to find a formula that is in 
\begin_inset Formula $\Sigma_{0\dots i}$
\end_inset

 or in 
\begin_inset Formula $\Sigma_{i}$
\end_inset

 but not in 
\begin_inset Formula $\Sigma_{0\dots i+1}$
\end_inset

.
 In this scenario,
 it changes its guess for 
\begin_inset Formula $\Sigma_{0\dots i+1}$
\end_inset

,
 forgets all its guesses for greater values of 
\begin_inset Formula $i$
\end_inset

,
 and keeps trying.
 This process is performed so that every type can show up as a guess for 
\begin_inset Formula $\Sigma_{0\dots i}$
\end_inset

 infinitely often.
\end_layout

\begin_deeper
\begin_layout Plain Layout
When finding a new candidate for 
\begin_inset Formula $\Sigma_{0\dots i}$
\end_inset

,
 it will find the first new type such that 
\begin_inset Formula $\Sigma_{0\dots i}(\vec{c}_{0},\overset{\nu}{\dots},\vec{c}_{i},d_{p_{0}},\dots,d_{p_{i-1}},y)$
\end_inset

 is consistent with 
\begin_inset Formula $W+\Phi$
\end_inset

,
 where 
\begin_inset Formula $W$
\end_inset

 is the Henkin formula of the collection of 
\begin_inset Formula $\vec{c}$
\end_inset

 up to 
\begin_inset Formula $\vec{c}_{i}$
\end_inset

 and the ones used in 
\begin_inset Formula $\Phi$
\end_inset

.
 Note that consistency with 
\begin_inset Formula $W+\Phi$
\end_inset

 is the same as to be consistent with 
\begin_inset Formula $T_{\text{curr}}$
\end_inset

.
\end_layout

\begin_layout Plain Layout
When a new guess is made for 
\begin_inset Formula $\Sigma_{0\dots i}$
\end_inset

,
 this process will also pick a value of 
\begin_inset Formula $p_{i}$
\end_inset

 large enough that 
\begin_inset Formula $d_{p_{i}}$
\end_inset

is not in 
\begin_inset Formula $W$
\end_inset

.
 This guarantees that 
\begin_inset Formula $\Sigma_{0\dots i}(\vec{c}_{0},\overset{\nu}{\dots},\vec{c}_{i},d_{p_{0}},\dots,d_{p})$
\end_inset

 is consistent with 
\begin_inset Formula $T_{\text{curr}}$
\end_inset

,
 as from its perspective 
\begin_inset Formula $d_{p}$
\end_inset

 is equivalent to a fresh variable.
\end_layout

\end_deeper
\begin_layout Itemize
The second process will loop over sentences 
\begin_inset Formula $\varphi_{n}$
\end_inset

 and commit to either adding the formula or its negation to the theory.
 It will prioritize being consistent with 
\begin_inset Formula $\Sigma_{0\dots i}(\vec{c}_{0},\overset{\nu}{\dots},\vec{c}_{i},d_{p_{0}},\dots,d_{p_{i}})$
\end_inset

 for smaller values of 
\begin_inset Formula $i$
\end_inset

.
 It might be unable to be consistent with all the types we've established so far;
 it will try to be consistent with as large an initial segment as it can.
\end_layout

\begin_deeper
\begin_layout Plain Layout
In the event that it is impossible to be consistent with 
\begin_inset Formula $\Sigma_{0\dots i}$
\end_inset

 and 
\begin_inset Formula $\Sigma_{0\dots i+1}$
\end_inset

 at the same time,
 we signal to the first process that it should find a new candidate for 
\begin_inset Formula $\Sigma_{0\dots i+1}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
The third process will regularly check that 
\begin_inset Formula $T_{\text{curr}}$
\end_inset

 is consistent with 
\begin_inset Formula $\exists_{y}\Sigma_{i}(\vec{c}_{i},y)$
\end_inset

 for every value of 
\begin_inset Formula $i$
\end_inset

.
 If it ever finds an inconsistency,
 it marks the corresponding index as fulfilled.
 Moreover,
 it signals the first process to find new variables 
\begin_inset Formula $d_{p_{j}}$
\end_inset

 for 
\begin_inset Formula $j>i$
\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:hatt"

\end_inset

The Theory Used to Create a Saturated Model
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
This algorithm evidently produces a consistent decidable theory 
\begin_inset Formula $\hat{T}$
\end_inset

 at the end,
 and hence the 
\begin_inset Formula $c$
\end_inset

 constants mod provable equality form a model.
 It remains to verify that this algorithm produces a saturated model.
 Inductively on 
\begin_inset Formula $i\in\N$
\end_inset

,
 we show that if 
\begin_inset Formula $\exists_{y}\Sigma_{i}(\vec{c}_{i},y)$
\end_inset

 is contained in the final theory then there is 
\begin_inset Formula $d_{p_{i}}$
\end_inset

 such that 
\begin_inset Formula $\Sigma_{i}(\vec{c}_{i},d_{p_{i}})$
\end_inset

 is contained in the final theory.
\end_layout

\begin_layout Standard
Consider a stage after which the third process has already found all inconsistencies for indices below 
\begin_inset Formula $i$
\end_inset

.
 Moreover,
 assume (as part of an inductive reasoning) that 
\begin_inset Formula $\Sigma_{0\dots j}$
\end_inset

 and 
\begin_inset Formula $d_{p_{j}}$
\end_inset

 stabilize for 
\begin_inset Formula $j<i$
\end_inset

,
 and indeed that we are in a stage after which this has already occurred.
 We claim that 
\begin_inset Formula $\Sigma_{0\dots i}$
\end_inset

 (and corresponding 
\begin_inset Formula $d_{p_{i}}$
\end_inset

) will eventually stabilize.
\end_layout

\begin_layout Standard
Assume by contradiction that it does not.
 Then,
 it will over the course of execution take on all possible types such that 
\begin_inset Formula $\Sigma_{0\dots i}(\vec{c}_{0},\overset{\nu}{\dots},\vec{c}_{i},d_{p_{0}},\dots,d_{p_{i-1}},y)$
\end_inset

 is compatible with 
\begin_inset Formula $T_{\text{curr}}$
\end_inset

.
 As such,
 it will eventually take on a type which is a consistent extension of 
\begin_inset Formula $\bar{\Sigma}=\hat{T}|(\vec{c}_{0},\overset{\times}{\dots},\vec{c}_{i},d_{p_{0}},\dots,d_{p_{i-1}})+\Sigma_{0\dots i-1}(\vec{c}_{0},\overset{\nu}{\dots},\vec{c}_{i-1},d_{p_{0}},\dots,d_{p_{i-1}})+\Sigma_{i}(\vec{c}_{i},y)$
\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Some proof is required to conclude that 
\begin_inset Formula $\bar{\Sigma}$
\end_inset

 is a consistent set of formulas.
 The proof consists of noticing that,
 by construction of the second process,
 
\begin_inset Formula $\hat{T}$
\end_inset

 is constructed specifically so that this is the case.
\end_layout

\end_inset

 By inspection of the algorithm,
 from that moment onward the type will never change because it has no reason to:
 
\end_layout

\begin_layout Itemize
The first process will never force a change of type because 
\begin_inset Formula $\Sigma_{0\dots i}(\vec{c}_{0},\overset{\nu}{\dots},\vec{c}_{i},d_{p_{0}},\dots,d_{p_{i-1}},y)$
\end_inset

 is chosen as to extend 
\begin_inset Formula $\Sigma_{0\dots i-1}(\vec{c}_{0},\overset{\nu}{\dots},\vec{c}_{i-1},d_{p_{0}},\dots,d_{p_{i-1}})+\Sigma_{i}(\vec{c}_{i},y)$
\end_inset

 and 
\begin_inset Formula $\Sigma_{0\dots j}$
\end_inset

 has stabilized for 
\begin_inset Formula $j<i$
\end_inset

.
 
\end_layout

\begin_layout Itemize
The second process will never force a change of type because 
\begin_inset Formula $\Sigma_{0\dots i}(\vec{c}_{0},\overset{\nu}{\dots},\vec{c}_{i},d_{p_{0}},\dots,d_{p_{i-1}},y)$
\end_inset

 is chosen as to extend 
\begin_inset Formula $\hat{T}|(\vec{c}_{0},\overset{\times}{\dots},\vec{c}_{i},d_{p_{0}},\dots,d_{p_{i-1}})$
\end_inset

.
 
\end_layout

\begin_layout Itemize
The third process will never force a change of type because we've assumed that it has been triggered as many times as it ever will be below 
\begin_inset Formula $i$
\end_inset

.
\end_layout

\begin_layout Standard
We actually draw a stronger conclusion:
 This (being a consistent extension of 
\begin_inset Formula $\bar{\Sigma}$
\end_inset

) is,
 in fact,
 the only way the type can stabilize.
 Moreover,
 in this instance,
 we will by construction never commit to a formula that contradicts 
\begin_inset Formula $\Sigma_{0\dots i}(\vec{c}_{0},\dots,\vec{c}_{i},d_{p_{0}},\dots,d_{p_{i-1}},d_{p_{i}})$
\end_inset

,
 and so we conclude that 
\begin_inset Formula $d_{p_{i}}$
\end_inset

 will satisfy 
\begin_inset Formula $\Sigma_{i}(\vec{c}_{i},d_{p_{i}})$
\end_inset

.
 Since 
\begin_inset Formula $i$
\end_inset

 is an arbitrary unfulfilled index,
 we conclude that the model corresponding to 
\begin_inset Formula $\hat{T}$
\end_inset

 is in fact saturated.
\end_layout

\end_deeper
\begin_layout Subsection

\nospellcheck on
Subenumerative
\nospellcheck default
 Degrees
\end_layout

\begin_layout Definition
A degree 
\begin_inset Formula $d$
\end_inset

 is said to be 
\emph on
\nospellcheck on
subenumerative
\emph default
\nospellcheck default
 if it computes a 
\nospellcheck on
subenumeration
\nospellcheck default
 of the computable sets;
 that is,
 a function 
\begin_inset Formula $F\colon\N\times\N\to2$
\end_inset

 such that the collection of sections 
\begin_inset Formula $F_{s}$
\end_inset

 includes all characteristic functions of computable sets.
\end_layout

\begin_layout Theorem
A degree is 
\nospellcheck on
subenumerative
\nospellcheck default
 iff it is either high or PA.
\end_layout

\begin_layout Proof
I feel comfortable enough with the proof that I don't feel the need to write it out right now.
 It can be found in 
\begin_inset CommandInset citation
LatexCommand cite
key "jockusch_1972"
literal "false"

\end_inset

.
\end_layout

\begin_layout Subsection
The Converse of the Conjecture
\end_layout

\begin_layout Theorem
Every 
\nospellcheck on
subenumerative
\nospellcheck default
 degree is saturated bounding
\end_layout

\begin_layout Proof
We characterized a saturated bounding degree as one which,
 for every NDEPACCT 
\begin_inset Formula $T$
\end_inset

,
 computes an enumeration of the paths in 
\begin_inset Formula $T$
\end_inset

.
 However,
 it actually suffices to compute a listing of sets which includes the paths in 
\begin_inset Formula $T$
\end_inset

.
 This is because,
 since 
\begin_inset Formula $T$
\end_inset

 is computable with no dead ends,
 we can uniformly turn an arbitrary path into a path in 
\begin_inset Formula $T$
\end_inset

:
 Just follow along the path until you detect that you've left 
\begin_inset Formula $T$
\end_inset

,
 and from then on replace the path by the one obtained by going left whenever possible.
\end_layout

\begin_layout Proof
From this,
 the theorem becomes clear,
 as a 
\nospellcheck on
subenumerative
\nospellcheck default
 computes a listing of 
\emph on
all
\emph default
 computable sets,
 which in particular includes all paths in any NDEPACCT.
\end_layout

\begin_layout Subsection
\begin_inset Formula $0$
\end_inset

 is Not Saturated Bounding
\end_layout

\begin_layout Theorem
\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
Millar 
\begin_inset CommandInset citation
LatexCommand cite
key "millar"
literal "false"

\end_inset

,
 
\nospellcheck on
Goncharov
\nospellcheck default
–
\nospellcheck on
Nurtazin
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "thm:zeronotsatbounding"

\end_inset


\begin_inset Formula $0$
\end_inset

 is not saturated bounding.
\end_layout

\begin_layout Proof
We build an NDEPACCT 
\begin_inset Formula $T$
\end_inset

 for which there fails to have any computable enumeration of its paths.
 We've seen that if we enumerate 
\begin_inset Quotes eld
\end_inset

too many paths
\begin_inset Quotes erd
\end_inset

 we can always 
\begin_inset Quotes eld
\end_inset

prune the enumeration down
\begin_inset Quotes erd
\end_inset

,
 so this is done by ensuring that there is a path that fails to be enumerated.
\end_layout

\begin_layout Proof
Our tree 
\begin_inset Formula $T$
\end_inset

 will be built in the following shape:
\begin_inset Float figure
placement document
alignment document
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[subtree/.style={draw,
 regular polygon,
 regular polygon sides=3,
 anchor=north}]
\end_layout

\begin_layout Plain Layout


\backslash
node (T) at (0,0) {$T
\backslash
;=$};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{scope}[shift={(2.5,2)}]
\end_layout

\begin_layout Plain Layout


\backslash
node[subtree] (I) at (-1,-1) {$T_0$};
\end_layout

\begin_layout Plain Layout


\backslash
node[subtree] (II) at (0,-2) {$T_1$};
\end_layout

\begin_layout Plain Layout


\backslash
node[subtree] (III) at (1,-3) {$T_2$};
\end_layout

\begin_layout Plain Layout


\backslash
node (ETC) at (3.5,-3.5) {$
\backslash
ddots$};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw (0,0) -- (I.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw (1,-1) -- (II.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw (2,-2) -- (III.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw (0,0) -- (ETC);
\end_layout

\begin_layout Plain Layout


\backslash
end{scope}
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
The tree we'll create.
\end_layout

\end_inset


\end_layout

\end_inset

in which 
\begin_inset Formula $T_{n}$
\end_inset

 will have the role of preventing 
\begin_inset Formula $\varphi_{n}$
\end_inset

 from being an enumeration of the paths of 
\begin_inset Formula $T$
\end_inset

,
 by containing a path distinct from every row of 
\begin_inset Formula $\varphi_{n}$
\end_inset

.
\end_layout

\begin_layout Proof
To describe 
\begin_inset Formula $T_{n}$
\end_inset

,
 we shall describe a procedure such that at each stage we have a finite tree,
 with some leaves marked as 
\begin_inset Quotes eld
\end_inset

unknown
\begin_inset Quotes erd
\end_inset

.
 This should be taken to mean that we haven't decided whether the tree will branch off to that node or not.
 We will also be highlighting a path through this tree,
 which is the path that we ensure is 
\emph on
not
\emph default
 enumerated by 
\begin_inset Formula $\varphi_{n}$
\end_inset

.
 Here is a picture of what 
\begin_inset Formula $T$
\end_inset

 might look at a finite stage,
 with emphasis on 
\begin_inset Formula $T_{1}$
\end_inset

.
\end_layout

\begin_layout Proof
\begin_inset Float figure
placement document
alignment document
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[
\end_layout

\begin_layout Plain Layout

scale=0.7,
\end_layout

\begin_layout Plain Layout

subtree/.style={draw,
 regular polygon,
 regular polygon sides=3,
 anchor=north},
\end_layout

\begin_layout Plain Layout

unk/.style={sibling distance=0.5cm,
 level distance=8mm},
\end_layout

\begin_layout Plain Layout

edge from parent path={(
\backslash
tikzparentnode.south)--(
\backslash
tikzchildnode.north)},
\end_layout

\begin_layout Plain Layout

level distance=15mm,
\end_layout

\begin_layout Plain Layout

sibling distance=7cm,
\end_layout

\begin_layout Plain Layout

thetree/.style={sibling distance=2cm},
\end_layout

\begin_layout Plain Layout

reg/.style={thin},
\end_layout

\begin_layout Plain Layout

marked/.style={line width=1mm}]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
coordinate
\end_layout

\begin_layout Plain Layout

	child {node[subtree]{$T_0$}}
\end_layout

\begin_layout Plain Layout

	child {
\end_layout

\begin_layout Plain Layout

		child {node[draw,
 circle] {$T_1$}
\end_layout

\begin_layout Plain Layout

			[thetree]
\end_layout

\begin_layout Plain Layout

			child[reg] {
\end_layout

\begin_layout Plain Layout

				child[missing] {}
\end_layout

\begin_layout Plain Layout

				child {
\end_layout

\begin_layout Plain Layout

					child[unk] {node{?}}
\end_layout

\begin_layout Plain Layout

					child[unk] {node{?}}
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			child[marked] {
\end_layout

\begin_layout Plain Layout

				child[missing]{}
\end_layout

\begin_layout Plain Layout

				child {
\end_layout

\begin_layout Plain Layout

					child[missing] {}
\end_layout

\begin_layout Plain Layout

					child {
\end_layout

\begin_layout Plain Layout

						child {
\end_layout

\begin_layout Plain Layout

							child {
\end_layout

\begin_layout Plain Layout

								[reg]
\end_layout

\begin_layout Plain Layout

								child[unk] {node{?}}
\end_layout

\begin_layout Plain Layout

								child[unk] {node{?}}
\end_layout

\begin_layout Plain Layout

							}
\end_layout

\begin_layout Plain Layout

							child {
\end_layout

\begin_layout Plain Layout

								[reg]
\end_layout

\begin_layout Plain Layout

								child[unk] {node{?}}
\end_layout

\begin_layout Plain Layout

								child[unk] {node{?}}
\end_layout

\begin_layout Plain Layout

							}
\end_layout

\begin_layout Plain Layout

						}
\end_layout

\begin_layout Plain Layout

						child[reg] {
\end_layout

\begin_layout Plain Layout

							child[missing]{}
\end_layout

\begin_layout Plain Layout

							child {
\end_layout

\begin_layout Plain Layout

								child[unk] {node{?}}
\end_layout

\begin_layout Plain Layout

								child[unk] {node{?}}
\end_layout

\begin_layout Plain Layout

							}
\end_layout

\begin_layout Plain Layout

						}
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

			}		
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		child {
\end_layout

\begin_layout Plain Layout

			child {node[subtree]{$T_2$}}
\end_layout

\begin_layout Plain Layout

			child[edge from parent path={(
\backslash
tikzparentnode.south)--(
\backslash
tikzchildnode)}] {node {$
\backslash
ddots$}}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Formula $T$
\end_inset

 after a few stages.
\end_layout

\end_inset


\end_layout

\end_inset

The algorithm executes the following two processes in parallel:
\end_layout

\begin_deeper
\begin_layout Itemize
The first process will replace every left-facing 
\begin_inset Formula $?$
\end_inset

 by a non-branch,
 and every right-facing 
\begin_inset Formula $?$
\end_inset

 by a branch both of whose children are marked 
\begin_inset Formula $?$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement document
alignment document
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[
\end_layout

\begin_layout Plain Layout

scale=1,
\end_layout

\begin_layout Plain Layout

subtree/.style={draw,
 regular polygon,
 regular polygon sides=3,
 anchor=north},
\end_layout

\begin_layout Plain Layout

unk/.style={sibling distance=0.5cm,
 level distance=8mm},
\end_layout

\begin_layout Plain Layout

edge from parent path={(
\backslash
tikzparentnode.south)--(
\backslash
tikzchildnode.north)},
\end_layout

\begin_layout Plain Layout

level distance=15mm,
\end_layout

\begin_layout Plain Layout

sibling distance=2cm]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[coordinate] at (0,0) {}
\end_layout

\begin_layout Plain Layout

	child[unk] {node{?}}
\end_layout

\begin_layout Plain Layout

	child[unk] {node{?}};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw[->] (1,0) -- (2,0);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[coordinate] at (3,0){}
\end_layout

\begin_layout Plain Layout

	child[missing]{}
\end_layout

\begin_layout Plain Layout

	child{
\end_layout

\begin_layout Plain Layout

		child[unk]{node{?}}
\end_layout

\begin_layout Plain Layout

		child[unk]{node{?}}
\end_layout

\begin_layout Plain Layout

	};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
The action performed by the first process.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The second process will keep an internal counter 
\begin_inset Formula $k$
\end_inset

,
 which starts at 
\begin_inset Formula $k=0$
\end_inset

.
 The value of this counter dictates that this process will ensure that 
\begin_inset Formula $T$
\end_inset

 contains a path that is distinct from 
\begin_inset Formula $i\mapsto\varphi_{n}\braket{k,i}$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
At any given point,
 this process will be computing the path 
\begin_inset Formula $(\varphi_{n}\braket{k,0},\varphi_{n}\braket{k,1},\dots)$
\end_inset

 up to the depth of the marked path of 
\begin_inset Formula $T_{n}$
\end_inset

 (including the prefix 
\begin_inset Formula $\overset{n}{\overbrace{1\dots1}}0$
\end_inset

),
 
\emph on
plus one
\emph default
.
 At this stage (we can prove by induction that) that which lies below the marked node will look like this:
\begin_inset Float figure
placement document
alignment document
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[
\end_layout

\begin_layout Plain Layout

scale=0.5,
\end_layout

\begin_layout Plain Layout

subtree/.style={draw,
 regular polygon,
 regular polygon sides=3,
 anchor=north},
\end_layout

\begin_layout Plain Layout

unk/.style={sibling distance=0.5cm,
 level distance=8mm},
\end_layout

\begin_layout Plain Layout

edge from parent path={(
\backslash
tikzparentnode.south)--(
\backslash
tikzchildnode.north)},
\end_layout

\begin_layout Plain Layout

level distance=15mm,
\end_layout

\begin_layout Plain Layout

sibling distance=2cm,
\end_layout

\begin_layout Plain Layout

reg/.style={thin},
\end_layout

\begin_layout Plain Layout

marked/.style={line width=1mm}]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
coordinate (root)
\end_layout

\begin_layout Plain Layout

	child[missing] {}
\end_layout

\begin_layout Plain Layout

	child[marked] {
\end_layout

\begin_layout Plain Layout

		child[reg] {
\end_layout

\begin_layout Plain Layout

			child[missing]{}
\end_layout

\begin_layout Plain Layout

			child {
\end_layout

\begin_layout Plain Layout

				child[missing]{}
\end_layout

\begin_layout Plain Layout

				child {
\end_layout

\begin_layout Plain Layout

					child[unk]{node{?}}
\end_layout

\begin_layout Plain Layout

					child[unk]{node{?}}
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		child[reg] {
\end_layout

\begin_layout Plain Layout

			child[missing]{}
\end_layout

\begin_layout Plain Layout

			child {
\end_layout

\begin_layout Plain Layout

				child[missing]{}
\end_layout

\begin_layout Plain Layout

				child {
\end_layout

\begin_layout Plain Layout

					child[unk]{node{?}}
\end_layout

\begin_layout Plain Layout

					child[unk]{node{?}}
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[right of=root] {(depth $d$)};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Below a marked node.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this scenario,
 if the path 
\begin_inset Formula $\varphi_{n}\braket{k,\cdot}$
\end_inset

 went left,
 we stipulate that the marked path shall go right,
 and vice versa.
 Then,
 we make the marked path go as far down as we've constructed the tree,
 and add branches on both sides.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement document
alignment document
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[
\end_layout

\begin_layout Plain Layout

scale=0.5,
\end_layout

\begin_layout Plain Layout

subtree/.style={draw,
 regular polygon,
 regular polygon sides=3,
 anchor=north},
\end_layout

\begin_layout Plain Layout

unk/.style={sibling distance=0.5cm,
 level distance=8mm},
\end_layout

\begin_layout Plain Layout

edge from parent path={(
\backslash
tikzparentnode.south)--(
\backslash
tikzchildnode.north)},
\end_layout

\begin_layout Plain Layout

level distance=15mm,
\end_layout

\begin_layout Plain Layout

sibling distance=2cm,
\end_layout

\begin_layout Plain Layout

reg/.style={thin},
\end_layout

\begin_layout Plain Layout

marked/.style={line width=1mm}]
\end_layout

\begin_layout Plain Layout


\backslash
coordinate (X)
\end_layout

\begin_layout Plain Layout

	child[missing] {}
\end_layout

\begin_layout Plain Layout

	child[marked] {
\end_layout

\begin_layout Plain Layout

		child[reg] {
\end_layout

\begin_layout Plain Layout

			child[missing]{}
\end_layout

\begin_layout Plain Layout

			child {
\end_layout

\begin_layout Plain Layout

				child[missing]{}
\end_layout

\begin_layout Plain Layout

				child {
\end_layout

\begin_layout Plain Layout

					child[unk]{node{?}}
\end_layout

\begin_layout Plain Layout

					child[unk]{node{?}}
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		child[marked] {
\end_layout

\begin_layout Plain Layout

			child[missing]{}
\end_layout

\begin_layout Plain Layout

			child {
\end_layout

\begin_layout Plain Layout

				child[missing]{}
\end_layout

\begin_layout Plain Layout

				child {
\end_layout

\begin_layout Plain Layout

					child[reg]{
\end_layout

\begin_layout Plain Layout

						child[unk]{node{?}}
\end_layout

\begin_layout Plain Layout

						child[unk]{node{?}}
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

					child[reg]{
\end_layout

\begin_layout Plain Layout

						child[unk]{node{?}}
\end_layout

\begin_layout Plain Layout

						child[unk]{node{?}}
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	};
\end_layout

\begin_layout Plain Layout


\backslash
node[above of=X] {If $
\backslash
varphi_n
\backslash
braket{k,d+1}=0$};
\end_layout

\begin_layout Plain Layout


\backslash
coordinate (Y) at (8,0)
\end_layout

\begin_layout Plain Layout

	child[missing] {}
\end_layout

\begin_layout Plain Layout

	child[marked] {
\end_layout

\begin_layout Plain Layout

		child[marked] {
\end_layout

\begin_layout Plain Layout

			child[missing]{}
\end_layout

\begin_layout Plain Layout

			child {
\end_layout

\begin_layout Plain Layout

				child[missing]{}
\end_layout

\begin_layout Plain Layout

				child {
\end_layout

\begin_layout Plain Layout

					child[reg]{
\end_layout

\begin_layout Plain Layout

						child[unk]{node{?}}
\end_layout

\begin_layout Plain Layout

						child[unk]{node{?}}
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

					child[reg]{
\end_layout

\begin_layout Plain Layout

						child[unk]{node{?}}
\end_layout

\begin_layout Plain Layout

						child[unk]{node{?}}
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		child[reg] {
\end_layout

\begin_layout Plain Layout

			child[missing]{}
\end_layout

\begin_layout Plain Layout

			child {
\end_layout

\begin_layout Plain Layout

				child[missing]{}
\end_layout

\begin_layout Plain Layout

				child {
\end_layout

\begin_layout Plain Layout

					child[unk]{node{?}}
\end_layout

\begin_layout Plain Layout

					child[unk]{node{?}}
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	};
\end_layout

\begin_layout Plain Layout


\backslash
node[above of=Y] {If $
\backslash
varphi_n
\backslash
braket{k,d+1}=1$};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
The action of the second process.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Upon performing this action,
 after which we are sure that the marked path will definitely not agree with 
\begin_inset Formula $\varphi_{n}\braket{k,\cdot}$
\end_inset

,
 we increment the counter 
\begin_inset Formula $k$
\end_inset

.
\end_layout

\end_deeper
\end_deeper
\begin_layout Proof
The first process ensures that the resulting tree is computable:
 Given a node 
\begin_inset Formula $\sigma$
\end_inset

 for which we desire to know whether it is or not in 
\begin_inset Formula $T$
\end_inset

,
 we simply execute the algorithm until the first process has run at least 
\begin_inset Formula $\ell=\mathrm{length}(\sigma)$
\end_inset

 times;
 at this point we will have committed to adding or not adding every node up to depth 
\begin_inset Formula $\ell$
\end_inset

.
\end_layout

\begin_layout Proof
The resulting tree has no dead ends because neither process allows the creation of a dead end.
\end_layout

\begin_layout Proof
The resulting tree has all of its paths computable because all of its paths can be broken up into the following three categories
\begin_inset Foot
status open

\begin_layout Plain Layout
These three categories actually split the paths by their 
\nospellcheck on
Cantor-Bendixson
\nospellcheck default
 rank.
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The paths of some 
\begin_inset Formula $T_{n}$
\end_inset

 which have at some point split off from the marked path,
 or for which the second process associated to 
\begin_inset Formula $T_{n}$
\end_inset

 loops indefinitely,
 will only ever be affected by the first process,
 which results in the path having an infinite prefix of ones.
 This evidently makes it computable.
\end_layout

\begin_deeper
\begin_layout Standard
(We could also have argued using the fact that that these paths are isolated.)
\end_layout

\end_deeper
\begin_layout Itemize
The marked path of a given 
\begin_inset Formula $T_{n}$
\end_inset

 for which the second process never loops indefinitely is computable,
 as we can simply run the simulation to find the marked path to arbitrary accuracy.
\end_layout

\begin_layout Itemize
The only remaining path is the path that goes to the right forever,
 which is evidently computable.
\end_layout

\end_deeper
\begin_layout Proof
Finally,
 it is true by construction that the tree admits no computable enumeration of its paths:
 For any candidate total function 
\begin_inset Formula $\varphi_{n}$
\end_inset

,
 the marked path of 
\begin_inset Formula $T_{n}$
\end_inset

 will furnish a path that is missed by 
\begin_inset Formula $\varphi_{n}$
\end_inset

.
\end_layout

\begin_layout Proof
\begin_inset FormulaMacro
\newcommand{\TM}{T_{\mathrm{M}}}
\end_inset


\end_layout

\begin_layout Section
Original Work:
 Enumerations of 
\begin_inset Formula $[\TM]$
\end_inset


\end_layout

\begin_layout Subsection
A Degree Which Doesn't Enumerate Paths of Millar's Tree
\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\length}{\mathop{\mathrm{length}}}
\end_inset


\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $\TM$
\end_inset

,
 henceforth referred to as 
\begin_inset Quotes eld
\end_inset

Millar's Tree
\begin_inset Quotes erd
\end_inset

,
 be the tree constructed in the proof of Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:zeronotsatbounding"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
 In order to investigate the saturated bounding degrees,
 it is natural to ask what degrees enumerate paths of Millar's tree.
\end_layout

\begin_layout Standard
After thinking about the subject for some time,
 I came to conjecture that any nontrivial degree enumerates paths of 
\begin_inset Formula $\TM$
\end_inset

.
 In this section,
 I disprove this conjecture.
\end_layout

\begin_layout Proposition
There is a noncomputable degree 
\begin_inset Formula $d$
\end_inset

 which does not compute an enumeration of the paths of 
\begin_inset Formula $\TM$
\end_inset

.
\end_layout

\begin_layout Proof
We build a set 
\begin_inset Formula $A$
\end_inset

 (to represent the degree 
\begin_inset Formula $d$
\end_inset

 to be built) by defining an ever-increasing initial final segment.
 At stage 
\begin_inset Formula $s$
\end_inset

,
 let 
\begin_inset Formula $\sigma_{s}\in2^{<\omega}$
\end_inset

 be the initial segment we've constructed.
 Let 
\begin_inset Formula $\sigma_{-1}$
\end_inset

 be the empty string.
\end_layout

\begin_deeper
\begin_layout Itemize
At even stage 
\begin_inset Formula $s=2e$
\end_inset

:
 We ensure that 
\begin_inset Formula $A$
\end_inset

 is noncomputable.
 To do so,
 let 
\begin_inset Formula $x=\varphi_{e}(\length(\sigma_{s-1}))$
\end_inset

,
 if this expression converges.
 If it does let 
\begin_inset Formula $\sigma_{s}$
\end_inset

 be the result of appending 
\begin_inset Formula $1\overset{.}{-}x$
\end_inset

 to the end of 
\begin_inset Formula $\sigma_{s-1}$
\end_inset

.
 Otherwise,
 set 
\begin_inset Formula $\sigma_{s}=\sigma_{s-1}$
\end_inset

.
\end_layout

\begin_layout Itemize
At each odd stage 
\begin_inset Formula $s$
\end_inset

,
 we pay attention to a specific oracle program 
\begin_inset Formula $P$
\end_inset

,
 in such a way that each particular program is paid attention to an infinite number of times.
\end_layout

\begin_deeper
\begin_layout Standard
When paying attention to 
\begin_inset Formula $P$
\end_inset

 for the first time,
 we first ask whether there is an extension 
\begin_inset Formula $\sigma'$
\end_inset

 of 
\begin_inset Formula $\sigma=\sigma_{s-1}$
\end_inset

 such that,
 no matter the oracle we choose to extend 
\begin_inset Formula $\sigma'$
\end_inset

,
 
\begin_inset Formula $P$
\end_inset

 fails to be total.
 If there is such 
\begin_inset Formula $\sigma'$
\end_inset

,
 we set 
\begin_inset Formula $\sigma_{s}=\sigma'$
\end_inset

.
\end_layout

\begin_layout Standard
When paying attention to 
\begin_inset Formula $P$
\end_inset

 for the 
\begin_inset Formula $x+1$
\end_inset

-th time,
 we look the section 
\begin_inset Formula $P_{x}$
\end_inset

 (in the sense that 
\begin_inset Formula $P_{x}(y)$
\end_inset

 should be read as 
\begin_inset Formula $P\braket{x,y}$
\end_inset

).
 We see what 
\begin_inset Formula $P_{x}$
\end_inset

 does when given 
\begin_inset Formula $\sigma$
\end_inset

 as a(n incomplete) oracle,
 in particular we check is there is any extension 
\begin_inset Formula $\tau$
\end_inset

 of 
\begin_inset Formula $\sigma=\sigma_{s-1}$
\end_inset

 for which some converging initial segment of 
\begin_inset Formula $P_{x}^{\tau}$
\end_inset

 is an isolated node of 
\begin_inset Formula $\TM$
\end_inset

.
 If there is,
 we set 
\begin_inset Formula $\sigma_{s}=\tau$
\end_inset

.
\end_layout

\begin_layout Standard
If there is no such extension,
 let 
\begin_inset Formula $\sigma_{s}=\sigma$
\end_inset

.
\end_layout

\end_deeper
\end_deeper
\begin_layout Proof
Now,
 our claim is that the oracle 
\begin_inset Formula $A$
\end_inset

 obtained by the above procedure (which is evidently noncomputable) does not enumerate the paths of 
\begin_inset Formula $\TM$
\end_inset

.
 To this effect,
 suppose that it does,
 with oracle program 
\begin_inset Formula $P$
\end_inset

.
 In particular,
 
\begin_inset Formula $P^{A}$
\end_inset

 is total.
 Let 
\begin_inset Formula $s$
\end_inset

 be the first stage in which we paid attention to 
\begin_inset Formula $P$
\end_inset

,
 and let 
\begin_inset Formula $\sigma=\sigma_{s}$
\end_inset

.
\end_layout

\begin_layout Proof
We define the following 
\emph on
computable
\emph default
 enumeration of paths 
\begin_inset Formula $P'$
\end_inset

 of 
\begin_inset Formula $\TM$
\end_inset

.
 Given a string 
\begin_inset Formula $\tau$
\end_inset

 which extends 
\begin_inset Formula $\sigma$
\end_inset

 and 
\begin_inset Formula $x\in\N$
\end_inset

,
 the path 
\begin_inset Formula $P'_{\braket{\tau,x}}(y)$
\end_inset

 is given by evaluating 
\begin_inset Formula $P_{x}(y)$
\end_inset

 on the partial oracle 
\begin_inset Formula $\tau$
\end_inset

,
 with the caveat that when querying the oracle for elements past where 
\begin_inset Formula $\tau$
\end_inset

 is defined we nondeterministically find an extension of 
\begin_inset Formula $\tau$
\end_inset

 on which the program terminates at the given index.
 Such an extension exists because if it did not,
 we would have made 
\begin_inset Formula $P^{A}$
\end_inset

 nontotal when paying attention to 
\begin_inset Formula $P$
\end_inset

.
 We take care to ensure that for different choices of 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 the resulting extensions of 
\begin_inset Formula $\tau$
\end_inset

 are coherent with one another,
 so that for every 
\begin_inset Formula $\tau$
\end_inset

 there is an oracle 
\begin_inset Formula $B_{\tau}$
\end_inset

 such that 
\begin_inset Formula $P'_{\braket{\tau,x}}(y)=P_{x}^{B_{\tau}}(y)$
\end_inset

.
\end_layout

\begin_layout Proof
Since 
\begin_inset Formula $P'$
\end_inset

 is a computable enumeration of paths,
 there must be some marked path of 
\begin_inset Formula $\TM$
\end_inset

 that 
\begin_inset Formula $P'$
\end_inset

 misses,
 which in turn is attained by some row of 
\begin_inset Formula $P$
\end_inset

,
 say 
\begin_inset Formula $P_{x}^{A}$
\end_inset

.
 Now,
 this index 
\begin_inset Formula $x$
\end_inset

 is considered eventually when paying attention to 
\begin_inset Formula $P$
\end_inset

,
 let us say at stage 
\begin_inset Formula $s_{0}$
\end_inset

.
 Moreover,
 there is some stage 
\begin_inset Formula $s$
\end_inset

 past 
\begin_inset Formula $s_{0}$
\end_inset

where 
\begin_inset Formula $A$
\end_inset

 has already been well-defined enough to determine the stage at which 
\begin_inset Formula $P_{x}^{A}$
\end_inset

 outputs its first zero.
 Let 
\begin_inset Formula $\tau$
\end_inset

 be 
\begin_inset Formula $\sigma_{s}$
\end_inset

 at this stage.
 We conclude that 
\begin_inset Formula $P_{x}^{B_{\tau}}(y)$
\end_inset

 
\emph on
must
\emph default
 be a nonprincipal path,
 as otherwise 
\begin_inset Formula $P_{x}^{A}$
\end_inset

 would have been a principal path.
 Moreover,
 
\begin_inset Formula $P_{x}^{B_{\tau}}$
\end_inset

 must have its first zero at the same place as 
\begin_inset Formula $P_{x}^{A}$
\end_inset

,
 whence we conclude 
\begin_inset Formula $P_{x}^{B_{\tau}}=P_{x}^{A}$
\end_inset

,
 or,
 equivalently,
 
\begin_inset Formula $P'_{\braket{\tau,x}}=P_{x}$
\end_inset

.
 But this is a contradiction,
 as we assumed that 
\begin_inset Formula $P_{x}$
\end_inset

 was a path that is not enumerated by 
\begin_inset Formula $P'$
\end_inset

.
 This contradiction proves that indeed 
\begin_inset Formula $P^{A}$
\end_inset

 cannot enumerate all paths,
 and the proof is complete.
\end_layout

\begin_layout Subsection
Every Enumeration of Paths of Millar's Tree of a Certain Type is PA
\end_layout

\begin_layout Standard
In an attempt to investigate the degree of enumerations of paths of 
\begin_inset Formula $\TM$
\end_inset

,
 I thought to consider the following class of enumerations.
\end_layout

\begin_layout Definition
Let 
\begin_inset Formula $A\in2^{\omega}$
\end_inset

.
 Define 
\begin_inset Formula $M_{0}(A)$
\end_inset

 as the enumeration of paths of 
\begin_inset Formula $\TM$
\end_inset

 that is constructed in the following way.
 It is indexed on finite strings,
 producing for each 
\begin_inset Formula $\sigma$
\end_inset

 a path of 
\begin_inset Formula $\TM$
\end_inset

 which extends 
\begin_inset Formula $\sigma$
\end_inset

.
 If 
\begin_inset Formula $\sigma=1^{n}$
\end_inset

,
 we define 
\begin_inset Formula $M_{0}(A)_{\sigma}=1^{\omega}$
\end_inset

.
 If 
\begin_inset Formula $\sigma$
\end_inset

 is on an isolated node,
 
\begin_inset Formula $M_{0}(A)_{\sigma}$
\end_inset

 is forced to be the unique path extending that node.
 If 
\begin_inset Formula $\sigma=1^{n}0\tau$
\end_inset

 and 
\begin_inset Formula $\sigma$
\end_inset

 is on a marked node,
 
\begin_inset Formula $M_{0}(A)_{\sigma}$
\end_inset

 follows the marked path until (if ever) it stops,
 after which it goes the direction of 
\begin_inset Formula $A(n)$
\end_inset

 and thereafter follows the unique path.
\end_layout

\begin_layout Proposition
For every 
\begin_inset Formula $A$
\end_inset

,
 
\begin_inset Formula $M_{0}(A)\leq A\oplus0'$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Proposition
For every computable 
\begin_inset Formula $A$
\end_inset

,
 
\begin_inset Formula $M_{0}(A)\equiv0'$
\end_inset

.
\end_layout

\begin_layout Proof
Let 
\begin_inset Formula $P$
\end_inset

 be a Turing machine.
 We wish to determine whether 
\begin_inset Formula $P$
\end_inset

 halts,
 using access to 
\begin_inset Formula $M_{0}(A)$
\end_inset

 for some previously fixed computable 
\begin_inset Formula $A$
\end_inset

.
 To this effect,
 we build an enumeration of paths of 
\begin_inset Formula $\TM$
\end_inset

 using the Recursion Theorem.
\end_layout

\begin_layout Proof
Let 
\begin_inset Formula $e$
\end_inset

 be the index for the following array.
 Each of its rows consists of the same path,
 which starts with 
\begin_inset Formula $1^{e}0$
\end_inset

.
 Then,
 
\begin_inset Formula $P$
\end_inset

 is executed,
 after which 
\begin_inset Formula $A(e)$
\end_inset

 is printed,
 followed by a stream of 1s.
\end_layout

\begin_layout Proof
By the construction of Millar's tree it must be the case that,
 if 
\begin_inset Formula $\varphi_{e}$
\end_inset

 is total,
 the one row it prints repeatedly cannot agree with the marked path starting with 
\begin_inset Formula $1^{e}0$
\end_inset

.
 Therefore,
 in this case,
 the marked row (and hence the row indexed 
\begin_inset Formula $1^{e}0$
\end_inset

 of 
\begin_inset Formula $M_{0}(A)$
\end_inset

) starts:
 
\begin_inset Formula $1^{e}0(1-A(e))$
\end_inset

.
 Thus,
 we may look at the entry 
\begin_inset Formula $\braket{1^{e}0,e+1}$
\end_inset

 of 
\begin_inset Formula $M_{0}(A)$
\end_inset

 and compare it against 
\begin_inset Formula $A(e)$
\end_inset

:
 Agreement means that 
\begin_inset Formula $P$
\end_inset

 never halts,
 while disagreement means that 
\begin_inset Formula $P$
\end_inset

 halts.
\end_layout

\begin_layout Remark
Most information contained in 
\begin_inset Formula $M_{0}(A)$
\end_inset

 is redundant.
 All that we need is the rows indexed 
\begin_inset Formula $1^{e}0$
\end_inset

;
 from these we are able to reconstruct 
\begin_inset Formula $M_{0}(A)$
\end_inset

.
\end_layout

\begin_layout Definition
Given 
\begin_inset Formula $A\in2^{\omega}$
\end_inset

,
 we define 
\begin_inset Formula $M(A)(x,y)=M_{0}(A)(1^{x}0,y)$
\end_inset

.
\end_layout

\begin_layout Proposition
For every 
\begin_inset Formula $A\in2^{\omega}$
\end_inset

,
 we have 
\begin_inset Formula $M(A)\equiv M_{0}(A)$
\end_inset

.
 This equivalence is uniform.
\end_layout

\begin_layout Proof
The reducibility 
\begin_inset Formula $\geq$
\end_inset

 is obvious,
 so we prove 
\begin_inset Formula $\leq$
\end_inset

.
\end_layout

\begin_layout Proof
Given access to an oracle for 
\begin_inset Formula $M_{0}(A)$
\end_inset

,
 we show how to compute 
\begin_inset Formula $M(A)_{\sigma}$
\end_inset

.
 If 
\begin_inset Formula $\sigma=1^{n}$
\end_inset

,
 
\begin_inset Formula $M(A)_{\sigma}=1^{\omega}$
\end_inset

by definition.
 If 
\begin_inset Formula $\sigma=1^{n}0\tau$
\end_inset

,
 we compare 
\begin_inset Formula $\sigma$
\end_inset

 against the corresponding initial segment of 
\begin_inset Formula $M_{0}(A)_{n}$
\end_inset

.
 If they agree,
 we print out 
\begin_inset Formula $M_{0}(A)_{n}$
\end_inset

.
 If they disagree,
 it must be the case that 
\begin_inset Formula $\sigma$
\end_inset

 is an isolated node of 
\begin_inset Formula $\TM$
\end_inset

,
 in which case we print out the unique path extending 
\begin_inset Formula $\sigma$
\end_inset

.
\end_layout

\begin_layout Standard
We see that 
\begin_inset Formula $M$
\end_inset

 is an operation that takes sets to degrees.
 Note that it is not generally degree-invariant:
 Indeed,
 one can show that for every degree 
\begin_inset Formula $d\geq0'$
\end_inset

 there are representatives 
\begin_inset Formula $A\in d$
\end_inset

 such that 
\begin_inset Formula $M(A)$
\end_inset

 takes any value between 
\begin_inset Formula $0'$
\end_inset

 and 
\begin_inset Formula $d$
\end_inset

.
 That said,
 we have shown that for every 
\begin_inset Formula $A\in0$
\end_inset

 we have 
\begin_inset Formula $M(A)\equiv0'$
\end_inset

,
 so that raises the question of whether this is as low as it gets.
 This turns out not to be the case.
\end_layout

\begin_layout Definition
We define the partial function 
\begin_inset Formula $M(\bot)$
\end_inset

 as the 
\begin_inset Quotes eld
\end_inset

fixed part of 
\begin_inset Formula $M(A)$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 More concretely,
 we set 
\begin_inset Formula $M(\bot)_{n}$
\end_inset

 as a sequence beginning with 
\begin_inset Formula $1^{n}0$
\end_inset

,
 followed by the corresponding marked path as far as it goes,
 followed by an undefined,
 followed by 
\begin_inset Formula $0^{\omega}$
\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset Formula $M(\bot)$
\end_inset

 is a partial computable function.
\end_layout

\begin_layout Proof
We provide an algorithm to compute 
\begin_inset Formula $M(\bot)(n,x)$
\end_inset

.
\end_layout

\begin_layout Proof
If 
\begin_inset Formula $x\leq n$
\end_inset

 we output 
\begin_inset Formula $1$
\end_inset

,
 and if 
\begin_inset Formula $x=n+1$
\end_inset

 we output 
\begin_inset Formula $0$
\end_inset

.
 Otherwise,
 look at every node of 
\begin_inset Formula $\TM$
\end_inset

 of length 
\begin_inset Formula $x+1$
\end_inset

 which starts as 
\begin_inset Formula $1^{n}0$
\end_inset

;
 if all of them have the same 
\begin_inset Formula $x$
\end_inset

-th element,
 output that.
 Finally,
 if neither of the previous cases hold,
 execute the construction of Millar's tree until we've computed the marked path starting with 
\begin_inset Formula $1^{n}0$
\end_inset

 to length at least 
\begin_inset Formula $x$
\end_inset

.
 If this is ever done,
 we output the 
\begin_inset Formula $x$
\end_inset

th element of this path.
\end_layout

\begin_layout Proposition
There is a set 
\begin_inset Formula $A$
\end_inset

 such that 
\begin_inset Formula $M(A)$
\end_inset

 is low.
\end_layout

\begin_layout Proof
The collection of sets of the form 
\begin_inset Formula $M(A)$
\end_inset

 forms a 
\begin_inset Formula $\Pi_{1}^{0}$
\end_inset

 class,
 because these are the extensions of the partial computable function 
\begin_inset Formula $M(\bot)$
\end_inset

.
 Thus,
 it contains a low element.
\end_layout

\begin_layout Standard
This class of enumerations (and of degrees) was introduced because it could possibly be used to create a computationally weak enumeration of 
\begin_inset Formula $[\TM]$
\end_inset

.
 This turns out not to be the case.
\end_layout

\begin_layout Proposition
For every set 
\begin_inset Formula $A$
\end_inset

,
 the degree of 
\begin_inset Formula $M(A)$
\end_inset

 is PA.
\end_layout

\begin_layout Proof
As pointed out above,
 the collection of sets 
\begin_inset Formula $\{M(A)\}_{A\in2^{\omega}}$
\end_inset

 is exactly the collection of extensions of 
\begin_inset Formula $M(\bot)$
\end_inset

.
 Thus,
 it suffices to prove that 
\begin_inset Formula $M(\bot)$
\end_inset

 is computably not computably extendable 
\begin_inset CommandInset citation
LatexCommand cite
after "Theorem 3.10"
key "slicingthetruth"
literal "false"

\end_inset

.
 That is,
 we wish to find a function 
\begin_inset Formula $\psi\colon\N\rightharpoonup\N$
\end_inset

 such that,
 whenever 
\begin_inset Formula $\varphi_{e}$
\end_inset

 extends 
\begin_inset Formula $M(\bot)$
\end_inset

,
 we have 
\begin_inset Formula $\psi(e)\iswd$
\end_inset

 and 
\begin_inset Formula $\varphi_{e}(\psi(e))\isnotwd$
\end_inset

.
 To this effect,
 we shall apply the Recursion Theorem with Parameters.
\end_layout

\begin_layout Proof
Given 
\begin_inset Formula $e$
\end_inset

,
 we define 
\begin_inset Formula $\varphi_{f(e)}$
\end_inset

 as:
\begin_inset Formula 
\[
\varphi_{f(e)}\braket{n,x}=\varphi_{e}\braket{f(e),x}.
\]

\end_inset

Then,
 we claim that,
 by defining 
\begin_inset Formula $\psi(e)=\braket{f(e),f(e)+1}$
\end_inset

,
 we obtain the desired effective noncomputability.
\end_layout

\begin_layout Proof
To verify this claim,
 let us suppose that 
\begin_inset Formula $\varphi_{e}(\psi(e))\iswd=q$
\end_inset

.
 Then,
 the first (and indeed,
 every) row of 
\begin_inset Formula $\varphi_{f(e)}$
\end_inset

 has the following well-defined prefix:
 
\begin_inset Formula $1^{f(e)}0q$
\end_inset

.
 As such,
 the construction of Millar's tree guarantees that the marked section whose prefix is 
\begin_inset Formula $1^{f(e)}0$
\end_inset

 is followed by 
\begin_inset Formula $1-q$
\end_inset

,
 and so 
\begin_inset Formula $M(\bot)_{f(e)}$
\end_inset

 has 
\begin_inset Formula $1^{f(e)}0(1-q)$
\end_inset

 as a prefix;
 in other words,
 
\begin_inset Formula $M(\bot)\braket{f(e),f(e)+1}=M(\bot)(\psi(e))=1-q$
\end_inset

.
 Thus,
 
\begin_inset Formula $\varphi_{e}$
\end_inset

 cannot extend 
\begin_inset Formula $M(\bot)$
\end_inset

.
\end_layout

\begin_layout Remark
We also have the converse:
 Every PA degree is 
\begin_inset Formula $M(A)$
\end_inset

 for some 
\begin_inset Formula $A$
\end_inset

.
 This is direct from the fact that 
\begin_inset Formula $M(\bot)$
\end_inset

 is computably not computably extendable.
\end_layout

\begin_layout Subsection
Listing the Marked Paths is 
\begin_inset Formula $0''$
\end_inset


\end_layout

\begin_layout Standard
Another possible class of enumeration of paths of 
\begin_inset Formula $\TM$
\end_inset

 goes as follows.
 Since we can subenumerate the isolated paths,
 and we can always add the path 
\begin_inset Formula $1^{\omega}$
\end_inset

 to our list,
 to provide an enumeration of 
\begin_inset Formula $[\TM]$
\end_inset

 is equivalent to providing a subenumeration of the marked paths of 
\begin_inset Formula $\TM$
\end_inset

.
 This raises the question:
 What if we provide a 
\begin_inset Quotes eld
\end_inset

proper
\begin_inset Quotes erd
\end_inset

 enumeration of the marked paths?
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:listingzeroprime"

\end_inset

Any listing of the marked paths of 
\begin_inset Formula $\TM$
\end_inset

 computes 
\begin_inset Formula $0'$
\end_inset

.
\end_layout

\begin_layout Proof
First,
 we note that to list the marked paths is the same as to list the values of 
\begin_inset Formula $n$
\end_inset

 for which there's a marked path prefixed by 
\begin_inset Formula $1^{n}0$
\end_inset

.
 Thus,
 we suppose that we have such a listing 
\begin_inset Formula $f\colon\N\to\N$
\end_inset

.
\end_layout

\begin_layout Proof
We wish to determine whether a given Turing machine 
\begin_inset Formula $T$
\end_inset

 halts.
 We run two processes in parallel.
 One of them simply runs 
\begin_inset Formula $T$
\end_inset

 waiting for it to halt,
 outputting 
\begin_inset Quotes eld
\end_inset

yes
\begin_inset Quotes erd
\end_inset

 if this happens.
 We now describe the second process,
 which will output 
\begin_inset Quotes eld
\end_inset

no
\begin_inset Quotes erd
\end_inset

 if 
\begin_inset Formula $T$
\end_inset

 does not halt.
\end_layout

\begin_layout Proof
Using the Recursion Theorem,
 define 
\begin_inset Formula $e(T)$
\end_inset

 as the program which outputs the following (possibly partial) listing of paths:
\end_layout

\begin_deeper
\begin_layout Itemize
The first row of 
\begin_inset Formula $\varphi_{e(T)}$
\end_inset

 is 
\begin_inset Formula $1^{e(T)}0^{\omega}$
\end_inset

.
\end_layout

\begin_layout Itemize
The second row starts with 
\begin_inset Formula $1^{e(T)}01$
\end_inset

,
 followed by ones until the next branching of Millar's tree,
 after which it outputs zero.
\end_layout

\begin_layout Itemize
The third row starts with 
\begin_inset Formula $1^{e(T)}01$
\end_inset

,
 followed by ones until the 
\emph on
second
\emph default
 next branching of Millar's tree,
 after which it outputs zero.
\end_layout

\begin_layout Itemize
And so on...
\end_layout

\end_deeper
\begin_layout Proof
However,
 we add the following twist:
 We stipulate that 
\begin_inset Formula $\varphi_{e(T)}(x)$
\end_inset

 first executes 
\begin_inset Formula $T$
\end_inset

 for 
\begin_inset Formula $x$
\end_inset

 steps,
 and if 
\begin_inset Formula $T$
\end_inset

 halts in this time,
 we let 
\begin_inset Formula $\varphi_{e(T)}(x)\isnotwd$
\end_inset

.
\end_layout

\begin_layout Proof
Now that we've defined this enumeration of paths,
 we can define the second process introduced above.
 This second process simply looks through the enumeration 
\begin_inset Formula $f$
\end_inset

 to see if 
\begin_inset Formula $e(T)$
\end_inset

 ever appears;
 if it does,
 we output 
\begin_inset Quotes eld
\end_inset

no
\begin_inset Quotes erd
\end_inset

.
 Indeed,
 
\begin_inset Formula $e(T)$
\end_inset

 appears in this enumeration iff 
\begin_inset Formula $\varphi_{e(T)}$
\end_inset

 is total iff 
\begin_inset Formula $T$
\end_inset

 does not halt.
 This completes the proof.
\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\Tot}{\mathrm{Tot}}
\end_inset


\end_layout

\begin_layout Standard
By Lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:listingzeroprime"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 we conclude in particular that a listing of the marked paths of 
\begin_inset Formula $\TM$
\end_inset

 enumerates 
\begin_inset Formula $\Tot^{c}$
\end_inset

.
 We will now show that it also enumerates 
\begin_inset Formula $\Tot$
\end_inset

.
\end_layout

\begin_layout Proposition
Any listing of the marked paths of 
\begin_inset Formula $\TM$
\end_inset

 computes 
\begin_inset Formula $0''\equiv\Tot$
\end_inset

.
\end_layout

\begin_layout Proof
We apply a similar strategy as in Lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:listingzeroprime"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
 Given an index 
\begin_inset Formula $e$
\end_inset

,
 we define a program 
\begin_inset Formula $e_{0}(e)$
\end_inset

 using the Recursion Theorem in a similar way as in the lemma.
 However,
 the twist is replaced by the following.
 Before printing the 
\begin_inset Formula $n$
\end_inset

-th row,
 we evaluate 
\begin_inset Formula $\varphi_{e}(n)$
\end_inset

.
 Thus,
 if 
\begin_inset Formula $\varphi_{e}(n)\isnotwd$
\end_inset

 then 
\begin_inset Formula $\varphi_{e_{0}(e)}$
\end_inset

 has an undefined 
\begin_inset Formula $n$
\end_inset

-th row.
 Thus,
 if we ever find a marked path starting with 
\begin_inset Formula $1^{e_{0}(e)}0$
\end_inset

,
 we know that 
\begin_inset Formula $e\in\Tot$
\end_inset

.
\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rmk:neededpaths"

\end_inset

In the above proofs,
 we do not need a full listing of 
\emph on
all
\emph default
 the marked paths.
 We are only requiring a listing of all marked paths of the form 
\begin_inset Formula $1^{e}01^{\omega}$
\end_inset

.
 Conversely,
 we can modify the proof to require only a listing of all marked paths which contain infinitely many zeros.
 This will be relevant in the next section.
\end_layout

\begin_layout Subsection
Enumerations of Nontrivial Paths
\end_layout

\begin_layout Standard
Let us now consider an alternative way in which we could enumerate the paths of Millar's tree.
 We've seen that listing out the marked paths precisely,
 while a way to list the paths of 
\begin_inset Formula $\TM$
\end_inset

,
 is computationally very strong.
 Let us instead suppose that we are only given a listing of the marked paths in which some prefix of every marked path has been removed.
 In other words,
 we are given a listing 
\begin_inset Formula $A$
\end_inset

 of tails of marked paths,
 with the guarantee that for every marked path one of its tails is in this listing.
 It is almost true that 
\begin_inset Formula $A$
\end_inset

 is high,
 but a technical hurdle stops this from being the case.
\end_layout

\begin_layout Standard
Following the results of the previous section,
 it suffices to construct from 
\begin_inset Formula $A'$
\end_inset

 a listing of the marked paths of 
\begin_inset Formula $\TM$
\end_inset

.
 Here is a promising idea.
 Given a node 
\begin_inset Formula $\sigma$
\end_inset

 and an index 
\begin_inset Formula $i$
\end_inset

,
 we can ask 
\begin_inset Formula $A'$
\end_inset

 if 
\begin_inset Formula $\sigma A_{i}$
\end_inset

 is a path of 
\begin_inset Formula $\TM$
\end_inset

,
 where 
\begin_inset Formula $A_{i}(x)=A\braket{i,x}$
\end_inset

.
 For every such combination 
\begin_inset Formula $\braket{\sigma,i}$
\end_inset

,
 we enumerate the resulting path.
 Indeed,
 this will print out a listing containing all marked paths,
 
\emph on
but it will include some false positives
\emph default
.
 This is because some marked paths have 
\begin_inset Formula $1^{\omega}$
\end_inset

as a suffix,
 which is the same suffix as any non-marked path.
 Thus,
 in fact,
 the proposed construction will be a listing of 
\emph on
all
\emph default
 paths of 
\begin_inset Formula $\TM$
\end_inset

.
\end_layout

\begin_layout Standard
First,
 we propose a heavy-handed way of dodging the problem.
\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\TTM}{\tilde{T}_{\mathrm{M}}}
\end_inset


\end_layout

\begin_layout Definition
Define the 
\emph on
twiddly Millar's tree
\emph default
,
 denoted 
\begin_inset Formula $\TTM$
\end_inset

,
 as a tree constructed in the same way as Millar's tree,
 with the exception that whenever a marked path is extended,
 a zero is appended to its end.
 In this manner,
 
\begin_inset Formula $\TTM$
\end_inset

 has no marked path terminating in 
\begin_inset Formula $1^{\omega}$
\end_inset

.
 Aside from this change,
 everything said so far about 
\begin_inset Formula $\TM$
\end_inset

 applies just as well to 
\begin_inset Formula $\TTM$
\end_inset

.
\end_layout

\begin_layout Proposition
If 
\begin_inset Formula $A$
\end_inset

 is an enumeration of tails of marked paths of 
\begin_inset Formula $\TTM$
\end_inset

,
 
\begin_inset Formula $A$
\end_inset

 is high.
\end_layout

\begin_layout Proof
The argument explained at the start of this section suffices.
\end_layout

\begin_layout Standard
Of course,
 defining a brand new tree for convenience is a little dodgy.
 It is in some sense necessary,
 however:
 Since 
\begin_inset Formula $1^{\omega}$
\end_inset

 is a suffix of some marked paths,
 it turns out that enumerating suffixes of marked paths is exactly the same as enumerating suffixes of 
\emph on
all
\emph default
 the paths,
 which requires exactly as much computational power as enumerating all the paths.
\end_layout

\begin_layout Standard
On the other hand,
 we can consider an enumeration of something slightly different.
\end_layout

\begin_layout Definition
A path of 
\begin_inset Formula $\TM$
\end_inset

 is said to be 
\emph on
trivial
\emph default
 if it has finitely many zeros.
\end_layout

\begin_layout Proposition
If 
\begin_inset Formula $A$
\end_inset

 is an enumeration of tails of nontrivial paths of 
\begin_inset Formula $\TM$
\end_inset

,
 
\begin_inset Formula $A$
\end_inset

 is high.
\end_layout

\begin_layout Proof
Combining Remark 
\begin_inset CommandInset ref
LatexCommand ref
reference "rmk:neededpaths"

\end_inset

 with the argument at the start of this section,
 we see that 
\begin_inset Formula $A'$
\end_inset

 lists enough paths to enumerate 
\begin_inset Formula $\Tot$
\end_inset

.
\end_layout

\begin_layout Remark
A similar reasoning will prove that,
 if 
\begin_inset Formula $A$
\end_inset

 is an enumeration of nontrivial paths of 
\begin_inset Formula $\TM$
\end_inset

 with prefixes scrambled,
 then 
\begin_inset Formula $A$
\end_inset

 is high.
 In fact,
 this holds even if some rows of 
\begin_inset Formula $A$
\end_inset

 do not correspond to paths of 
\begin_inset Formula $\TM$
\end_inset

,
 so long as every row of 
\begin_inset Formula $A$
\end_inset

 contains infinitely many zeros.
\end_layout

\begin_layout Question*
Is every high degree represented in this manner?
\end_layout

\begin_layout Proposition
Every high degree 
\begin_inset Formula $d$
\end_inset

 computes an enumeration of nontrivial paths of 
\begin_inset Formula $\TM$
\end_inset

 whose prefixes have been scrambled.
\end_layout

\begin_layout Proof
It is not hard to see that 
\begin_inset Formula $0''$
\end_inset

 enumerates the set of indices of nontrivial paths of 
\begin_inset Formula $\TM$
\end_inset

.
 Indeed,
 
\begin_inset Formula $0''$
\end_inset

 can simply enumerate the total functions 
\begin_inset Formula $\varphi_{e}$
\end_inset

,
 and for each of these ask 
\begin_inset Formula $0'$
\end_inset

 if the resulting path is in 
\begin_inset Formula $\TM$
\end_inset

,
 and then ask 
\begin_inset Formula $0''$
\end_inset

 is it contains infinitely many zeros.
 Let 
\begin_inset Formula $f$
\end_inset

 be a 
\begin_inset Formula $0''$
\end_inset

-computable enumeration of this set.
 Now,
 given an arbitrary high degree 
\begin_inset Formula $d$
\end_inset

,
 let 
\begin_inset Formula $f_{s}$
\end_inset

 be a 
\begin_inset Formula $d$
\end_inset

-computable approximation of 
\begin_inset Formula $f$
\end_inset

.
 We now present a scrambled prefix enumeration of the nontrivial paths of 
\begin_inset Formula $\TM$
\end_inset

,
 which we call 
\begin_inset Formula $g\colon\N\times\N\to\N$
\end_inset

.
\end_layout

\begin_layout Proof
We define 
\begin_inset Formula $g_{n}(x)$
\end_inset

 as follows.
 First,
 compute 
\begin_inset Formula $f_{x}(n)$
\end_inset

 as an approximation of 
\begin_inset Formula $f(n)$
\end_inset

.
 Then,
 in parallel,
 compute 
\begin_inset Formula $\varphi_{f_{x}(n)}(x)$
\end_inset

 while you compute better approximations 
\begin_inset Formula $f_{x+1}(n)$
\end_inset

,
 
\begin_inset Formula $f_{x+2}(n)$
\end_inset

,
 etc.
 If the approximation ever changes,
 the first process shifts to computing 
\begin_inset Formula $\varphi_{f_{x'}(n)}(x)$
\end_inset

,
 where 
\begin_inset Formula $f_{x'}(n)$
\end_inset

 is the new approximation.
\end_layout

\begin_layout Proof
Since 
\begin_inset Formula $f_{x}(n)\underset{x\to\infty}{\to}f(n)$
\end_inset

,
 eventually the approximation settles on a total function and so the first process will necessarily terminate.
 Thus,
 
\begin_inset Formula $g_{n}(x)$
\end_inset

 is always well-defined.
 Moreover,
 for large enough values of 
\begin_inset Formula $x$
\end_inset

 the initial approximation is already 
\begin_inset Formula $f(n)$
\end_inset

,
 and so the 
\begin_inset Formula $n$
\end_inset

-th row of 
\begin_inset Formula $g$
\end_inset

 will always be a scrambled prefix version of 
\begin_inset Formula $\varphi_{f(n)}$
\end_inset

.
\end_layout

\begin_layout Standard
The situation is different for truncated prefixes.
 To understand why,
 consider the possibility that one could deduce the index of the current path from the spacing between its zeros.
 This is plausible because the position of the zeros is strongly related to 
\begin_inset Quotes eld
\end_inset

execution time
\begin_inset Quotes erd
\end_inset

,
 that is,
 the smallest value of 
\begin_inset Formula $s$
\end_inset

 for which 
\begin_inset Formula $\varphi_{e}(x)^{s}$
\end_inset

 is defined.
 With enough care,
 the spacing between these values might act as a 
\begin_inset Quotes eld
\end_inset

barcode
\begin_inset Quotes erd
\end_inset

 from which 
\begin_inset Formula $e$
\end_inset

 may be deduced.
 On the other hand,
 it is also plausible that we cannot conclude anything from this spacing,
 if these spacings are arranged maliciously as to ensure that any attempted deduction could very well be a fluke.
\end_layout

\begin_layout Standard
Another thing that introduces variance is the nitty-gritty details of the construction of Millar's tree,
 which have been irrelevant until now,
 and hence kept mostly unspecified.
 For the sake of definiteness,
 we make a grounding assumption.
\end_layout

\begin_layout Standard
\noindent
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\noindent

\series bold
Assumption 
\begin_inset CommandInset counter
LatexCommand addto
counter "theorem"
value "1"
lyxonly "true"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
refstepcounter{thm}
\backslash
arabic{thm}
\end_layout

\end_inset

:
\begin_inset CommandInset label
LatexCommand label
name "asmp:millar"

\end_inset


\series default
 Let 
\begin_inset Formula $\mu=1^{e}0\mu'$
\end_inset

 be a marked path of length 
\begin_inset Formula $N$
\end_inset

 up to a bifurcation point,
 which is assumed to be the 
\begin_inset Formula $k$
\end_inset

-th,
 and let 
\begin_inset Formula $\mu a1^{t}$
\end_inset

 be the continuation of the marked path up to the next bifurcation.
 Then,
 it is assumed that it takes 
\begin_inset Formula $t$
\end_inset

 steps to compute 
\begin_inset Formula $\varphi_{e}\braket{k,N}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rmk:asmpmillar"

\end_inset

Assumption 
\begin_inset CommandInset ref
LatexCommand ref
reference "asmp:millar"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 presupposes a slightly different construction of 
\begin_inset Formula $\TM$
\end_inset

 than the one we presented in Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:zeronotsatbounding"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
 Therein,
 it is assumed that we compute each row all the way up to a bifurcation before deciding which way the marked path will go.
 Here,
 we assume a more economical perspective,
 where only the relevant element of the row is computed.
\end_layout

\begin_layout Proposition
There is an interpretation of 
\begin_inset Quotes eld
\end_inset

runtime
\begin_inset Quotes erd
\end_inset

 for which any enumeration of tails of nontrivial paths of 
\begin_inset Formula $\TM$
\end_inset

 computes 
\begin_inset Formula $0''$
\end_inset

.
\end_layout

\begin_layout Proof
Let 
\begin_inset Formula $\varphi_{e}(x)^{s}$
\end_inset

 be a prior fixed interpretation of runtime,
 or computable approximation of a universal function.
 We define the new interpretation 
\begin_inset Formula $\psi(e,x,s)$
\end_inset

 as follows.
\end_layout

\begin_layout Proof
First,
 let 
\begin_inset Formula $\{p_{n}\}_{n\in\N}$
\end_inset

be an enumeration of the prime numbers in increasing order.
 Let 
\begin_inset Formula $e,x\in\N$
\end_inset

.
 Suppose that 
\begin_inset Formula $\varphi_{e}(x)$
\end_inset

 takes 
\begin_inset Formula $t$
\end_inset

 time to halt.
 If the result is 
\begin_inset Formula $0$
\end_inset

,
 we let the halting time of 
\begin_inset Formula $\psi(e,x)$
\end_inset

 be the smallest number above 
\begin_inset Formula $t$
\end_inset

 which is divisible by 
\begin_inset Formula $p_{0}\dots p_{e}$
\end_inset

.
 If the result is 
\begin_inset Formula $1$
\end_inset

,
 we let this halting time be the smallest number above 
\begin_inset Formula $t$
\end_inset

 which is divisible by 
\begin_inset Formula $p_{0}\dots p_{e-1}$
\end_inset

,
 and has remainder 
\begin_inset Formula $1$
\end_inset

 modulo 
\begin_inset Formula $p_{e}$
\end_inset

.
 The resulting 
\begin_inset Formula $\psi$
\end_inset

 is evidently computable.
\end_layout

\begin_layout Proof
We claim that,
 with the 
\begin_inset Formula $\psi$
\end_inset

 interpretation,
 any enumeration of tails of nontrivial paths computes 
\begin_inset Formula $0''$
\end_inset

,
 in the following manner.
 Let 
\begin_inset Formula $f_{n}$
\end_inset

 be a row of such an enumeration.
 Pick two positions of consecutive zeros of 
\begin_inset Formula $f_{n}$
\end_inset

,
 say 
\begin_inset Formula $x_{0}$
\end_inset

 and 
\begin_inset Formula $x_{1}$
\end_inset

.
 In other words,
 
\begin_inset Formula $f_{n}(x_{0})=f_{n}(x_{1})=0$
\end_inset

,
 and 
\begin_inset Formula $f_{n}(x)=1$
\end_inset

 for every 
\begin_inset Formula $x_{0}<x<x_{1}$
\end_inset

.
 This is possible to find because 
\begin_inset Formula $f_{n}$
\end_inset

 is assumed to have infinitely many zeros.
 Then,
 let 
\begin_inset Formula $p_{e}$
\end_inset

 be the smallest prime number such that 
\begin_inset Formula $\Delta x=x_{0}-x_{1}$
\end_inset

 is not divisible by 
\begin_inset Formula $p_{e}$
\end_inset

.
 Our claim is that 
\begin_inset Formula $f_{n}$
\end_inset

 is a truncated copy of of the marked path whose prefix is 
\begin_inset Formula $1^{e}0$
\end_inset

.
\end_layout

\begin_layout Proof
To prove this,
 let us look at the situation in the opposite way.
 Suppose that 
\begin_inset Formula $f_{n}$
\end_inset

 is a truncated copy of the path starting with 
\begin_inset Formula $1^{e}0$
\end_inset

,
 and we will show that the smallest prime that does not divide 
\begin_inset Formula $\Delta x$
\end_inset

 is 
\begin_inset Formula $p_{e}$
\end_inset

.
\end_layout

\begin_layout Proof
By Assumption 
\begin_inset CommandInset ref
LatexCommand ref
reference "asmp:millar"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 the time interval 
\begin_inset Formula $\Delta x$
\end_inset

 is given by the sum of the times it took 
\begin_inset Formula $\varphi_{e}$
\end_inset

 to evaluate some number of computations,
 of which all but one output 
\begin_inset Formula $0$
\end_inset

.
 All of these times,
 and hence 
\begin_inset Formula $\Delta x$
\end_inset

,
 are divisible by all primes below 
\begin_inset Formula $p_{e}$
\end_inset

.
 However,
 modulo 
\begin_inset Formula $p_{e}$
\end_inset

,
 all these times except the very last one contributed nothing,
 and the last one contributed one.
 Thus,
 
\begin_inset Formula $\Delta x\equiv1$
\end_inset

 modulo 
\begin_inset Formula $p_{e}$
\end_inset

,
 and our claim is proven.
\end_layout

\begin_layout Remark
The entire construction boils down to,
 as previously stated,
 ensuring that the location of the path is encoded into the spaces between its zeros.
 This could also be easily achieved if we were willing to modify the construction of Millar's tree;
 for example,
 if whenever a bifurcation occurs,
 a number of zeros is always printed out which encodes the subtree the marked path in question lies in.
\end_layout

\begin_layout Proposition
There is an interpretation of 
\begin_inset Quotes eld
\end_inset

runtime
\begin_inset Quotes erd
\end_inset

 under which any high degree computes an enumeration of tails of nontrivial paths of 
\begin_inset Formula $\TM$
\end_inset

.
\end_layout

\begin_layout Proof
Here is a rough sketch of the strategy.
 Given a high degree 
\begin_inset Formula $d$
\end_inset

,
 we are able to approximate such an enumeration,
 by optimistically assuming that below every node there is a nontrivial marked path,
 and following along it by using the marks.
 This will not always work:
 There are some nodes below which the marked path is trivial,
 and some others below which there is no marked path.
 However,
 a high degree – we will provide more detail later – is able to find out that a given path is a bad bet,
 back out of it,
 and go try another path.
 Now,
 the issue is that we can't just try another path at random:
 To match what we're trying to do,
 we need the path we change to to be 
\begin_inset Quotes eld
\end_inset

compatible
\begin_inset Quotes erd
\end_inset

 with the path that we already have (so that we get a nontrivial path with a prefix removed instead of one with a prefix scrambled).
 As such,
 we will game the runtime of our computation function to make sure that,
 no matter the prefix we've already established,
 there will be a nontrivial marked path we can switch to.
\end_layout

\begin_layout Proof
Now that the sketch has been established,
 let us construct our interpretation of runtime.
 Let 
\begin_inset Formula $\varphi_{e}(x)^{s}$
\end_inset

 be a prior established notion of runtime.
 We will define a new one from it,
 called 
\begin_inset Formula $\psi(e,x,s)$
\end_inset

.
 To do so,
 we first establish an infinite increasing sequence 
\begin_inset Formula $\{u_{n}\}_{n\in\N}$
\end_inset

 of indices such that every 
\begin_inset Formula $\varphi_{u_{n}}$
\end_inset

 is the total constant function equal to 
\begin_inset Formula $1$
\end_inset

.
 We also establish an enumeration 
\begin_inset Formula $\{\sigma_{n}\}_{n\in\N}$
\end_inset

 of finite sequences 
\begin_inset Formula $\N^{<\omega}$
\end_inset

 which repeats each sequence infinitely many often.
 Now we can define the runtime of 
\begin_inset Formula $\psi(e,x)$
\end_inset

:
 If 
\begin_inset Formula $e=u_{n}$
\end_inset

 for some value of 
\begin_inset Formula $n$
\end_inset

,
 and 
\begin_inset Formula $x<\length(\sigma_{n})$
\end_inset

,
 we define the runtime of 
\begin_inset Formula $\psi(e,x)$
\end_inset

 to be 
\begin_inset Formula $\sigma_{nx}$
\end_inset

.
 Otherwise,
 we let it be the same runtime as 
\begin_inset Formula $\varphi$
\end_inset

.
\end_layout

\begin_layout Proof
Let us now prove that,
 with this interpretation of runtime,
 any high degree can produce an enumeration of tails of nontrivial paths of 
\begin_inset Formula $\TM$
\end_inset

.
 Recall from Martin's theorem that our degree enumerates a function which dominates every computable function;
 we call it 
\begin_inset Formula $h$
\end_inset

.
 We will build an enumeration called 
\begin_inset Formula $f$
\end_inset

,
 indexed on pairs 
\begin_inset Formula $\braket{e,z}\in\N\times\N$
\end_inset

.
 On index 
\begin_inset Formula $\braket{e,z}$
\end_inset

,
 this enumeration shall begin printing out 
\begin_inset Formula $\varphi_{e}$
\end_inset

.
 If this function ever leaves Millar's tree,
 jump to 
\noun on
fallback
\noun default
 below.
 Moreover,
 keep a tally of the time it takes you to print out consecutive zeroes;
 If after the 
\begin_inset Formula $k$
\end_inset

-the zero you take more than 
\begin_inset Formula $h(k)+z$
\end_inset

 time to reach the next zero,
 jump to 
\noun on
fallback
\noun default
 as well.
\end_layout

\begin_layout Proof
Let us now define the 
\noun on
fallback
\noun default
 operation.
 Suppose that we have already printed out a finite sequence 
\begin_inset Formula $\tau$
\end_inset

.
 Let 
\begin_inset Formula $\sigma$
\end_inset

 be the sequence of intervals between consecutive zeros,
 and let 
\begin_inset Formula $n>e$
\end_inset

 be such that 
\begin_inset Formula $\sigma_{n}=\sigma$
\end_inset

.
 Then,
 by 
\noun on
fallback
\noun default
 we mean that we stop printing out 
\begin_inset Formula $\varphi_{e}$
\end_inset

 and instead start printing out the marked path whose prefix is 
\begin_inset Formula $1^{u_{n}}0$
\end_inset

.
 This is because,
 by definition,
 the marked path whose prefix is 
\begin_inset Formula $1^{u_{n}}0$
\end_inset

 proceeds as 
\begin_inset Formula $1^{\sigma_{n0}}0\dots01^{\sigma_{nN}}0$
\end_inset

,
 and so,
 the marked path in question will start out as 
\begin_inset Formula $1^{u_{n}-e}\tau$
\end_inset

.
 Thus,
 continuing to print out this marked path will yield a truncation of a nontrivial marked path.
\end_layout

\begin_layout Proof
This shows that every row of our enumeration will always be a nontrivial marked path.
 To show that every marked path 
\begin_inset Formula $\varphi_{e}$
\end_inset

 is a row of our enumeration,
 note that the computable function 
\begin_inset Quotes eld
\end_inset

time it takes to compute all elements between the 
\begin_inset Formula $n$
\end_inset

-th consecutive zeros of 
\begin_inset Formula $\varphi_{e}$
\end_inset


\begin_inset Quotes erd
\end_inset

 is dominated by 
\begin_inset Formula $h$
\end_inset

,
 and so for large enough values of 
\begin_inset Formula $z$
\end_inset

 we have 
\begin_inset Formula $f_{\braket{e,z}}=\varphi_{e}$
\end_inset

.
 The proof is complete.
\end_layout

\begin_layout Subsection
Nonrepeating Enumerations
\end_layout

\begin_layout Standard
Let us now return to the general context.
 One might think about types of enumerations of paths of 
\nospellcheck on
NDEPACC
\nospellcheck default
 trees,
 and whether they have additional computational power.
 One such example is whether it is harder to enumerate the paths of such a tree without any repetitions.
\end_layout

\begin_layout Proposition
Let 
\begin_inset Formula $T$
\end_inset

 be an 
\nospellcheck on
NDEPACC
\nospellcheck default
 tree with infinitely many paths,
 and let 
\begin_inset Formula $A$
\end_inset

 be an enumeration of these paths.
 Then,
 
\begin_inset Formula $A$
\end_inset

 computes an enumeration of these paths with no repetitions.
\end_layout

\begin_layout Proposition
More specifically,
 
\begin_inset Formula $A$
\end_inset

 computes a function 
\begin_inset Formula $f\colon\N\to\N$
\end_inset

 such that the sequence of paths 
\begin_inset Formula $A_{f(0)},A_{f(1)},\dots$
\end_inset

 is the desired enumeration.
\end_layout

\begin_layout Proof
We define 
\begin_inset Formula $f$
\end_inset

 inductively.
 Suppose that 
\begin_inset Formula $f(0),\dots,f(n-1)$
\end_inset

 have already been defined;
 we then define 
\begin_inset Formula $f(n)$
\end_inset

.
 First,
 we define
\begin_inset FormulaMacro
\newcommand{\upto}{\mathord{\upharpoonright}}
\end_inset


\begin_inset Formula 
\[
k(n)=\text{smallest \ensuremath{k} such that \ensuremath{\exists_{i<k}\forall_{j<k}\;A_{i}\upto^{k}\neq A_{f(j)}\upto^{k}}.}
\]

\end_inset


\end_layout

\begin_layout Proof
Then,
 we set 
\begin_inset Formula $f(n)$
\end_inset

 as the smallest value of 
\begin_inset Formula $i$
\end_inset

 satisfying the above condition.
 Note that 
\begin_inset Formula $k(n)$
\end_inset

 is well-defined because there must be a row 
\begin_inset Formula $k_{1}$
\end_inset

 which is distinct from 
\begin_inset Formula $A_{f(0)}$
\end_inset

,
 
\begin_inset Formula $\dots$
\end_inset

,
 and 
\begin_inset Formula $A_{f(n-1)}$
\end_inset

,
 and an index 
\begin_inset Formula $k_{2}$
\end_inset

 which suffices to distinguish 
\begin_inset Formula $A_{k_{1}}$
\end_inset

from all of those;
 then 
\begin_inset Formula $k(n)$
\end_inset

 will be well-defined and less than 
\begin_inset Formula $\max(k_{1},k_{2})$
\end_inset

.
\end_layout

\begin_layout Proof
By construction,
 it is evident that all the rows 
\begin_inset Formula $A_{f(n)}$
\end_inset

 are distinct.
 It remains to verify that every row of 
\begin_inset Formula $A$
\end_inset

 appears in the enumeration 
\begin_inset Formula $A_{f}$
\end_inset

.
 Thus,
 consider a fixed row of 
\begin_inset Formula $A$
\end_inset

;
 let 
\begin_inset Formula $e$
\end_inset

 be the minimal index for this row.
 Since 
\begin_inset Formula $A_{e}$
\end_inset

 is distinct from all prior rows,
 there is some value of 
\begin_inset Formula $k$
\end_inset

 such that 
\begin_inset Formula $(A_{e})_{0,\dots,k}$
\end_inset

 is distinct from the corresponding tuple for all prior rows.
 Then,
 consider a stage 
\begin_inset Formula $s\geq k$
\end_inset

 such that all rows prior to 
\begin_inset Formula $e$
\end_inset

 which were ever going to be enumerated have already been enumerated.
 It is easy to check that,
 if 
\begin_inset Formula $A_{e}$
\end_inset

 has not yet been enumerated,
 it will be so at stage 
\begin_inset Formula $s$
\end_inset

,
 which completes the proof.
\end_layout

\begin_layout Remark
This argument uses nothing about the fact that we are enumerating paths in a tree;
 it would just as well work on an enumeration of e.g.
\begin_inset space ~
\end_inset

computable sets.
\end_layout

\begin_layout Subsection
Winning Degrees
\end_layout

\begin_layout Standard
Here is an alternative characterization of the subenumerative degrees.
 One should envision the following definition as a set 
\begin_inset Formula $A$
\end_inset

 trying to 
\begin_inset Quotes eld
\end_inset

guess
\begin_inset Quotes erd
\end_inset

 the next element of a set 
\begin_inset Formula $B$
\end_inset

,
 using information about whether its previous guesses were right or wrong.
\end_layout

\begin_layout Definition
Let 
\begin_inset Formula $A$
\end_inset

 be a set,
 and 
\begin_inset Formula $e\in\N$
\end_inset

.
 Given a set 
\begin_inset Formula $B$
\end_inset

,
 we say that 
\begin_inset Formula $\{e\}^{A}\colon2^{<\omega}\to2$
\end_inset

 
\emph on
beats
\emph default
 
\begin_inset Formula $B$
\end_inset

 if,
 for all but finitely many prefixes 
\begin_inset Formula $\sigma b$
\end_inset

 of 
\begin_inset Formula $B$
\end_inset

,
 we have 
\begin_inset Formula $\{e\}^{A}(\sigma)=b$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
A set 
\begin_inset Formula $A$
\end_inset

 is said to be a 
\emph on
winning set
\emph default
,
 or to 
\emph on
beat all computable sets
\emph default
 if there is 
\begin_inset Formula $e\in\N$
\end_inset

 such that 
\begin_inset Formula $\{e\}^{A}$
\end_inset

 beats every computable set.
\end_layout

\begin_layout Proposition
\begin_inset Formula $A$
\end_inset

 is a winning set iff it belongs to a subenumerative degree.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\Linear}{\mathcal{L}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\barLinear}{\bar{\Linear}}
\end_inset


\end_layout

\end_deeper
\begin_layout Section
Original Work:
 Studying 
\begin_inset Formula $\Linear(\TM)$
\end_inset


\end_layout

\begin_layout Subsection
Background
\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\isop}[1]{[#1]^{\mathrm{iso}}}
\end_inset


\end_layout

\begin_layout Standard
Given a tree 
\begin_inset Formula $T$
\end_inset

,
 we define 
\begin_inset Formula $\isop T$
\end_inset

 as the set of isolated paths of 
\begin_inset Formula $T$
\end_inset

.
 We define 
\begin_inset Formula $\Linear(T)$
\end_inset

 as the linear order given by 
\begin_inset Formula $\isop T$
\end_inset

,
 ordered lexicographically.
\end_layout

\begin_layout Standard
Throughout this section,
 we work under Assumption 
\begin_inset CommandInset ref
LatexCommand ref
reference "asmp:millar"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 and more precisely the construction hinted at by Remark 
\begin_inset CommandInset ref
LatexCommand ref
reference "rmk:asmpmillar"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 regarding the construction of 
\begin_inset Formula $\TM$
\end_inset

.
\end_layout

\begin_layout Standard
The question we are trying to answer is whether the structure of 
\begin_inset Formula $\Linear(\TM)$
\end_inset

 is computable or not.
\end_layout

\begin_layout Standard
We will also investigate computability of 
\begin_inset Formula $\barLinear(T)$
\end_inset

,
 the lexicographic linear order on 
\begin_inset Formula $[T]$
\end_inset

.
\end_layout

\begin_layout Subsection
There Is No Computable Enumeration of 
\begin_inset Formula $\isop{\TM}$
\end_inset


\end_layout

\begin_layout Proposition
Let 
\begin_inset Formula $\varphi_{e}$
\end_inset

 be a computable enumeration of paths of 
\begin_inset Formula $\TM$
\end_inset

.
 If 
\begin_inset Formula $\varphi_{e}$
\end_inset

 has the property that,
 for every 
\begin_inset Formula $j$
\end_inset

,
 it enumerates a path starting with 
\begin_inset Formula $1^{j}0$
\end_inset

,
 then 
\begin_inset Formula $\varphi_{e}$
\end_inset

 enumerates a marked (i.e.
\begin_inset space \space{}
\end_inset

non-isolated) path.
\end_layout

\begin_layout Proof
We define a computable function 
\begin_inset Formula $\varphi_{\hat{e}}$
\end_inset

 by the recursion theorem,
 which we will then use to show that the marked path starting as 
\begin_inset Formula $1^{\hat{e}}0$
\end_inset

 is enumerated by 
\begin_inset Formula $\varphi_{e}$
\end_inset

.
\end_layout

\begin_layout Proof
Let 
\begin_inset Formula $y$
\end_inset

 be the first row of 
\begin_inset Formula $\varphi_{e}$
\end_inset

 starting as 
\begin_inset Formula $1^{\hat{e}}0$
\end_inset

 (this is where we use the assumption).
 We define 
\begin_inset Formula $\varphi_{\hat{e}}$
\end_inset

 as a function which diagonalizes against 
\begin_inset Formula $(\varphi_{e})_{y}$
\end_inset

.
 That is:
 we begin by setting 
\begin_inset Formula $\varphi_{\hat{e}}\braket{0,\hat{e}+1}=1-\varphi_{e}\braket{y,\hat{e}+1}$
\end_inset

.
 This ensures that 
\begin_inset Formula $(\varphi_{e})_{y}$
\end_inset

 starts following along the marked path,
 which is defined at least up to the second branching point.
 Then,
 if 
\begin_inset Formula $x_{1}$
\end_inset

 is the next branching point hit by 
\begin_inset Formula $(\varphi_{e})_{y}$
\end_inset

,
 we define 
\begin_inset Formula $\varphi_{\hat{e}}\braket{1,x_{1}}=1-\varphi_{e}\braket{y,x_{1}}$
\end_inset

,
 and so on,
 inductively ensuring that the marked path is defined to arbitrary depth,
 as well as ensuring that 
\begin_inset Formula $(\varphi_{e})_{y}$
\end_inset

 follows it forever.
\end_layout

\begin_layout Corollary
\begin_inset CommandInset label
LatexCommand label
name "cor:noenumiso"

\end_inset

There is no computable enumeration of 
\begin_inset Formula $\isop{\TM}$
\end_inset

.
\end_layout

\begin_layout Remark
The reason we were interested in this result is because,
 were it to hold false,
 we would have that 
\begin_inset Formula $\Linear(\TM)$
\end_inset

 is computable.
 The fact that 
\begin_inset Formula $\isop{\TM}$
\end_inset

 is 
\emph on
not
\emph default
 computable does not give us any information on the computability of 
\begin_inset Formula $\Linear(\TM)$
\end_inset

,
 however.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sec:tmpsi1"

\end_inset

A 
\nospellcheck on
CNDEPAC
\nospellcheck default
 Tree 
\begin_inset Formula $T$
\end_inset

 With 
\begin_inset Formula $\Linear(T)$
\end_inset

 Computable but 
\begin_inset Formula $\isop T$
\end_inset

 Non-Enumerable
\end_layout

\begin_layout Standard
We begin by noting that all the results on 
\begin_inset Formula $\TM$
\end_inset

 thus far have not depended on the particular choice of universal function,
 so long as it is computable and satisfies the s-m-n theorem (and hence the Recursion Theorem).
 Thus,
 in this section,
 we make the following choice.
 Given a previously fixed admissible choice of 
\begin_inset Formula $\varphi$
\end_inset

,
 we define
\begin_inset Formula 
\[
\psi_{e}(x)=\begin{cases}
\varphi_{k}(x) & \text{if \ensuremath{e=2k}}\\
y\bmod2 & \text{if \ensuremath{e} is odd and \ensuremath{x=\braket{y,z}}.}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
This satisfies the s-m-n theorem because,
 given a computable function 
\begin_inset Formula $f(x,y)$
\end_inset

,
 we can write it as 
\begin_inset Formula $\varphi_{s(x)}(y)$
\end_inset

,
 and hence as 
\begin_inset Formula $\psi_{2s(x)}(y)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\TMpsi}{\TM^{\psi}}
{T_{\mathrm{M}}^{\psi}}
\end_inset


\end_layout

\begin_layout Standard
Now,
 let 
\begin_inset Formula $\TMpsi$
\end_inset

 be Millar's tree,
 constructed from the universal function 
\begin_inset Formula $\psi$
\end_inset

.
 By Corollary 
\begin_inset CommandInset ref
LatexCommand ref
reference "cor:noenumiso"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 we conclude that there is no computable enumeration of 
\begin_inset Formula $\isop{\TMpsi}$
\end_inset

,
 so it suffices to prove that 
\begin_inset Formula $\Lang(\TMpsi)$
\end_inset

 is a computable structure.
\end_layout

\begin_layout Standard
First,
 let us 
\begin_inset Note Note
status open

\begin_layout Plain Layout

\nospellcheck on
todo
\nospellcheck default
 finish
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
On Enumerability of 
\begin_inset Formula $[T]$
\end_inset

 vs.
 
\begin_inset Formula $\isop T$
\end_inset


\end_layout

\begin_layout Standard
Given a 
\nospellcheck on
CNDEPAC
\nospellcheck default
 tree,
 one might wonder whether there is a relation between the enumerability of 
\begin_inset Formula $[T]$
\end_inset

 vs.
 that of 
\begin_inset Formula $\isop T$
\end_inset

.
 We present information on three of the possible combinations:
\end_layout

\begin_layout Itemize
It is possible that both 
\begin_inset Formula $[T]$
\end_inset

 and 
\begin_inset Formula $\isop T$
\end_inset

 are c.e,
 for example if 
\begin_inset Formula $T$
\end_inset

 has very simple path structure.
\end_layout

\begin_layout Itemize
By Corollary 
\begin_inset CommandInset ref
LatexCommand ref
reference "cor:noenumiso"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 Millar's Tree shows that it's possible for neither 
\begin_inset Formula $[T]$
\end_inset

 nor 
\begin_inset Formula $\isop T$
\end_inset

 to be enumerable.
\end_layout

\begin_layout Itemize
Adapting an argument by Hirschfeldt 
\begin_inset CommandInset citation
LatexCommand cite
key "hirschfeldt_2006"
literal "false"

\end_inset

,
 it is possible to show that from an enumeration of 
\begin_inset Formula $[T]$
\end_inset

 one can uniformly obtain an enumeration of 
\begin_inset Formula $\isop T$
\end_inset

.
 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Sketch:
 Using the enumeration of 
\begin_inset Formula $[T]$
\end_inset

,
 diagonalize to construct a sequence in 
\begin_inset Formula $2^{\omega}$
\end_inset

 that agrees with no path.
 Then,
 apply Hirschfeldt's argument with this sequence in place of the noncomputable set.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It remains open (to me) whether it is possible to construct a tree 
\begin_inset Formula $T$
\end_inset

 such that 
\begin_inset Formula $[T]$
\end_inset

 is not enumerable but 
\begin_inset Formula $\isop T$
\end_inset

 is.
\end_layout

\begin_layout Subsection
Isolated Points of Computable Orders
\end_layout

\begin_layout Proposition
\begin_inset FormulaMacro
\newcommand{\iso}{\text{iso}}
\end_inset

If 
\begin_inset Formula $A$
\end_inset

 is a computably representable complete linearly ordered set,
 
\begin_inset Formula $A^{\iso}$
\end_inset

 is also computably representable.
\end_layout

\begin_layout Proposition
\begin_inset Note Note
status open

\begin_layout Plain Layout
Done by considering the swapping thing
\end_layout

\end_inset


\end_layout

\begin_layout Corollary
\begin_inset CommandInset label
LatexCommand label
name "cor:barlinear"

\end_inset

Given a 
\nospellcheck on
CNDEPAC
\nospellcheck default
 tree 
\begin_inset Formula $T$
\end_inset

,
 if 
\begin_inset Formula $\barLinear(T)$
\end_inset

 is computably representable then 
\begin_inset Formula $\Lang(T)$
\end_inset

 is also computably representable.
 Moreover,
 this process is uniform.
\end_layout

\begin_layout Subsection
Trees of Low Rank
\end_layout

\begin_layout Standard
It will be useful for me to consider trees of low rank in the sequel,
 and I will want to ensure that they all live in the realm of 
\nospellcheck on
CNDEPAC
\nospellcheck default
 trees.
\end_layout

\begin_layout Definition
A 
\nospellcheck on
CNDE
\nospellcheck default
 tree is a Computable Tree with No Dead Ends.
\end_layout

\begin_layout Proposition
If 
\begin_inset Formula $T$
\end_inset

 is a 
\nospellcheck on
CNDE
\nospellcheck default
 tree with finitely many paths,
 
\begin_inset Formula $T$
\end_inset

 is a 
\nospellcheck on
CNDEPAC
\nospellcheck default
 tree.
 Moreover,
 if 
\begin_inset Formula $T$
\end_inset

 has exactly one path of rank 1,
 say 
\begin_inset Formula $p$
\end_inset

,
 and there is an upper bound 
\begin_inset Formula $k$
\end_inset

 to how many time other paths can branch upon diverging from 
\begin_inset Formula $p$
\end_inset

,
 then 
\begin_inset Formula $T$
\end_inset

 is a 
\nospellcheck on
CNDEPAC
\nospellcheck default
 tree.
\end_layout

\begin_layout Definition
A 
\emph on
1rk1
\emph default
 tree 
\begin_inset Formula $T$
\end_inset

 is a 
\nospellcheck on
CNDE
\nospellcheck default
 tree that admits exactly one path of rank 1.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Proposition
There is 1rk1 tree 
\begin_inset Formula $T$
\end_inset

 whose unique nonisolated path is not computable.
 In other words,
 there is a 1rk1 tree that is not PAC.
\end_layout

\begin_layout Proof
We will describe the construction of a 
\begin_inset Quotes eld
\end_inset

marked path
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $p$
\end_inset

,
 and our tree will initially consist of taking this path and branching off of it at every depth,
 creating an isolated path terminating in zeros.
 However,
 over the course of the construction,
 we will make revisions to 
\begin_inset Formula $p$
\end_inset

,
 at some point changing,
 say,
 the 
\begin_inset Formula $n$
\end_inset

th place from a 
\begin_inset Formula $0$
\end_inset

 to a 
\begin_inset Formula $1$
\end_inset

.
 In this event,
 the now-defunct branch will remain stagnant and injury will occur for the processes marked 
\begin_inset Formula $n+1$
\end_inset

 and above,
 which will have to be restarted.
\end_layout

\begin_layout Proof
\begin_inset Float figure
placement document
alignment document
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
\end_layout

\begin_layout Plain Layout

%uncomment if require:
 
\backslash
path (0,368);
 %set diagram left start at 0,
 and has height of 368
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%Straight Lines [id:da03967178610437139] 
\end_layout

\begin_layout Plain Layout


\backslash
draw [line width=3]    (200,0) -- (0,200) ;
\end_layout

\begin_layout Plain Layout

%Straight Lines [id:da6412933874124586] 
\end_layout

\begin_layout Plain Layout


\backslash
draw    (200,0) -- (240,40) -- (160,200) ;
\end_layout

\begin_layout Plain Layout

%Straight Lines [id:da3403701290760951] 
\end_layout

\begin_layout Plain Layout


\backslash
draw    (160,40) -- (200,80) -- (140,200) ;
\end_layout

\begin_layout Plain Layout

%Straight Lines [id:da3595645541144279] 
\end_layout

\begin_layout Plain Layout


\backslash
draw    (120,80) -- (160,120) -- (120,200) ;
\end_layout

\begin_layout Plain Layout

%Straight Lines [id:da8920052650847465] 
\end_layout

\begin_layout Plain Layout


\backslash
draw    (80,120) -- (120,160) -- (100,200) ;
\end_layout

\begin_layout Plain Layout

%Straight Lines [id:da5970965327874109] 
\end_layout

\begin_layout Plain Layout


\backslash
draw    (40,160) -- (80,200) ;
\end_layout

\begin_layout Plain Layout

%Straight Lines [id:da6305798697363738] 
\end_layout

\begin_layout Plain Layout


\backslash
draw    (272,110) -- (340,110) ;
\end_layout

\begin_layout Plain Layout


\backslash
draw [shift={(342,110)},
 rotate = 180] [color={rgb,
 255:red,
 0;
 green,
 0;
 blue,
 0 }  ][line width=0.75]    (10.93,-3.29) ..
 controls (6.95,-1.4) and (3.31,-0.3) ..
 (0,0) ..
 controls (3.31,0.3) and (6.95,1.4) ..
 (10.93,3.29)   ;
\end_layout

\begin_layout Plain Layout

%Straight Lines [id:da6958271846372078] 
\end_layout

\begin_layout Plain Layout


\backslash
draw [line width=3]    (550,0) -- (470,80) -- (510,120) -- (470,200) -- (390,280) ;
\end_layout

\begin_layout Plain Layout

%Straight Lines [id:da1892316704505188] 
\end_layout

\begin_layout Plain Layout


\backslash
draw    (550,0) -- (590,40) -- (580,240) ;
\end_layout

\begin_layout Plain Layout

%Straight Lines [id:da010803954838428775] 
\end_layout

\begin_layout Plain Layout


\backslash
draw    (510,40) -- (550,80) -- (540,240) ;
\end_layout

\begin_layout Plain Layout

%Straight Lines [id:da5097338803086449] 
\end_layout

\begin_layout Plain Layout


\backslash
draw    (470,80) -- (350,200) -- (310,240) ;
\end_layout

\begin_layout Plain Layout

%Straight Lines [id:da36332866017401255] 
\end_layout

\begin_layout Plain Layout


\backslash
draw    (430,120) -- (470,160) -- (450,200) -- (410,240) ;
\end_layout

\begin_layout Plain Layout

%Straight Lines [id:da6949892565967547] 
\end_layout

\begin_layout Plain Layout


\backslash
draw    (390,160) -- (430,200) -- (390,240) ;
\end_layout

\begin_layout Plain Layout

%Straight Lines [id:da9506758935125812] 
\end_layout

\begin_layout Plain Layout


\backslash
draw    (470,200) -- (510,240) -- (500,290) ;
\end_layout

\begin_layout Plain Layout

%Straight Lines [id:da07447760200446396] 
\end_layout

\begin_layout Plain Layout


\backslash
draw    (430,240) -- (470,280) ;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Text Node
\end_layout

\begin_layout Plain Layout


\backslash
draw (250,82) node [anchor=north west][inner sep=0.75pt]   [align=left] {Revision at $
\backslash
displaystyle n=2$};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:cndetree"

\end_inset

Sample construction of tree 
\begin_inset Formula $T$
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Proof
It remains to ensure that 
\begin_inset Formula $p$
\end_inset

 converges to a noncomputable function;
 this way,
 
\begin_inset Formula $T$
\end_inset

 will have 
\begin_inset Formula $p$
\end_inset

 as a noncomputable path.
 To this effect,
 pick an arbitrary noncomputable c.e.
\begin_inset space \space{}
\end_inset

set 
\begin_inset Formula $A$
\end_inset

,
 and start with 
\begin_inset Formula $p_{0}=0^{\omega}$
\end_inset

.
\end_layout

\begin_layout Proof
When the first element 
\begin_inset Formula $x$
\end_inset

 is enumerated into 
\begin_inset Formula $A$
\end_inset

 at stage 
\begin_inset Formula $s$
\end_inset

 (wlog 
\begin_inset Formula $x\leq s$
\end_inset

),
 we perform the operation shown on Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:cndetree"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
 The idea would be to repeat the process,
 but if an element 
\begin_inset Formula $y$
\end_inset

 is now enumerated between 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $s$
\end_inset

,
 we have no place to branch the path off.
 This issue is fixed if instead of branching at 
\emph on
depth
\emph default
 
\begin_inset Formula $y$
\end_inset

,
 we branch at the 
\begin_inset Formula $y$
\end_inset

th branching point of the marked path.
\end_layout

\begin_layout Proof
We need to handle the case where an element is enumerated before elements that have been considered before.
 That is,
 suppose that we've already enumerated 
\begin_inset Formula $x_{0}<x_{1}<\dots<x_{n}$
\end_inset

 into 
\begin_inset Formula $A$
\end_inset

,
 and that we now enumerate 
\begin_inset Formula $y$
\end_inset

 between 
\begin_inset Formula $x_{i}$
\end_inset

 and 
\begin_inset Formula $x_{i+1}$
\end_inset

.
 (An analogous argument needs to be made if 
\begin_inset Formula $y<x_{0}$
\end_inset

).
 In this scenario,
 we revise 
\begin_inset Formula $p$
\end_inset

 at the 
\begin_inset Formula $y$
\end_inset

th branching point,
 and subsequently we must act as though we have just enumerated 
\begin_inset Formula $x_{i+1},\dots,x_{n}$
\end_inset

 in order.
\end_layout

\begin_layout Proof
Now,
 let 
\begin_inset Formula $p$
\end_inset

 denote the limit path.
 Every path other than 
\begin_inset Formula $p$
\end_inset

 will eventually diverge from the marked path forever,
 and so will be isolated.
 On the other hand,
 it is clear that 
\begin_inset Formula $p$
\end_inset

 is not isolated:
 For example,
 every 
\begin_inset Formula $x\in A$
\end_inset

 induces a branching point!
 Finally,
 we claim that 
\begin_inset Formula $p$
\end_inset

 is not computable.
 Indeed,
 we claim that 
\begin_inset Formula $p$
\end_inset

 is Turing equivalent to 
\begin_inset Formula $A$
\end_inset

.
 It is clear that from 
\begin_inset Formula $A$
\end_inset

 we can compute 
\begin_inset Formula $p$
\end_inset

,
 but moreover 
\begin_inset Formula $A$
\end_inset

 can be read off of 
\begin_inset Formula $p$
\end_inset

 as follows:
 a number 
\begin_inset Formula $x$
\end_inset

 is in 
\begin_inset Formula $A$
\end_inset

 if and only if,
 at the 
\begin_inset Formula $x$
\end_inset

th branching point of 
\begin_inset Formula $p$
\end_inset

,
 
\begin_inset Formula $p$
\end_inset

 has gone to the right.
\end_layout

\begin_layout Proof
This completes the proof.
\end_layout

\begin_layout Definition
A 
\emph on
spinal
\emph default
 tree is a 
\nospellcheck on
CNDE
\nospellcheck default
 tree with exactly one path of rank 1,
 such that every path that branches off of it becomes immediately isolated.
\end_layout

\begin_layout Proposition
Every spinal tree is 
\nospellcheck on
CNDEPAC
\nospellcheck default
.
\end_layout

\begin_layout Proof
Since every isolated path is computable,
 it suffices to verify that the unique nonprincipal path is computable.
 To compute it,
 simply follow along the tree,
 and upon finding a branching point,
 wait until one of the branches branches again.
 This tells you where the nonprincipal path is going.
\end_layout

\begin_layout Definition
A 
\emph on
0-spinal
\emph default
 tree is a tree that is either spinal,
 or admits finitely many paths and its branching points form a chain.
\end_layout

\begin_layout Remark
The 0-spinal trees are precisely the ones that can show up as branches of Millar's tree and suitable variations.
\end_layout

\begin_layout Proposition
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Schweber
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "prop:schweber"

\end_inset

 There is no computable method that turns an index for a 0-spinal tree 
\begin_inset Formula $T$
\end_inset

 into an index for 
\begin_inset Formula $\Linear(T)$
\end_inset

.
\end_layout

\begin_layout Proof
Suppose that there is such a method.
 Using the recursion theorem,
 we adversarially construct a tree 
\begin_inset Formula $T$
\end_inset

 to produce an incorrect result.
\end_layout

\begin_layout Proof
Let 
\begin_inset Formula $T$
\end_inset

 start as a one-branch tree,
 and commit to only branching when we see an element being enumerated into the order produced by the method;
 call it 
\begin_inset Formula $L$
\end_inset

.
 Since 
\begin_inset Formula $L$
\end_inset

 must agree with 
\begin_inset Formula $\Lang(T)$
\end_inset

,
 an element must eventually be enumerated into 
\begin_inset Formula $L$
\end_inset

.
 Keep note of it;
 we will refer to it as 
\begin_inset Formula $0$
\end_inset

.
 At this point,
 branch the tree 
\begin_inset Formula $T$
\end_inset

.
\end_layout

\begin_layout Proof
For the same reason as in the previous paragraph,
 a second element must be enumerated into 
\begin_inset Formula $L$
\end_inset

.
 When it is so,
 the two current branches of 
\begin_inset Formula $T$
\end_inset

 are in correspondence with the elements of 
\begin_inset Formula $L$
\end_inset

,
 and so one of the two branches must correspond to the element 
\begin_inset Formula $0$
\end_inset

.
 Branch off of it.
\end_layout

\begin_layout Proof
Continue this procedure:
 Each time you branch,
 wait until a new element is added into 
\begin_inset Formula $L$
\end_inset

,
 then look at which of the two new branches corresponds to the element 
\begin_inset Formula $0$
\end_inset

 and branch off that one.
\end_layout

\begin_layout Proof
The resulting tree 
\begin_inset Formula $T$
\end_inset

 has 
\begin_inset Formula $\Lang(T)$
\end_inset

 of order type 
\begin_inset Formula $n+\omega^{*}$
\end_inset

,
 
\begin_inset Formula $\omega+n$
\end_inset

,
 or 
\begin_inset Formula $\omega+\omega^{*}$
\end_inset

,
 and it can be verified that in each of these instances the order produced by the algorithm is respectively 
\begin_inset Formula $n+1+\omega^{*}$
\end_inset

,
 
\begin_inset Formula $\omega+n+1$
\end_inset

,
 or 
\begin_inset Formula $\omega+1+\omega^{*}$
\end_inset

,
 which is incorrect.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Corollary
There is no computable method that turns an index for a PAC tree 
\begin_inset Formula $T$
\end_inset

 into an index for 
\begin_inset Formula $\Linear(T)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Corollary
There is no computable method that turns an index for a 0-spinal tree 
\begin_inset Formula $T$
\end_inset

 into an index for 
\begin_inset Formula $\barLinear(T)$
\end_inset

.
\end_layout

\begin_layout Remark
Proposition 
\begin_inset CommandInset ref
LatexCommand ref
reference "prop:schweber"

\end_inset

 shows that a relatively naïve algorithm to compute 
\begin_inset Formula $\Lang(\TM)$
\end_inset

,
 by computing the orders of each branch and concatenating them,
 will not succeed.
\end_layout

\begin_layout Standard
I have decided to investigate the computability of algorithms that turn certain types of trees into orders associated for them.
 For example:
\end_layout

\begin_layout Proposition
\begin_inset CommandInset label
LatexCommand label
name "prop:omegabar"

\end_inset

There is an algorithm that turns an index for a 0-spinal tree 
\begin_inset Formula $T$
\end_inset

 into an index for 
\begin_inset Formula $\omega+\barLinear(T)$
\end_inset

.
\end_layout

\begin_layout Proof
First,
 we sketch an algorithm that turns an index for a 0-spinal tree 
\begin_inset Formula $T$
\end_inset

 into an index for:
\begin_inset Formula 
\begin{equation}
\begin{cases}
\barLinear(T), & \text{if \ensuremath{T} has infinitely many branches,}\\
n-1, & \text{if \ensuremath{\barLinear(T)=n}.}
\end{cases}\label{eq:barlinearT}
\end{equation}

\end_inset

This algorithm works as follows:
 Wait until 
\begin_inset Formula $T$
\end_inset

 branches,
 and at that point introduce a designated element that we will call 
\begin_inset Formula $0$
\end_inset

.
 When 
\begin_inset Formula $T$
\end_inset

 branches again,
 let's say on the left side,
 we add a new element to the right of 
\begin_inset Formula $0$
\end_inset

 to represent the branch that has just been abandoned.
 At each stage,
 
\begin_inset Formula $0$
\end_inset

 follows the latest branching point,
 and elements are added for every branch that has been left behind.
\end_layout

\begin_layout Proof
Now,
 we adapt this algorithm to compute 
\begin_inset Formula $\omega+\barLinear(T)$
\end_inset

.
 At the start of the algorithm's execution,
 add an element 
\begin_inset Formula $s_{0}$
\end_inset

,
 which will be to the left of what the above algorithm does.
 While the algorithm runs,
 add elements to the immediate left of 
\begin_inset Formula $s_{0}$
\end_inset

.
 When we find a branch of 
\begin_inset Formula $T$
\end_inset

,
 add a new element 
\begin_inset Formula $s_{1}$
\end_inset

immediately to the right of 
\begin_inset Formula $s_{0}$
\end_inset

,
 and continue execution,
 with 
\begin_inset Formula $s_{1}$
\end_inset

 functioning as 
\begin_inset Formula $s_{0}$
\end_inset

 did previously.
 When we find a new branch of 
\begin_inset Formula $T$
\end_inset

,
 we replace 
\begin_inset Formula $s_{1}$
\end_inset

 by a new element 
\begin_inset Formula $s_{2}$
\end_inset

,
 and so on.
\end_layout

\begin_layout Proof
The purpose of this is so that,
 if 
\begin_inset Formula $T$
\end_inset

 branches finitely many times,
 the last element 
\begin_inset Formula $s_{n}$
\end_inset

 will compensate the 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $-1$
\end_inset


\begin_inset Quotes erd
\end_inset

 from the algorithm outlined above.
 On other other hand,
 if 
\begin_inset Formula $T$
\end_inset

 branches infinitely many times,
 all 
\begin_inset Formula $s_{n}$
\end_inset

 will be absorbed into 
\begin_inset Formula $\omega$
\end_inset

.
 In either case,
 the resulting order type is 
\begin_inset Formula $\omega+\barLinear(T)$
\end_inset

.
\end_layout

\begin_layout Standard
The above idea can be easily adapted to provide all of the following results.
\end_layout

\begin_layout Corollary
There is an algorithm that turns an index for a 0-spinal tree 
\begin_inset Formula $T$
\end_inset

 and a nonnegative integer 
\begin_inset Formula $n$
\end_inset

 into an index for 
\begin_inset Formula $\omega+n+\barLinear(T)$
\end_inset

.
\end_layout

\begin_layout Proof
Apply Proposition 
\begin_inset CommandInset ref
LatexCommand ref
reference "prop:omegabar"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 to the tree obtained by adding 
\begin_inset Formula $n$
\end_inset

 branches on the left of 
\begin_inset Formula $T$
\end_inset

 at the root.
\end_layout

\begin_layout Corollary
\begin_inset CommandInset label
LatexCommand label
name "cor:omega1linear"

\end_inset

There is an algorithm that turns an index for a 0-spinal tree 
\begin_inset Formula $T$
\end_inset

 into an index for 
\begin_inset Formula $\omega+1+\Linear(T)$
\end_inset

.
\end_layout

\begin_layout Standard
The significance of this last corollary is the following.
 We have seen in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:tmpsi1"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 that there is a choice of universal function for which 
\begin_inset Formula $\Linear(\TM)$
\end_inset

 is computably representable.
 This was done by constructing the order in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:barlinearT"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 for every branch,
 and relying on the fact that (with the right universal function) every finite subtree is adjacent to one whose order is 
\begin_inset Formula $\omega$
\end_inset

 or 
\begin_inset Formula $\omega^{*}$
\end_inset

,
 facing in such a way as to absorb the 
\begin_inset Formula $-1$
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:barlinearT"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
 This raises the idea that one could try to avoid this easy strategy by instead constructing 
\begin_inset Quotes eld
\end_inset

separators
\begin_inset Quotes erd
\end_inset

.
 In other words,
 choose a universal function as to make
\begin_inset Formula 
\[
\Linear(\TM)=(\omega+1)+\Linear(T_{0})+(1+\omega^{*})+(\omega+1)+\Linear(T_{1})+(1+\omega^{*})+\dots
\]

\end_inset

The punchline is that Corollary 
\begin_inset CommandInset ref
LatexCommand ref
reference "cor:omega1linear"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 shows that this approach also does not work,
 in the sense that the resulting Millar's Tree has a computably representable order.
\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
By Corollary 
\begin_inset CommandInset ref
LatexCommand ref
reference "cor:barlinear"

\end_inset

,
 we get that computing 
\begin_inset Formula $\barLinear$
\end_inset

 can be no easier than computing 
\begin_inset Formula $\Linear$
\end_inset

.
 However,
 it leaves open the question of whether it is strictly harder.
 A possible way to quantify this would be to find a tree for which 
\begin_inset Formula $\Linear$
\end_inset

 is computable but 
\begin_inset Formula $\barLinear$
\end_inset

 is not.
 I have been unable to do so as yet.
 However,
 the following two results are a different way to express that there is an added difficulty in computing 
\begin_inset Formula $\barLinear$
\end_inset

.
\end_layout

\begin_layout Proposition
There is an algorithm that turns an index for a 1rk1 tree 
\begin_inset Formula $T$
\end_inset

 into an index for 
\begin_inset Formula $\Linear(T)$
\end_inset

.
\end_layout

\begin_layout Proof
Consider the branching points of 
\begin_inset Formula $T$
\end_inset

,
 ordered lexicographically,
 with the caveat that string terminator is seen as a character ordered between 
\begin_inset Formula $0$
\end_inset

 and 
\begin_inset Formula $1$
\end_inset

.
 This order is isomorphic to 
\begin_inset Formula $\Linear(T)$
\end_inset

,
 and we will now explain why.
\end_layout

\begin_layout Proof
Any isolated path 
\begin_inset Formula $q$
\end_inset

 of 
\begin_inset Formula $T$
\end_inset

 branches off of the unique rank 1 path,
 which we call 
\begin_inset Formula $p$
\end_inset

.
 Let 
\begin_inset Formula $\sigma$
\end_inset

 be the node at which this happens,
 with 
\begin_inset Formula $q=\sigma iq'$
\end_inset

,
 with 
\begin_inset Formula $i\in2$
\end_inset

.
 As a consequence,
 there are finitely many paths below 
\begin_inset Formula $\sigma i$
\end_inset

,
 let us say 
\begin_inset Formula $n$
\end_inset

.
 As such,
 there are 
\begin_inset Formula $n-1$
\end_inset

 branching points at or below 
\begin_inset Formula $\sigma i$
\end_inset

.
 Hence,
 we can put 
\begin_inset Quotes eld
\end_inset

paths below 
\begin_inset Formula $\sigma i$
\end_inset


\begin_inset Quotes erd
\end_inset

 in ordered bijection with 
\begin_inset Quotes eld
\end_inset

branching points below 
\begin_inset Formula $\sigma i$
\end_inset

,
 plus 
\begin_inset Formula $\sigma$
\end_inset

 itself
\begin_inset Quotes erd
\end_inset

.
 If we perform this procedure for every branching point of 
\begin_inset Formula $p$
\end_inset

,
 we obtain an order preserving bijection between the isolated paths and the branching points,
 as desired.
\end_layout

\begin_layout Subsubsection
A Difficulty Result
\end_layout

\begin_layout Standard
In this section,
 we establish the following theorem.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:1rk1barlinear"

\end_inset

Suppose that 
\begin_inset Formula $d$
\end_inset

 is a degree that computes a function which,
 given an index for a 1rk1 tree 
\begin_inset Formula $T$
\end_inset

,
 returns an index for 
\begin_inset Formula $\barLinear(T)$
\end_inset

.
 Then,
 
\begin_inset Formula $d\oplus0''\geq0'''$
\end_inset

.
\end_layout

\begin_layout Corollary
There is no algorithm that turns an index for a 1rk1 tree 
\begin_inset Formula $T$
\end_inset

 into an index for 
\begin_inset Formula $\barLinear(T)$
\end_inset

.
 There is also no algorithm computable in 
\begin_inset Formula $0'$
\end_inset

 or 
\begin_inset Formula $0''$
\end_inset

.
\end_layout

\begin_layout Standard
Before establishing Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:1rk1barlinear"

\end_inset

,
 we make a small study of the difficulty in distinguishing certain linear orders and trees.
 This will also explain why 
\begin_inset Formula $\barLinear$
\end_inset

 is is so much harder to compute in this scenario comparatively to 
\begin_inset Formula $\Linear$
\end_inset

.
\end_layout

\begin_layout Standard
In the sequence,
 unless indicated otherwise,
 any reference to 
\begin_inset Quotes eld
\end_inset

given a 1rk1 tree
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

given a linear order 
\begin_inset Formula $L$
\end_inset


\begin_inset Quotes erd
\end_inset

 should be taken to implicitly mean 
\begin_inset Quotes eld
\end_inset

given a 
\emph on
computable index
\emph default

\begin_inset Quotes erd
\end_inset

 for the object in question.
\end_layout

\begin_layout Definition
Given a 1rk1 tree 
\begin_inset Formula $T$
\end_inset

,
 the linear order 
\begin_inset Formula $\barLinear(T)$
\end_inset

 has order type of one of the following three kinds:
 
\begin_inset Formula $\omega+1+\omega^{*}$
\end_inset

,
 
\begin_inset Formula $\omega+n$
\end_inset

,
 or 
\begin_inset Formula $n+\omega^{*}$
\end_inset

,
 for some 
\begin_inset Formula $n\geq1$
\end_inset

.
 We call these three types of linear orders 
\emph on
1rk1 orders
\emph default
.
 We refer to the first type of linear order as a 
\emph on
three-block
\emph default
 linear order,
 and the second and third type as a 
\emph on
two-block
\emph default
 linear order.
 Moreover,
 we refer to a 1rk1 tree 
\begin_inset Formula $T$
\end_inset

 as a three/two-block tree if 
\begin_inset Formula $\barLinear(T)$
\end_inset

 is a three/two-block linear order,
 respectively.
\end_layout

\begin_layout Proposition
There is a 
\begin_inset Formula $0'''$
\end_inset

-computable algorithm that identifies whether a 1rk1 tree 
\begin_inset Formula $T$
\end_inset

 is three-block or two-block.
\end_layout

\begin_layout Proof
We use Post's theorem,
 by showing that the condition 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $T$
\end_inset

 is three-block
\begin_inset Quotes erd
\end_inset

 may be written as a 
\begin_inset Formula $\Pi_{3}$
\end_inset

.
\end_layout

\begin_layout Proof
Being a three-block tree is the same as saying that there are arbitrarily many paths to the left and to the right of the nonprincipal path.
 In other words,
\begin_inset Formula 
\[
\text{\ensuremath{T} is three-block iff }\forall_{n}\exists_{\sigma}\begin{pmatrix}\begin{array}{l}
\text{\ensuremath{\sigma} is in a nonprincipal path of \ensuremath{T} and there are \ensuremath{n} distinct nodes of \ensuremath{T}}\\
\text{to the left and to the right of \ensuremath{\sigma}, at the same level as \ensuremath{\sigma}}
\end{array}\end{pmatrix}.
\]

\end_inset


\end_layout

\begin_layout Proof
Naively,
 this is a 
\begin_inset Formula $\Pi_{4}$
\end_inset

 condition because 
\begin_inset Formula $\sigma$
\end_inset

 being in a nonprincipal path of 
\begin_inset Formula $T$
\end_inset

 is a 
\begin_inset Formula $\Pi_{2}$
\end_inset

 condition:
 For all 
\begin_inset Formula $k$
\end_inset

 there is a depth 
\begin_inset Formula $d$
\end_inset

 at which 
\begin_inset Formula $\sigma$
\end_inset

 has 
\begin_inset Formula $k$
\end_inset

 distinct children (or more),
 and the remainder of the condition is computable.
 However,
 in a 1rk1 tree we can also write 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\sigma$
\end_inset

 is in the nonprincipal path of 
\begin_inset Formula $T$
\end_inset


\begin_inset Quotes erd
\end_inset

 in a 
\begin_inset Formula $\Sigma_{2}$
\end_inset

 fashion,
 by saying:
 There is a number 
\begin_inset Formula $q$
\end_inset

 for which,
 at every depth 
\begin_inset Formula $d$
\end_inset

,
 all but (at most) 
\begin_inset Formula $q$
\end_inset

 nodes of 
\begin_inset Formula $T$
\end_inset

 at depth 
\begin_inset Formula $d$
\end_inset

 are descendants of 
\begin_inset Formula $\sigma$
\end_inset

.
 This concludes the proof.
\end_layout

\begin_layout Proposition
\begin_inset CommandInset label
LatexCommand label
name "prop:1rk1order"

\end_inset

There is a 
\begin_inset Formula $0''$
\end_inset

-computable algorithm that identifies whether a 1rk1 order 
\begin_inset Formula $L$
\end_inset

 is a three-block order or a two-block order.
\end_layout

\begin_layout Proof
We show that,
 for a 1rk1 order 
\begin_inset Formula $L$
\end_inset

,
 the condition 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $L$
\end_inset

 is a three-block order
\begin_inset Quotes erd
\end_inset

 is 
\begin_inset Formula $\Delta_{3}$
\end_inset

,
 by showing that both it and the property of being two-block may be written in a 
\begin_inset Formula $\Sigma_{3}$
\end_inset

 way.
\end_layout

\begin_layout Proof
First,
 we write three-blockness as a 
\begin_inset Formula $\Sigma_{3}$
\end_inset

 property:
\begin_inset Formula 
\[
\text{\ensuremath{L} is three-block iff }\exists_{c}\forall_{n}(\text{there are at least \ensuremath{n} elements of \ensuremath{L} at the left of \ensuremath{c}, and likewise for the right}).
\]

\end_inset

Then,
 we write two-blockness as a 
\begin_inset Formula $\Sigma_{3}$
\end_inset

 property:
\begin_inset Formula 
\[
\text{\ensuremath{L} is two-block iff }\exists_{x_{1}<\dots<x_{n}\in L}\forall_{\nu\in L}\begin{pmatrix}\begin{array}{l}
\text{either \ensuremath{\nu} is one of the \ensuremath{x_{i}},}\\
\text{or \ensuremath{\nu<x_{1}}, in which case there exists \ensuremath{\nu'} inbetween \ensuremath{\nu} and \ensuremath{x_{1}}}
\end{array}\end{pmatrix}.
\]

\end_inset

This concludes the proof.
\end_layout

\begin_layout Standard
The following proposition is not strictly necessary for our purposes,
 but does show that Proposition 
\begin_inset CommandInset ref
LatexCommand ref
reference "prop:1rk1order"

\end_inset

 cannot be improved.
\end_layout

\begin_layout Proposition
Proposition 
\begin_inset CommandInset ref
LatexCommand ref
reference "prop:1rk1order"

\end_inset

 is strict.
 In other words,
 any degree that can correctly identify whether a 1rk1 order is three-block or two-block can also compute 
\begin_inset Formula $0''$
\end_inset

.
\end_layout

\begin_layout Proof
It suffices to provide an algorithm that,
 given 
\begin_inset Formula $e\in\N$
\end_inset

,
 will produce a 1rk1 linear order 
\begin_inset Formula $L(e)$
\end_inset

 such that 
\begin_inset Formula $L(e)$
\end_inset

 is two-block iff 
\begin_inset Formula $\varphi_{e}$
\end_inset

 is total.
\end_layout

\begin_layout Proof
Consider the following linear order.
 First,
 we add an element 
\begin_inset Formula $r\in L(e)$
\end_inset

,
 that will be greater than everyone else we add.
 Then,
 we will be adding an element 
\begin_inset Formula $m_{0}$
\end_inset

,
 and a sequence of elements 
\begin_inset Formula $\ell_{0}<\ell_{1}<\ell_{2}<\dots<m_{0}<r$
\end_inset

,
 while in parallel evaluating 
\begin_inset Formula $\varphi_{e}(0)$
\end_inset

 and adding another sequence of elements 
\begin_inset Formula $\dots<r_{02}<r_{01}<r_{00}$
\end_inset

 between the 
\begin_inset Formula $m_{0}$
\end_inset

 and 
\begin_inset Formula $r$
\end_inset

 for as long as 
\begin_inset Formula $\varphi_{e}(0)$
\end_inset

 takes to halt.
 Thus,
 if 
\begin_inset Formula $\varphi_{e}(0)\isnotwd$
\end_inset

,
 the resulting order is 
\begin_inset Formula $\omega+1+\omega^{*}$
\end_inset

.
\end_layout

\begin_layout Proof
Now,
 if 
\begin_inset Formula $\varphi_{e}(0)$
\end_inset

 does halt,
 we halt the above processes,
 add a new element 
\begin_inset Formula $m_{1}$
\end_inset

between 
\begin_inset Formula $r_{00}$
\end_inset

 and 
\begin_inset Formula $r$
\end_inset

,
 continue adding elements 
\begin_inset Formula $\ell_{i}$
\end_inset

 in ascending order immediately to the left of 
\begin_inset Formula $m_{1}$
\end_inset

,
 and add a decreasing sequence of elements 
\begin_inset Formula $r_{1i}$
\end_inset

 immediately to the right of 
\begin_inset Formula $m_{1}$
\end_inset

,
 for as long as 
\begin_inset Formula $\varphi_{e}(1)$
\end_inset

 takes to halt.
 Again,
 if it does not halt,
 the resulting order is 
\begin_inset Formula $\omega+1+\omega^{*}$
\end_inset

,
 and if it does halt the process continues in the obvious way.
\end_layout

\begin_layout Proof
In this way,
 if 
\begin_inset Formula $\varphi_{e}$
\end_inset

 is not total,
 the resulting order is three-block.
 On the other hand,
 if 
\begin_inset Formula $\varphi_{e}$
\end_inset

 is total,
 the resulting order is easily seen to equal 
\begin_inset Formula $\omega+1$
\end_inset

,
 and so the proof is complete.
\end_layout

\begin_layout Standard
In the sequence,
 we will be proving results about 
\begin_inset Formula $0'''$
\end_inset

.
 This requires having a manageable characterization of the triple jump.
 We now outline the one that we will be using.
\end_layout

\begin_layout Standard
Recall the following characterizations of the degrees that 
\begin_inset Formula $0'$
\end_inset

 and 
\begin_inset Formula $0''$
\end_inset

:
\end_layout

\begin_layout Itemize
A degree can compute 
\begin_inset Formula $0'$
\end_inset

 iff it can,
 given a convergent computable sequence 
\begin_inset Formula $\{a_{n}\}_{n\in\N}$
\end_inset

,
 determine its limit.
\end_layout

\begin_layout Itemize
A degree can compute 
\begin_inset Formula $0''$
\end_inset

 iff it can,
 given a computable sequence 
\begin_inset Formula $\{a_{n}\}_{n\in\N}$
\end_inset

,
 determine whether it converges.
\end_layout

\begin_layout Standard
There is a relatively natural step that follows these:
\end_layout

\begin_layout Proposition
A degree can compute 
\begin_inset Formula $0'''$
\end_inset

 iff it can,
 given a computable sequence of total functions 
\begin_inset Formula $\{f_{s}\}_{s\in\N}$
\end_inset

,
 determine whether it converges (pointwise everywhere).
\end_layout

\begin_layout Proof
(
\begin_inset Formula $\rightarrow$
\end_inset

) Convergence is determined by the formula 
\begin_inset Formula $\forall_{x}\exists_{L}\exists_{N}\forall_{n}(n>N\implies f_{n}(x)=L)$
\end_inset

 which,
 being 
\begin_inset Formula $\Pi_{3}$
\end_inset

,
 is in particular 
\begin_inset Formula $0'''$
\end_inset

-computable.
\end_layout

\begin_layout Proof
(
\begin_inset Formula $\leftarrow$
\end_inset

) By relativization of a well-known fact,
 we have 
\begin_inset Formula $0'''=\Tot(K)$
\end_inset

,
 for 
\begin_inset Formula $K$
\end_inset

 a set with 
\begin_inset Formula $\deg(K)=0'$
\end_inset

.
 As such,
 let 
\begin_inset Formula $e\in\N$
\end_inset

,
 and let us suppose we wish to know if 
\begin_inset Formula $\varphi_{e}^{K}$
\end_inset

 is total,
 where 
\begin_inset Formula $K$
\end_inset

 is the Halting Problem.
\end_layout

\begin_layout Proof
Let 
\begin_inset Formula $K_{s}$
\end_inset

 be a computable approximation to the Halting Problem,
 and define 
\begin_inset Formula $f_{s}(x)$
\end_inset

 as follows.
 Given 
\begin_inset Formula $x\in\N$
\end_inset

,
 we look at the first 
\begin_inset Formula $s$
\end_inset

 steps of the sequence 
\begin_inset Formula $q_{s}(x)=(\varphi_{e}^{K_{s}}(x))[s]$
\end_inset

,
 where the suffix 
\begin_inset Formula $[s]$
\end_inset

 means we are evaluating it only for 
\begin_inset Formula $s$
\end_inset

 time.
 Now,
 we stipulate that 
\begin_inset Formula $f_{s}(x)$
\end_inset

 will generally look like 
\begin_inset Formula $q_{s}(x)$
\end_inset

,
 with the following two exceptions:
\end_layout

\begin_deeper
\begin_layout Itemize
If 
\begin_inset Formula $\varphi_{e}^{K_{s}}(x)$
\end_inset

 has not halted after 
\begin_inset Formula $s$
\end_inset

 steps,
 ensure that 
\begin_inset Formula $f_{s}(x)\neq f_{s-1}(x)$
\end_inset

,
\end_layout

\begin_layout Itemize
If the approximation 
\begin_inset Formula $K_{s}$
\end_inset

 has changed in a computationally-relevant way (for 
\begin_inset Formula $(\varphi_{e}^{K_{s}}(x))[s]$
\end_inset

 from step 
\begin_inset Formula $s$
\end_inset

 to step 
\begin_inset Formula $s+1$
\end_inset

,
 ensure that 
\begin_inset Formula $f_{s}(x)\neq f_{s-1}(x)$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Proof
Thus,
 if 
\begin_inset Formula $\varphi_{e}^{K}(x)$
\end_inset

 halts,
 for 
\begin_inset Formula $s$
\end_inset

 large enough that 
\begin_inset Formula $K_{s}$
\end_inset

 agrees with 
\begin_inset Formula $K$
\end_inset

 as far as the computation of 
\begin_inset Formula $\varphi_{e}^{K}(x)$
\end_inset

 uses it,
 as well as large enough that the computation has already ended,
 neither of the above two exceptions will occur,
 and so 
\begin_inset Formula $f_{s}(x)$
\end_inset

 will agree with 
\begin_inset Formula $\varphi_{e}^{K}(x)$
\end_inset

 for large enough 
\begin_inset Formula $s$
\end_inset

.
\end_layout

\begin_layout Proof
On the other hand,
 if 
\begin_inset Formula $f_{s}(x)$
\end_inset

 converges as 
\begin_inset Formula $s\to\infty$
\end_inset

,
 neither of the two exceptions occurs for large enough values of 
\begin_inset Formula $s$
\end_inset

,
 meaning that not only does the computation 
\begin_inset Formula $\varphi_{e}^{K_{s}}(x)$
\end_inset

 terminate,
 but also the approximation of 
\begin_inset Formula $K_{s}$
\end_inset

 does not change in any relevant way,
 implying that it is correct for the purposes of this computation.
 Thus,
 
\begin_inset Formula $\varphi_{e}^{K}(x)\iswd$
\end_inset

.
\end_layout

\begin_layout Proof
Thus,
 we see that 
\begin_inset Formula $f_{s}$
\end_inset

 converges pointwise everywhere iff 
\begin_inset Formula $e\in\Tot(K)$
\end_inset

,
 and so a degree that can verify the convergence of 
\begin_inset Formula $f_{s}$
\end_inset

 can also compute 
\begin_inset Formula $\Tot(K)$
\end_inset

,
 finishing the proof.
\end_layout

\begin_layout Standard
We are now prepared to prove Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:1rk1barlinear"

\end_inset

:
\end_layout

\begin_layout Theorem*
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:1rk1barlinear"

\end_inset


\end_layout

\end_inset

Suppose that 
\begin_inset Formula $d$
\end_inset

 is a degree that computes a function which,
 given an index for a 1rk1 tree 
\begin_inset Formula $T$
\end_inset

,
 returns an index for 
\begin_inset Formula $\barLinear(T)$
\end_inset

.
 Then,
 
\begin_inset Formula $d\oplus0''\geq0'''$
\end_inset

.
\end_layout

\begin_layout Proof
The crux of the proof is the following construction:
 We will show that we can,
 uniformly in an index for a total computable function 
\begin_inset Formula $f\colon\N\times\N\to\N$
\end_inset

,
 construct a 1rk1 tree 
\begin_inset Formula $T$
\end_inset

 that is three-block when 
\begin_inset Formula $f_{s}$
\end_inset

 converges everywhere,
 and two-block if 
\begin_inset Formula $f_{s}(x)$
\end_inset

 diverges for some value of 
\begin_inset Formula $x$
\end_inset

.
 This suffices to prove the theorem by the following:
 Given an oracle for 
\begin_inset Formula $d\oplus0''$
\end_inset

,
 given a total computable sequence 
\begin_inset Formula $\{f_{s}\}_{s\in\N}$
\end_inset

,
 we construct the tree 
\begin_inset Formula $T$
\end_inset

 described above,
 then use the oracle for 
\begin_inset Formula $d$
\end_inset

 to obtain an index for 
\begin_inset Formula $L=\barLinear(T)$
\end_inset

,
 and then apply Proposition 
\begin_inset CommandInset ref
LatexCommand ref
reference "prop:1rk1order"

\end_inset

 to,
 using 
\begin_inset Formula $0''$
\end_inset

,
 tell whether 
\begin_inset Formula $L$
\end_inset

,
 and by extension 
\begin_inset Formula $T$
\end_inset

,
 is three-block or two-block,
 thereby determining whether 
\begin_inset Formula $\{f_{s}\}_{s\in\N}$
\end_inset

 converges pointwise everywhere or not.
\end_layout

\begin_layout Proof
Let us now describe the construction of the tree 
\begin_inset Formula $T$
\end_inset

.
 We define it recursively,
 first defining an 
\begin_inset Quotes eld
\end_inset

outer layer description
\begin_inset Quotes erd
\end_inset

 of the tree,
 followed by explaining how to recursively apply the same reasoning to certain subtrees.
\end_layout

\begin_layout Proof
At the start,
 we branch off the origin to both sides,
 then branch off the right side again,
 with the middle section being a subtree which we call 
\begin_inset Formula $T_{1}$
\end_inset

 and whose construction we describe later.
\end_layout

\begin_layout Proof
\begin_inset Float figure
placement document
alignment document
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1,
\end_layout

\begin_layout Plain Layout

subtree/.style={draw,
 regular polygon,
 regular polygon sides=3,
 align=center,
 anchor=north}]
\end_layout

\begin_layout Plain Layout

%uncomment if require:
 
\backslash
path (0,300);
 %set diagram left start at 0,
 and has height of 300
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Text Node
\end_layout

\begin_layout Plain Layout


\backslash
node[subtree] (T0) at (150,150)  {$T_{1}$};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw[->] (190,90) -- (150,50) -- (50,150);
\end_layout

\begin_layout Plain Layout


\backslash
draw[->] (T0.north) -- (190,90) -- (250,150);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:startT"

\end_inset

The start of the construction of 
\begin_inset Formula $T$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Proof
In parallel,
 we observe the evolution of the value of 
\begin_inset Formula $f_{s}(0)$
\end_inset

.
 If it never changes,
 the tree looks as in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:startT"

\end_inset

,
 with the construction of 
\begin_inset Formula $T_{1}$
\end_inset

 being described later.
 On the other hand,
 if the value of 
\begin_inset Formula $f_{s}(0)$
\end_inset

 is ever observed to change,
 we perform the following operations:
\end_layout

\begin_deeper
\begin_layout Itemize
Freeze the construction of 
\begin_inset Formula $T_{1}$
\end_inset

 by stopping the addition of any new branches (though every current branch must be prolonged indefinitely as 
\begin_inset Formula $T$
\end_inset

 may have no dead ends),
\end_layout

\begin_layout Itemize
On the leftmost path,
 branch twice as you did in the origin,
 and in the middle section restart the construction of 
\begin_inset Formula $T_{1}$
\end_inset

 from scratch.
\end_layout

\end_deeper
\begin_layout Proof
\begin_inset Float figure
placement document
alignment document
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1,
\end_layout

\begin_layout Plain Layout

subtree/.style={draw,
 regular polygon,
 regular polygon sides=3,
 align=center,
 anchor=north}]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Text Node
\end_layout

\begin_layout Plain Layout


\backslash
node[subtree] (T0) at (170,110){$T_1$};
\end_layout

\begin_layout Plain Layout


\backslash
node[subtree] (T1) at (70,170) {$T_1$};
\end_layout

\begin_layout Plain Layout


\backslash
node[anchor=north] at (T0.south) {(Frozen)};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%
\backslash
draw[->] (190,90) -- (150,50) -- (50,150);
\end_layout

\begin_layout Plain Layout

%
\backslash
draw[->] (T0.north) -- (190,90) -- (250,150);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%Straight Lines [id:da22224855595790238] 
\end_layout

\begin_layout Plain Layout


\backslash
draw[->]    (190,90) -- (150,50) -- (20,180) ;
\end_layout

\begin_layout Plain Layout

%Straight Lines [id:da4816521803944812] 
\end_layout

\begin_layout Plain Layout


\backslash
draw[->]    (170,110) -- (190,90) -- (250,150) ;
\end_layout

\begin_layout Plain Layout

%Straight Lines [id:da9996970512272761] 
\end_layout

\begin_layout Plain Layout


\backslash
draw[->]    (70,130) -- (130,190) ;
\end_layout

\begin_layout Plain Layout

%Straight Lines [id:da584976328181152] 
\end_layout

\begin_layout Plain Layout


\backslash
draw    (90,150) -- (70,170) ;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:continueT"

\end_inset

The construction of 
\begin_inset Formula $T$
\end_inset

 after 
\begin_inset Formula $f_{s}(0)$
\end_inset

 has changed once.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Proof
The construction proceeds in this manner:
 Each time 
\begin_inset Formula $f_{s}(0)$
\end_inset

 is observed to change,
 we freeze the current iteration of 
\begin_inset Formula $T_{1}$
\end_inset

 and add a new one on the left.
 Thus,
 it is clear that if 
\begin_inset Formula $f_{s}(0)$
\end_inset

 does not converge,
 the resulting tree (which is evidently 1rk1) has 
\begin_inset Formula $\barLinear(T)$
\end_inset

 equal to 
\begin_inset Formula $1+\omega^{*}$
\end_inset

,
 and so 
\begin_inset Formula $T$
\end_inset

 is two-block.
\end_layout

\begin_layout Proof
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Proof
Now,
 let us describe the construction of 
\begin_inset Formula $T_{1}$
\end_inset

.
 It is the same as the construction of 
\begin_inset Formula $T$
\end_inset

 itself,
 except that it instead monitors the value of 
\begin_inset Formula $f_{s}(1)$
\end_inset

,
 and the subtree it constructs (call it 
\begin_inset Formula $T_{2}$
\end_inset

) is similar except that it monitors the value of 
\begin_inset Formula $f_{s}(2)$
\end_inset

,
 and so on.
 Note that if 
\begin_inset Formula $f_{s}(0)$
\end_inset

 does converge,
 the tree 
\begin_inset Formula $T$
\end_inset

 is given by 
\begin_inset Formula $T_{1}$
\end_inset

,
 plus a finite amount of branches to its right and left (and indeed,
 only one branch to its left but possibly many to its right).
\end_layout

\begin_layout Proof
Now,
 we can inductively argue that,
 if 
\begin_inset Formula $x$
\end_inset

 is the smallest value at which 
\begin_inset Formula $f_{s}(x)$
\end_inset

 diverges,
 the tree 
\begin_inset Formula $T$
\end_inset

 will be of order type 
\begin_inset Formula $1+x+\omega^{*}$
\end_inset

,
 and so is a two-block tree.
 On the other hand,
 if 
\begin_inset Formula $f_{s}$
\end_inset

 converges everywhere,
 we see that 
\begin_inset Formula $T$
\end_inset

 contains a copy of 
\begin_inset Formula $T_{1}$
\end_inset

,
 which in turn contains a copy of 
\begin_inset Formula $T_{2}$
\end_inset

,
 and so on,
 in such a way that in the passage between each 
\begin_inset Formula $T_{n}$
\end_inset

 and 
\begin_inset Formula $T_{n+1}$
\end_inset

 we have also added at least one path to the left and one path to the right,
 and moreover a finite number of paths on each side.
 Thus,
 in this case 
\begin_inset Formula $T$
\end_inset

 is seen to have a unique nonprincipal path – the one that follows down all these subtrees – with every other path being isolated.
 Hence,
 
\begin_inset Formula $T$
\end_inset

 is 1rk1,
 and in particular is a three-block tree.
 This concludes all the necessary verifications,
 and the theorem is proven.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
note to self:
 prove also that 
\begin_inset Formula $\omega+\omega^{*}$
\end_inset

 is harder to distinguish,
 requiring 
\begin_inset Formula $0'''$
\end_inset

,
 which is why 
\begin_inset Formula $\Linear$
\end_inset

 is so much easier to compute.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "C:/Users/gaming/Desktop/theorems/misc/logic/bibliography"
options "plain"
encoding "default"

\end_inset


\end_layout

\end_body
\end_document
